{"meta":{"title":"覽月維基","subtitle":null,"description":"明明如月，何時可掇？如切如磋，如琢如磨，衣帶漸寬而終不悔","author":"Lshare","url":"https://linlshare.github.io"},"pages":[{"title":"About","date":"2019-01-13T11:37:46.794Z","updated":"2019-01-13T11:37:46.794Z","comments":true,"path":"about/index.html","permalink":"https://linlshare.github.io/about/index.html","excerpt":"","text":"藍月維基是我的個人維基，忠實地記錄我的所知。我認為每個人，確切地說是每個有知識追求的人，都應該建立自己的維基庫，不論是什麼形式的都可以，記錄自己的認知，更新自己的認知；如果不介意，還可以分享自己的認知，正如覽月維基一般。 在沒有建立維基庫時，一旦我需要某項知識我會檢索互聯網，一頁有一頁，然後找尋到所要的知識用於解決問題，但是當問題再次出現時，我又陷入了這個循環。呵，生命是如此短暫，我又何必在循環中浪費呢？我抗擊遺忘的方式就是記錄和不斷更新，一旦需要某項知識，第一時間在個人維基庫里檢索，溫習，然後再更新。如此反復，知識就得到了鞏固和提升。 對了，下面是我的名片，歡迎郵件交流。 名字 Lshare 性別 男 ♂ 年齡 90後 愛好 女 ♀、漢字、平均律 🎵、網上衝浪 🏄、攝影 📸 etc. 星座 獅子座 🦁 坐標 廣州🗼 職業 程序員 🐒 座右銘 事如春夢了無痕 症狀 強迫症（會對博客上一點點的顏色不順眼調一整天）、社恐症（與其社交不如喝茶看書） 覺得開心的事情 🙃 陽光正好，靜靜地看玩一本喜歡的書。微風習習，跟三兩好友談笑風生。困擾的問題用代碼輕鬆實現了。週末邊吃飯邊看美劇。工作日早上下暴雨，又有理由請假了。聽說 Google 解封了。 更多 Github 、Lshare@outlook.com"},{"title":"Categories","date":"2019-01-13T11:37:46.795Z","updated":"2019-01-13T11:37:46.795Z","comments":true,"path":"categories/index.html","permalink":"https://linlshare.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-13T11:37:46.798Z","updated":"2019-01-13T11:37:46.798Z","comments":true,"path":"tags/index.html","permalink":"https://linlshare.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DynamoDB","slug":"it/java/aws/DynamoDB","date":"2019-01-19T03:14:51.000Z","updated":"2019-01-21T12:53:02.198Z","comments":true,"path":"2019/01/19/it/java/aws/DynamoDB/","link":"","permalink":"https://linlshare.github.io/2019/01/19/it/java/aws/DynamoDB/","excerpt":"","text":"基本概念 Table（表），与其他数据库的表的概念一致，即为数据的集合。 Items（数据项），代表一行数据。 Attributes（属性），一个数据项可由多个属性构成，一个属性由属性名、属性值类型和属性值构成。 Partition Key（分区键），即是最简单的主键，由一个属性构成，一张表有且只有一个分区键。由于 DynamoDB 内部在存储数据时使用分区键的 Hash 值实现跨多个分区的数据项目平均分布，故分区键又称之为 Hash Key。 Sort Key（排序键），排序键和分区键构成另一种主键，用于在分区中按排序键排序。由于 DynamoDB 内部按照排序键值有序地将具有相同分区键的项目存储在互相紧邻的物理位置，故排序键又称之为 Range Key。 Secondary Indexes（二级索引），这样命名应该是将主键视为一级索引。DynamoDB 的二级索引有两种： Global secondary index（GSI），创建跟主键不同的分区键和排序键的索引，DynamoDB 有最多创建 20 个 GSI 的限制； Local secondary index（LSI），创建跟主键的分区键相同但是排序键相异的索引，当且仅当创建表时可用，DynamoDB 有最多创建 5 个 LSI 的限制； 配置本地开发环境下载 DynamoDB 本地版本从 计算机上的 DynamoDB（可下载版本）- aws 下载，并放置到合适的位置。 配置1234&gt; aws configure --profile local AWS Access Key ID [None]: fake-akAWS Secret Access Key [None]: fake-skDefault region name [None]:Default output format [None]: 启动1java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb CLI 操作 注意：如果是本地版本需要添加 --endpoint-url http://localhost:8000 12345678910111213141516171819202122232425262728293031# 创建表格aws dynamodb create-table \\ --table-name ab-debug-proxy \\ --attribute-definitions \\ AttributeName=host,AttributeType=S \\ AttributeName=port,AttributeType=N \\ AttributeName=channel,AttributeType=S \\ --key-schema AttributeName=host,KeyType=HASH AttributeName=port,KeyType=RANGE \\ --global-secondary-indexes IndexName=channel-index,KeySchema=[\"&#123;AttributeName=channel,KeyType=HASH&#125;\"],Projection=\"&#123;ProjectionType=ALL&#125;\",ProvisionedThroughput=\"&#123;ReadCapacityUnits=1,WriteCapacityUnits=1&#125;\" \\ --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 \\ --endpoint-url http://localhost:8000# 删除表格aws dynamodb delete-table \\ --table-name ab-debug-proxy \\ --endpoint-url http://localhost:8000# 列出所有表格aws dynamodb list-tables --endpoint-url http://localhost:8000# 添加数据项aws dynamodb put-item \\ --table-name ab-debug-proxy \\ --item '&#123;\"host\": &#123;\"S\": \"192.168.1.0\"&#125;,\"port\": &#123;\"N\": \"9090\"&#125;,\"channel\": &#123;\"S\": \"sw\"&#125; &#125;' \\ --return-consumed-capacity TOTAL \\ --endpoint-url http://localhost:8000# 扫描数据项aws dynamodb scan \\ --table-name ab-debug-proxy \\ --endpoint-url http://localhost:8000 Java 操作批量加载（Batch Load）12345678910List&lt;KeyPair&gt; keyPairList = new ArrayList&lt;&gt;();for (Proxy proxy : proxyList) &#123; KeyPair keyPair = new KeyPair(); keyPair.setHashKey(proxy.getHost()); keyPair.setRangeKey(proxy.getPort()); keyPairList.add(keyPair);&#125;Map&lt;Class&lt;?&gt;, List&lt;KeyPair&gt;&gt; keyPairForTable = new HashMap&lt;&gt;();keyPairForTable.put(Proxy.class, keyPairList);Map&lt;String, List&lt;Object&gt;&gt; stringListMap = dynamoDBMapper.batchLoad(keyPairForTable); 排错Scan 过滤 Boolean 类型字段时返回为空1234567891011Map&lt;String, AttributeValue&gt; eav = new HashMap&lt;&gt;();Map&lt;String, String&gt; ean = new HashMap&lt;&gt;();StringBuilder filterExpressionBuilder = new StringBuilder();eav.put(\":valid\", new AttributeValue().withBOOL(proxy.getLocked()));ean.put(\"#valid\",\"valid\");filterExpressionBuilder.append(\"#valid = :valid\");DynamoDBScanExpression scanExpression = new DynamoDBScanExpression().withConsistentRead(false) .withExpressionAttributeValues(eav) .withExpressionAttributeNames(ean) .withFilterExpression(filterExpressionBuilder.toString());PaginatedScanList&lt;Proxy&gt; result = dynamoDBMapper.scan(Proxy.class, scanExpression); DynamoDB 存储 Boolean 类型时其实是使用 Number 类型存储，进行过滤时不能使用布尔值进行过滤，而是要使用 “0” （false）和 “1”（true），更改如下： 1eav.put(\":valid\", new AttributeValue().withN(proxy.getLocked() ? \"1\" : \"0\")); DynamoDBMappingException调用 DynamoDB 的 batchSave 接口发生以下错误： 12345678com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMappingException: not supported; requires @DynamoDBTyped or @DynamoDBTypeConverted at com.amazonaws.services.dynamodbv2.datamodeling.StandardModelFactories$Rules$NotSupported.set(StandardModelFactories.java:664) at com.amazonaws.services.dynamodbv2.datamodeling.StandardModelFactories$Rules$NotSupported.set(StandardModelFactories.java:650) at com.amazonaws.services.dynamodbv2.datamodeling.StandardModelFactories$AbstractRule.convert(StandardModelFactories.java:709) at com.amazonaws.services.dynamodbv2.datamodeling.StandardModelFactories$AbstractRule.convert(StandardModelFactories.java:691) at com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel.convert(DynamoDBMapperFieldModel.java:138) at com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper.batchWrite(DynamoDBMapper.java:1107) at com.amazonaws.services.dynamodbv2.datamodeling.AbstractDynamoDBMapper.batchSave(AbstractDynamoDBMapper.java:173) 原来在注解为 @DynamoDBTable 的实体类中使用了自定义类型的字段，DynamoDB 并不支持。 解决方案：在该自定义类型的字段上添加注解 @DynamoDBTypeConvertedJson 即可，原理是使用 Jackson 将该字段的值 json 化再存储。如果不想要 Jackson ，可以自定义转化器，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// CustomTypeConverter.javapublic class CustomTypeConverter&lt;T&gt; implements DynamoDBTypeConverter&lt;String, T&gt; &#123; private Class&lt;T&gt; clazz; public CustomTypeConverter(Class&lt;T&gt; clazz) &#123; this.clazz = clazz; &#125; @Override public String convert(T object) &#123; return Json.toJson(object); &#125; @Override public T unconvert(String json) &#123; return Json.fromJson(json, clazz); &#125;&#125;// JobTreeConverter.javapublic class JobTreeConverter extends CustomTypeConverter&lt;JobTree&gt; &#123; public JobTreeConverter(Class&lt;JobTree&gt; clazz) &#123; super(clazz); &#125;&#125;// JobGroup.java@DynamoDBTable(tableName = \"job-group\")public class JobGroup implements Serializable &#123; @DynamoDBHashKey(attributeName = \"id\") @SerializedName(\"id\") private String id; @SerializedName(\"name\") private String name; @DynamoDBTypeConverted(converter = JobTreeConverter.class) @DynamoDBAttribute(attributeName = \"default_job_tree\") @SerializedName(\"default_job_tree\") private JobTree defaultJobTree; //...&#125; 参考 计算机上的 DynamoDB（可下载版本）- aws Instroduction - Amazon DynamoDB DynamoDB API 文档 -aws","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"aws","slug":"it/java/aws","permalink":"https://linlshare.github.io/categories/it/java/aws/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"aws","slug":"aws","permalink":"https://linlshare.github.io/tags/aws/"},{"name":"DynamoDB","slug":"DynamoDB","permalink":"https://linlshare.github.io/tags/DynamoDB/"}]},{"title":"AWS Lambda 服务","slug":"it/serverless/AWS Lambda 服务","date":"2019-01-17T14:40:52.000Z","updated":"2019-01-18T12:58:15.087Z","comments":true,"path":"2019/01/17/it/serverless/AWS Lambda 服务/","link":"","permalink":"https://linlshare.github.io/2019/01/17/it/serverless/AWS Lambda 服务/","excerpt":"","text":"简介Lambda 是 AWS 提供的一个无服务器架构的服务，用户只需要专注于写代码而不用关心部署，通常需要关心外部事件源，可以与 API Gateway, SNS, S3, DynamoDB 等等配合使用。 本质简单粗暴地说，一个 Lambda 就是一个 Docker 服务或者 Firecracker 服务，Firecracker 是 AWS 开源的一个类似 Docker 的服务，AWS 计划将所有的 Lambda 实现改为 Firecracker。因此，当 Lambda 第一次被调用时通常会比较慢，因为服务需要先进行冷启动，但接下来的调用就会快很多了。 支持 默认支持 6 种编程语言（.Net, Python, Node.js, Java, Go, Ruby）； 支持自定义运行时（仓库 mthenw/awesome-layers 中罗列了一些开源的运行时）； 支持Lambda 之间的共享库（类似 Docker 的 Layer 概念），方便各个 Lambda 之间共用公共代码； 支持版本控制； 支持红蓝发布，即将请求按比例发送到不同版本的 Lambda 函数中。 限制 非预留账户并发 1000（注意：不是单个函数，而是单个 AWS 账户），提升需提 case； 单个函数内存占用 128M ~ 3008M； 单个函数最长运行时间是 15分钟； 单个函数最多只能包含 5 个函数层（即共享库）； 单个函数部署包压缩状态下不得超过 50 MB，解压状态不得超过 250 MB； 单个区域（Region）Lambda 函数的总大小不得超过 75 GB。 费用 计费方式：需按使用量计费，具体为函数的请求数量、持续时间和内存量。 免费套餐：每个月 100万请求，及 400000GB-秒。 免费之后：每 100 万个请求 0.20 USD，每 GB-秒 0.00001667 USD。 参考 AWS Lambda - aws（AWS Lambda 的官方开发人员指南） AWS Lambda 定价 - aws","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"serverless","slug":"it/serverless","permalink":"https://linlshare.github.io/categories/it/serverless/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"https://linlshare.github.io/tags/Lambda/"},{"name":"AWS","slug":"AWS","permalink":"https://linlshare.github.io/tags/AWS/"}]},{"title":"漢字雜談","slug":"language/漢語言/漢字雜談","date":"2019-01-16T13:40:38.000Z","updated":"2019-01-17T01:03:15.163Z","comments":true,"path":"2019/01/16/language/漢語言/漢字雜談/","link":"","permalink":"https://linlshare.github.io/2019/01/16/language/漢語言/漢字雜談/","excerpt":"","text":"文字伊始我們的祖先原本生活在資源豐富的非洲森林里，後來也許森林退化，被迫暴露在草原之上，開始試著直立抬頭尋找食物和警惕天敵。到 250 萬年前，能人已經學會了製造石器；隨後在 150 萬年前，匠人學會了使用火；再到 16 萬年前埃塞爾比亞的長者智人出現了喪葬儀式。自從學會了直立行走、製造石器和使用火，人類行走的範圍越來越廣，接收的信息量原來越多，面臨的挑戰越來越大，腦容量也越來越發達，據說 35.5 萬年前的海德堡人腦容量已經有現代人 93%了。 人類誕生已經是相當久遠的過去了，但開始使用文字亦不過幾千年的時光。直到約 8600 年左右，人類開始使用一些文字符號，有河南漯河出土的賈湖契刻為證，但因為尚無法破譯，且出土量較少，無法滿足我們對文字的定義。真正意義上的文字當屬約 5500 年前兩河流域的蘇美爾人的楔形文字，它是世界上最早的文字。而我們中國最早的文字當是約 3400 年前的甲骨文，有河南安陽殷墟出土的甲骨為證。另外如今全世界都在使用的字母始於約 2000 年前生活在地中海的腓尼基人使用的腓尼基字母。那時的人類使用文字進行交流，與人交流更與神交流；使用文字進行記錄，記錄生活更記錄歷史。 早期的文字無一例外都是象形文字，而延綿至今的象形文字除漢字外無二。近兩百多年英語獨步世界的情況似乎昭示著象形文字勢必被字母文字取而代之，但無論如何且勿擅改文字，文字自有其生命力，比之三千年的生命力，這兩百多年的經驗實在太短了。 漢字六書漢字這近百年來被誤解太深了，人們以為漢字只是象形文字，沒有表音的功能，學習起來成本高，從而導致國民文盲率高。殊不知漢字除象形外，還有另外五種造字方法，分別是指事、會意、形聲、假借和轉注。這六種方法在《漢書》中稱之為 “六書”。在早期使用象形、指事、會意造字較多，以後則以形聲、轉注和假借造字為主。 所謂象形即是畫出物體的形狀，但據我所知通常不會完整畫出物體的形狀，而是進行了提煉，提煉出物體的核心特征予以表現，如甲骨文「人」字，表現了能直立，膝蓋會向前彎曲的人的側面形象；指事就更抽象了，使用純符號（點、劃）以在象形的基礎上表達抽象的含義，如甲骨文「上」字是在一條橫線上加一短劃，表達上面的抽象概念；會意則是將幾個漢字的基礎部件組合成起來表達一個新的含義，如「武」字由「止」（腳趾、前進）與「戈」（武器）構成，表達軍隊出征的含義；而形聲是有形符和聲符構成，形符表達其所屬類別，聲符表達其音，形聲造字的出現是為了解決先有語言而後有文字的書寫場景，以化學元素為例：元素 Ra，英文為「Radium」，是法國人居里夫人及其丈夫發現的一種放射性元素，有音但無中國文字，怎麼辦呢？我們取同音符「雷」和表達其屬類的形符「金」，組合成「鐳」完美解決了這一問題。再說到假借，假借是一字多義的源頭，試以「長」為例，甲骨文「長」象一長髮老者拄扙之形，本義就是長者、老人，後假借「長髮」而有尺寸長短的義項，假借「長者」而有市長的義項。漢字活用避免了漢字數量的爆炸。最後一項造字法，也是爭議最大的一項——轉注，依我淺見，轉注就是將原本含有多義項的字，加註符號析出其中一個義項，比如甲骨文「老」表示拄扙的老人，泛指一切老人，為了表達老父親的概念，加「丂」符造出「考」；又如甲骨文「來」是麥子的象形，也有到來的義項，為專指到來之意造出「麥」字，但因為後來「來」經常被借用表到來的意思，反而用了「麥」來表示麥子的意思。 漢字與外來語日語採用片假名吸收外來語，僅吸收了其音，雖然吸收快且多，如コーヒー（咖啡）、アメリカ（美國）、コンピュータ（電腦）、ケーキ（蛋糕）、シャツ（襯衫）等等，但在我看來并不是很高明。漢語吸收外來語的能力比之更為強大。19世紀中葉，中國的大門被人家用鴉片（opium）和大炮打開了，我們被迫融入新的世界秩序，從此我們知道了我們的友鄰是如何強大，他們的文化也絕非蠻夷，我們不再妄自尊大，正視了自身的位置，認真地去向強國學習，吸收了許多新詞彙。這些詞彙不僅有音譯的，比如布爾什維克（большевик）、馬克思（Marx）、美國（America，早期譯為美利堅）、喬叟（Chaucer）、莎士比亞（Shakespeare）、貝多芬（Beethoven）、因特網（Internet）、卡通（cartoon）、壽司（すし）、谷歌（Google）、迪士尼（Disney）；還有形聲的，如鈾（Uranium）；有會意的，如電話（telephone）、电脑（computer）、手機（mobile phone）、軟件（software）；更有假借的，如氧（Oxygen）、民主（democracy，早期音譯為德謨克拉西）、科學（science，早期音譯為賽因斯）、憲法（constitution）、合同（contract）等等。信息的爆炸使得我們來不及造單字了，我們通常以詞為單位擴充漢語的詞彙，還有許多詞我們以英文形式或其縮寫形式整體消化，多見於科技詞彙，比如 AI、Java、BBC等。 走向世界隨著國門的開放，中國也重新對外輸出詞彙，比如： Kung Fu（功夫）、Tao（道）、Qi（氣）、Chopsticks（筷子）、Lychee（荔枝）、Confucius Institute（孔子學院）、GFW（防火长城）、Alibaba（阿里巴巴）、Guanxi（關係）等等。漢字正重新向世界展示其蓬勃的生命力，但還不是最嚴謹、最優美而內涵最豐富的模樣，需要文字學家、語言學家、政府、社會各界與文字愛好者一道努力，讓美好的事情發生。 參考 人類演化進程 - 維基百科 六書 - 維基百科 漢語多功能字庫","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"漢語言","slug":"language/漢語言","permalink":"https://linlshare.github.io/categories/language/漢語言/"}],"tags":[{"name":"漢字","slug":"漢字","permalink":"https://linlshare.github.io/tags/漢字/"}]},{"title":"JSONPath","slug":"it/robot/JSONPath","date":"2019-01-14T11:16:57.000Z","updated":"2019-01-14T11:33:31.204Z","comments":true,"path":"2019/01/14/it/robot/JSONPath/","link":"","permalink":"https://linlshare.github.io/2019/01/14/it/robot/JSONPath/","excerpt":"","text":"概要JSONPath，XPath for JSON，是仿造 XPath 进行 JSON 定位的一套语法。 基本语法 XPath JSONPath Description / $ 根对象或元素 . @ 当前对象或元素 / . or [] 子操作 .. n/a 父操作 // .. 向下遍历，创意来自 E4X * * 通配 @ n/a 获取属性，但 JSON 结构没有任何属性 [] [] 下标操作。XPath 用来迭代元素集合和断言，在 Javascript 和 JSON 中则是数组操作 \\ [,] 连结操作。在 XPath 中为将节点集合并。 JSONPath 允许选择名称和索引作为集合。 n/a [start:end:step] 数组切片操作。创意来自 ES4 [] ?() 执行一个过滤脚本表达式 n/a () 脚本表达式 () n/a XPath 中的分组操作 参考 JsonPath - goessner.net（详细介绍了 JSONPath 语法） JSONPATH Expression Tester - jsonpath.curiousconcept.com（绝好的测试 JSONPath 语法的在线工具）","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"robot","slug":"it/robot","permalink":"https://linlshare.github.io/categories/it/robot/"}],"tags":[{"name":"JSONPath","slug":"JSONPath","permalink":"https://linlshare.github.io/tags/JSONPath/"}]},{"title":"瘦肉粥","slug":"recipe/瘦肉粥","date":"2019-01-13T16:21:18.000Z","updated":"2019-01-13T16:42:25.368Z","comments":true,"path":"2019/01/14/recipe/瘦肉粥/","link":"","permalink":"https://linlshare.github.io/2019/01/14/recipe/瘦肉粥/","excerpt":"","text":"食材準備 材料 參考量 參考單價 參考價格 瘦肉 ? 2.2元 米 80ML（煮成約3碗粥） 4元/斤 &lt;1元 烹飪過程 淘米，根據具體電飯煲的要求加入適量的水，煮粥； 將瘦肉切成細長狀肉絲，加鹽爪拌，醃製10分鐘； 粥快熟了，加入預備好的瘦肉，攪拌，繼續煮10分鐘； 開鍋享用。 參考 皮蛋瘦肉粥 - 下厨房","categories":[{"name":"recipe","slug":"recipe","permalink":"https://linlshare.github.io/categories/recipe/"}],"tags":[{"name":"Recipe","slug":"Recipe","permalink":"https://linlshare.github.io/tags/Recipe/"}]},{"title":"明清時期澳門華人社會研究論文集","slug":"history/明清時期澳門華人社會研究論文集","date":"2019-01-13T11:37:46.355Z","updated":"2019-01-13T11:37:46.356Z","comments":true,"path":"2019/01/13/history/明清時期澳門華人社會研究論文集/","link":"","permalink":"https://linlshare.github.io/2019/01/13/history/明清時期澳門華人社會研究論文集/","excerpt":"","text":"KEY VALUE 作者/編者 林廣志 陳文源 出版社 澳門基金會 出版日期 2018年03月 ISBN 978-99937-1-247-3 頁數 775 在線閱讀 前言──明清時期澳門華人社會研究的回顧與前瞻 金國平、吳志良認為，兩宋時期澳門已是客家先民從中原遷徙、開發華南的歷史足跡之一。 客家人足跡遍佈大半個中國，了不起。 總體而言，目前澳門華商家族的研究，大多關注晚清居澳華商的經濟狀況、社會地位以及參與社會公益、國內政治活動，對於由葡國管治下傳統華人家族觀念、家族維繫因素、家族企業經營方式以及家族與社會勾聯等極具特色的內容，仍需進行學理性的梳理，這種梳理對深入理解澳門近代社會的構成和發展無疑具有重要意義。 從家族社會或者說熟人社會，往現代社會發展的過程是重點。 居澳華人在澳門經濟發展過程中的角色，經歷由葡商附庸型到澳門經濟主控型的轉變。在鴉片戰爭前，華人主要是從事通事、買辦、小商販、手工、僕役等葡商附庸性的工作…… 19 世紀初，清政府兩次修訂對外策，對日漸增強的澳門華商團體予以沉重的打擊:一是實施禁煙政策，懲辦了一批華人鴉片商;二是為抗擊葡國在澳門推行強硬的殖民政策，廣東政府實施了“以商制夷”策略，將居澳華商遷至黃埔港。經歷了這兩次重大事件，剛剛萌生的澳門華商財團勢力嚴重受挫。 19 世紀 40 年代，葡國政府為了挽回澳門貿易被邊緣化的危機，追隨英國在香港的政策，擅自宣佈澳門為自由港，並在澳門推行強硬的殖民政策，強拆中方官署。由於洋船駛往香港，居澳華商遷至黃埔，澳門並沒能因其“自由”而繁榮起來，反而因失去華商而陷入衰落，致使澳葡政府財政陷入危機。為了扭轉日益惡化的財政狀況，澳葡政府開始對賭博業與一些重要民生物資 (如豬肉等) 實施專營制度。 50 年代，由於國內民亂，大批華人攜資避難澳門，而澳葡政府的專營制度為這些新移民者提供了新的營商機會。在這樣的環境下，華人以其資本與勇氣，逐漸壟斷了澳門大部分專營行業，大至賭博經營、鴉片貿易、苦力貿易，小至食品經營、手工車服務、街燈管理等等，華人成為澳門經濟發展最重要的力量。 怎麼做到的？時運輪轉。 清政府嚴禁鴉片，轉移居澳華商 –&gt; 40年代葡國殖民澳門，陷入財政危機 –&gt; 實施賭博業和重要民生物資專營制度 –&gt; 50年代國內民亂，華人攜資避難澳門 –&gt; 華人壟斷大部分專營行業。 1582 年，澳門議事會成立，此後逐漸形成華葡分治的政治格局。葡王於 1589年發佈訓令，明確規定議事會不得干預華人事務，但華人天主教徒例外…… 華葡分治”是明清時期澳門社會管治的特徵，但明清政府主要是管主權、管邊防、管稅收。亞馬留事件後，儘管澳葡政府極力拉攏居澳華人，但對居澳華人的社會生活卻力不從心。因此，實質上華人社會長期處於“管而不理”的狀態，澳門華人社會內部更多地依賴中葡之外的“第三權力”進行調節。湯開建認為，鏡湖醫院是由當時華人精英籌建，在華人社會中具有極高的公信力，鏡湖醫院不僅從事一般性的慈善公益活動，也是華人集議商事的重要機構……林廣志對華人社會組織進行了歷史考察，認為澳門華人組織從漁農社會到近代商業社會的發展歷經了五個階段:第一是以媽閣廟、蓮峰廟為代表的神緣性組織;第二是以三街會館為代表的業緣性組織;第三是以鏡湖醫院、同善堂為代表的慈善性組織;第四是以宜安公司等為代表的聯誼性組織;第五是以澳門商會為代表的政商性組織，這些組織大多承擔起華人社會解決糾紛、集議商事的功能，逐漸形成華人社會管的“第三權力”。 華人的事務明清政府不管，葡人又管不了，只能靠民間團體自治了。聯繫澳門華人的紐帶由神、職業、慈善組織、聯誼組織變化到政商組織。原來設立澳門行政區是有其自治背景的。 孫中山在澳門行醫得到了一眾華商的熱心支持，但在其尋覓革命的“熱心同志”時卻遭受“冷遇”，原因是澳門華商普遍不贊成孫之“激烈之主張”。 據孫中山澳門行醫足跡 - 大公網，孫先生1892年畢業于香港西醫書院，后到澳門鏡湖醫院為華人義診，成為該院首位西醫。 澳門社會的複雜性是眾所周知的，所謂“小澳門，多內涵;表象單純，深層複雜”。 一、人口家族晚清澳門華人巨商盧九家族事跡考述 - 林廣志 盧九(1848 - 1907)，原名華紹，字育諾，號焯之，小名 ，廣東新會潮連鄉人。盧九是 19 世紀下半葉澳門的“一代賭王”，也是當時澳門政治、經濟及社會生活中最有影響的華商代表之一。幾十年間，盧九及其家族縱橫省澳，際會風雲，專擅煙賭，旁及其餘，熱心社群，樂善好施，在華葡社會享有極高的聲譽。 盧家大屋 盧廉若公園 文字比較 大陆简体 台灣繁體 澳門繁體 研究 研究 硏究 打拼 打拼 打 节假 節假 節假 判断 判斷 斷 学者 學者 學者 价值 價值 價値 读书 讀書 書 契约 契約","categories":[{"name":"history","slug":"history","permalink":"https://linlshare.github.io/categories/history/"}],"tags":[{"name":"History","slug":"History","permalink":"https://linlshare.github.io/tags/History/"},{"name":"澳門","slug":"澳門","permalink":"https://linlshare.github.io/tags/澳門/"}]},{"title":"薑絲黃酒炒花蛤","slug":"recipe/薑絲黃酒炒花蛤","date":"2019-01-13T10:59:07.000Z","updated":"2019-01-13T11:37:46.779Z","comments":true,"path":"2019/01/13/recipe/薑絲黃酒炒花蛤/","link":"","permalink":"https://linlshare.github.io/2019/01/13/recipe/薑絲黃酒炒花蛤/","excerpt":"","text":"食材準備 材料 參考量 參考單價 參考價格 花蛤（花甲、蜆） 半斤多一點 11元/斤 6元 黃酒（紹酒） 半勺（約40ML） 約25元/瓶（2.5L） 0.4元 薑絲 一小塊 ？ ？ 食用油 半勺 ？ ？ 烹飪過程 先將花蛤泡水洗淨，約10分鐘； 先將薑絲切成小細條狀； 鍋底下油，油起泡后下薑絲，煎至金黃； 下花蛤，蓋上蓋子，至花蛤開口即可，約3分鐘； 連同乳白色的湯一起出鍋； 可加少量芹菜配色。 提示： 花蛤生活在灘塗中，含沙較多，建議購買用水沖過一點時間的以避免洗花蛤的麻煩； 花甲本身含水較多，所以整個過程無需加水； 結果 參考 名廚家常菜｜薑絲黃酒炒花蛤 - YouTube.com（看完需1分19秒）","categories":[{"name":"recipe","slug":"recipe","permalink":"https://linlshare.github.io/categories/recipe/"}],"tags":[{"name":"Recipe","slug":"Recipe","permalink":"https://linlshare.github.io/tags/Recipe/"}]},{"title":"拯救大兵瑞恩","slug":"movie/拯救大兵瑞恩","date":"2019-01-06T06:57:22.000Z","updated":"2019-01-13T11:37:46.608Z","comments":true,"path":"2019/01/06/movie/拯救大兵瑞恩/","link":"","permalink":"https://linlshare.github.io/2019/01/06/movie/拯救大兵瑞恩/","excerpt":"","text":"基本信息123456789101112131415161718192021222324252627282930&#123; \"IMDb编码\": \"tt0120815\", \"原名\": \"Saving Private Ryan\", \"又名\": [\"拯救大兵瑞恩\", \"雷霆救兵(港)\", \"抢救雷恩大兵(台)\"], \"上映日期\": [\"1998-07-24(美国)\"], \"片长\":\"169分钟\", \"语言\": [\"英语\", \"法语\", \"德语\", \"捷克语\"], \"制片国家/地区\": \"美国\", \"官方网站\": \"http://www.rzm.com/pvt.ryan/index.html\", \"类型\": [\"剧情\", \"历史\", \"战争\"], \"导演\": \"史蒂文·斯皮尔伯格\", \"编剧\": \"罗伯特·罗达特\", \"主演\": [ \"汤姆·汉克斯\", \"汤姆·塞兹摩尔\", \"爱德华·伯恩斯\", \"巴里·佩珀\", \"亚当·戈德堡\", \"范·迪塞尔\", \"吉奥瓦尼·瑞比西\", \"杰瑞米·戴维斯\", \"马特·达蒙\", \"特德·丹森\", \"保罗·吉亚玛提\", \"丹尼斯·法里纳\", \"马克斯·马蒂尼\", \"丹兰·布鲁诺\", \"安德鲁·斯科特\" ]&#125; 自问自答拯救大兵瑞恩是确有其事吗？首先这是电影的虚构，但虚构并非无所凭据，二战时期兄弟参军皆阵亡的事多如牛毛。流传广泛的有苏利文五兄弟事件： 1942年的1月3日，乔、法兰克、艾尔、麦特以及乔治这五兄弟共同加入了美国海军，随后在11月12日，苏利文五兄弟所服役的朱诺号轻型巡洋舰经过三个多月的瓜岛战役舰身受损，在退回埃斯皮里图桑托岛途中受日军舰艇鱼雷攻击，五兄弟相继阵亡。 其实电影是基于来自纽约州托纳旺达市奈兰德兄弟的故事，詹姆斯·瑞恩（马特·达蒙 饰）的原型就是弗莱德里克·奈兰德。 名字 年龄 军衔 部门 战斗地点 关键事件 罗伯特·奈兰德(Robert “Bob” Niland) 25 中士 第82空降师，第505空降步兵团 德国圣迈瑞.埃格利斯镇（诺曼底） D-Day（诺曼底登陆日，1944年6月6日）阵亡 普列思顿·奈兰德(Preston Niland) 29 中尉 第22步兵团，第4步兵师 德国犹他州滩头（诺曼底） 1944年6月7日，阵亡 艾德华·奈兰德(Edward Niland) 31 中士 美国陆军航空兵 缅甸 1944年5月16日，被俘，美军误以为阵亡 弗莱德里克·奈兰德(Frederick “Fritz” Niland) 24 中士 第101空降师，第501伞兵团 诺曼底 D-Day 后的几天，辗转英国，回到美国。 二战后美军如何避免瑞恩式的家庭悲剧？美军在二战后制定了仅存者政策（Sole Survivor Policy），以用来在某一人士遭逢家中成员（如兄弟姐妹）于从军期间殉职的变故时，保护其得以不被征召入伍、或免除参加战斗任务。 参考 Niland brothers - Wikipedia 电影《拯救大兵瑞恩》中的“瑞恩”到底是谁？ - 凤凰网 仅存者政策 - 维基百科","categories":[{"name":"movie","slug":"movie","permalink":"https://linlshare.github.io/categories/movie/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://linlshare.github.io/tags/电影/"}]},{"title":"T·S·艾略特","slug":"literature/T·S·艾略特","date":"2018-12-31T14:38:19.000Z","updated":"2019-01-13T11:37:46.603Z","comments":true,"path":"2018/12/31/literature/T·S·艾略特/","link":"","permalink":"https://linlshare.github.io/2018/12/31/literature/T·S·艾略特/","excerpt":"","text":"KEY VALUE 原名 Thomas Stearns Eliot 译名 T·S·艾略特 出生地 美国密苏里州圣路易斯 生卒 1888年9月26日 - 1965年1月4日 风格 身份 诗人、剧作家、评论家、编辑 代表作 《荒原》（The Waste Land，1922年） 影响力 1948年获得诺贝尔文学奖；诗作《荒原》被视为英美文学的里程碑 参考 T·S·艾略特 - 维基百科 荒原 - 维基文库","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"T·S·艾略特","slug":"T·S·艾略特","permalink":"https://linlshare.github.io/tags/T·S·艾略特/"}]},{"title":"狄兰·托马斯","slug":"literature/狄兰·托马斯","date":"2018-12-31T13:21:19.000Z","updated":"2019-01-13T11:37:46.605Z","comments":true,"path":"2018/12/31/literature/狄兰·托马斯/","link":"","permalink":"https://linlshare.github.io/2018/12/31/literature/狄兰·托马斯/","excerpt":"","text":"KEY VALUE 原名 Dylan Thomas 译名 狄兰·托马斯 出生地 英国威尔士 生卒 1914年10月27日－1953年11月9日 风格 超现实主义 身份 诗人 代表作 诗集《诗十八首》、《死亡和出场》；《不要温和地走进那个良夜》、《穿过绿色茎管催动花朵的力》、《挽歌》、《而死亡也不得统治万物》 之外 喝酒、再喝酒；写诗、不写诗； 《不要温和地走进那个良夜》在电影《星际穿越》中不时吟唱，很有力量。 参考 狄兰·托马斯 - 维基百科 Dylan - dylanthomas.com","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"狄兰·托马斯","slug":"狄兰·托马斯","permalink":"https://linlshare.github.io/tags/狄兰·托马斯/"}]},{"title":"蒲柏","slug":"literature/蒲柏","date":"2018-12-30T15:20:22.000Z","updated":"2019-01-13T11:37:46.607Z","comments":true,"path":"2018/12/30/literature/蒲柏/","link":"","permalink":"https://linlshare.github.io/2018/12/30/literature/蒲柏/","excerpt":"","text":"KEY VALUE 原名 Alexander Pope 译名 亚历山大·蒲柏 出生地 英格兰伦敦 生卒 1688年5月21日-1744年5月30日 风格 英雄双行体 身份 诗人 代表作 《批评论》、《夺发记》、《伊利亚特》译本 受影响于 荷马、乔叟、莎士比亚等等 影响力 18世纪英国最伟大的诗人；影响了拜伦等诗人","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"蒲柏","slug":"蒲柏","permalink":"https://linlshare.github.io/tags/蒲柏/"}]},{"title":"荷马","slug":"literature/荷马","date":"2018-12-30T15:01:23.000Z","updated":"2019-01-13T11:37:46.606Z","comments":true,"path":"2018/12/30/literature/荷马/","link":"","permalink":"https://linlshare.github.io/2018/12/30/literature/荷马/","excerpt":"","text":"KEY VALUE 原名 Ὅμηρος 译名 荷马 国籍 古希腊 生卒 不详，约莫公元前8世纪 风格 荷马史诗 身份 吟游诗人 代表作 《伊利亚特》（希腊语：Ιλιάς，转写：Iliás）、《奥德赛》（古希腊语：Ὀδύσσεια，转写：Odýsseia，英语：Odyssey） 影响力 荷马被称为欧洲四大史诗诗人之一或之首（另外三人为维吉尔、但丁、米尔顿）；但丁称荷马为“诗人之王” 荷马史诗荷马史诗具有以下特质： 轻快迅捷； 语言风格平易直接； 思想平易直接； 高贵。 《伊利亚特》被发现于18世纪的荷马史诗《伊利亚特》长15,693行，叙述希腊联军围攻小亚细亚的城市特洛伊（又称伊利昂、伊利亚特）的故事，以希腊联军统帅阿伽门农和猛将阿基里斯的争吵为中心，集中描写了战争结束前五十天发生的事情。 内容：《伊利亚特》叙述了特洛伊战争第十年（也是最后一年）中几个星期的活动。史诗以阿基里斯和阿伽门农的争吵开始，以赫克托耳的葬礼结束，故事的背景和最终的结局都没有直接叙述。 在希腊联军中，只有阿基里斯才是赫克托尔的对手，因此他拒绝参战就必然引起希腊联军的失利。希腊联军在此情况下抵御不了特洛亚军队的反攻，只好退而固守海滨的战船，在那里构筑了防守性的壁垒。阿伽门农这时后悔自己对阿基里斯不公，只好派奥德修和另一位希腊将领去向他求和。可是他愤怒未消，坚决不答应回到战争。阿基里斯只是在特洛亚军队已经突破希腊联军的壁垒纵火焚烧他们的战船的十分危急的情况下，才把他的盔甲和战马借给他的好友帕特洛克罗斯，让帕特洛克罗斯前去应敌。帕特洛克罗斯虽然击退了特洛亚军队的攻击，但终为赫克托耳所杀，因此阿基里斯借给他的盔甲也丢掉了，这盔甲原是他的母亲忒提斯女神请匠神制造的。战友之死与盔甲被丢引起阿基里斯的第二次愤怒，而使他与阿伽门农和解，并且在他母亲请匠神给他制造了一副新盔甲之后，重新回到战争，最后杀死了赫克托耳，取得了决定性的胜利。 蒲柏译本罗念生、王焕之译本《奥德赛》《奥德赛》共12,105行，叙述伊塔卡王奥德修斯（又称奥德赛斯、罗马神话中的尤利西斯）在攻陷特洛伊后归国途中十年漂泊的故事，集中描写的是这十年中最后一年零几十天的事情。 内容：主要是连接伊利亚特的剧情，话说经过特洛伊战争之后，在希腊军回家途中，因为英雄奥德修斯（Odysseus）激怒海神波赛顿，所以波赛顿降临灾祸于他，使他们遇到海难，全军覆没。奥德修斯虽因机智和勇敢逃过一劫，但波赛顿的愤怒未息，故使奥德修斯找不到回家的航线而在大海里漂流。而另一方面他的妻子不知奥德修斯的生死，面对着蛮横的求婚者就只有苦等着丈夫的回来。最后在诸神的帮忙下，经过十年漂流生活的奥德修斯终于回到家里与他的妻子团聚，并与儿子和仆人联手杀死了求婚者。 参考 荷马 - 维基百科 伊利亚特 - 维基百科 《伊利亚特》的译本 - 上海人民出版社 奥德赛 - 维基百科","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"荷马","slug":"荷马","permalink":"https://linlshare.github.io/tags/荷马/"}]},{"title":"埃德蒙·斯宾塞","slug":"literature/埃德蒙·斯宾塞","date":"2018-12-30T14:35:03.000Z","updated":"2019-01-13T11:37:46.604Z","comments":true,"path":"2018/12/30/literature/埃德蒙·斯宾塞/","link":"","permalink":"https://linlshare.github.io/2018/12/30/literature/埃德蒙·斯宾塞/","excerpt":"","text":"KEY VALUE 原名 Edmund Spenser 译名 埃德蒙·斯宾塞 出生地 英国伦敦 生卒 1552年－1599年1月13日 风格 斯宾塞诗节 身份 诗人 代表作 《仙后》（The Faerie Queene） 受影响于 乔叟的《坎特伯雷故事集》；维吉尔和他的《埃内阿斯纪》；12世纪吟游诗人的《亚瑟王传说》 影响力 英国著名诗人、桂冠诗人；影响了弥尔顿、雪莱、拜伦、丁尼生、蒲柏等诗人 《仙后》《仙后》是斯宾塞于1590年出版的史诗，仙后喻指伊莉莎白一世女皇。 内容：描述骑士霍理士（圣洁）与公主优娜（真理）一同对抗恶龙（邪恶）的故事。 参考 埃德蒙·斯宾塞 - 维基百科 仙后 - 维基百科","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"埃德蒙·斯宾塞","slug":"埃德蒙·斯宾塞","permalink":"https://linlshare.github.io/tags/埃德蒙·斯宾塞/"}]},{"title":"乔叟","slug":"literature/乔叟","date":"2018-12-30T13:29:28.000Z","updated":"2019-01-13T11:37:46.604Z","comments":true,"path":"2018/12/30/literature/乔叟/","link":"","permalink":"https://linlshare.github.io/2018/12/30/literature/乔叟/","excerpt":"","text":"KEY VALUE 原名 Geoffrey Chaucer 译名 杰弗里·乔叟 出生地 英格兰伦敦 生卒 1343年–1400年10月25日 风格 双韵体诗 身份 诗人、作家、哲学家、炼金术士、天文学家、朝臣、外交官 代表作 《坎特伯雷故事集》（The Canterbury Tales） 受影响于 但丁和他的《神曲》、薄伽丘和他的《十日谈》 影响力 英国中世纪最杰出的诗人、英国中世纪文学和文艺复兴文学之间承上启下的人物、影响了威廉·莎士比亚和埃德蒙·斯宾塞、第一位葬在西敏寺诗人角的诗人。 《坎特伯雷故事集》坎特伯雷是英国肯特郡的市镇，1385年10月，乔叟被指派为肯特郡的治安法官，猜测于此时著作《坎特伯雷故事集》。 内容：故事叙说有30名朝圣者聚集在伦敦一家客店，整装前往70英里外的坎特伯雷。店主哈里‧贝利自告奋勇担任导游，并在晚饭后提议在往返途中每人各讲两个故事，以解五天旅途中的无聊寂寞，看谁的故事讲得最好，可以免费吃一餐好饭。这些朝圣者，有骑士、僧侣、侍从、商人、匠人、纺织匠、医生、地主、农夫、海员、家庭主妇等，代表了广泛的社会阶层。他们讲述的内容，主要包括爱情和骑士探险传奇、宗教和道德故事、滑稽故事、动物寓言等23个故事，大多数的故事都是用双韵诗体写成的，乔叟自己讲了《梅里白的故事》则是散文体，厨师和见习骑士没有讲完故事，其中商人、农民、修女，巴斯妇人，以及卖赎罪券者的故事最为精彩，是本书的精华，基本上《坎特伯雷故事集》是一部未完成的作品。 方重译本参考 杰弗里·乔叟 - 维基百科 坎特伯雷故事集 - 维基百科 乔叟《坎特伯雷故事集》（Geoffrey Chaucer）- 阮一峰的网络日志","categories":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/categories/literature/"}],"tags":[{"name":"literature","slug":"literature","permalink":"https://linlshare.github.io/tags/literature/"},{"name":"乔叟","slug":"乔叟","permalink":"https://linlshare.github.io/tags/乔叟/"}]},{"title":"Trio","slug":"music/Trio","date":"2018-12-28T18:04:59.000Z","updated":"2019-01-13T11:37:46.629Z","comments":true,"path":"2018/12/29/music/Trio/","link":"","permalink":"https://linlshare.github.io/2018/12/29/music/Trio/","excerpt":"","text":"Trio，三重奏。最常见的三重奏形式是钢琴三重奏（钢琴、小提琴及大提琴）以及弦乐三重奏（小提琴，中提琴及大提琴）。 钢琴三重奏数贝多芬（Beethoven），弦乐三重奏数莫扎特（Mozart）。","categories":[{"name":"music","slug":"music","permalink":"https://linlshare.github.io/categories/music/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://linlshare.github.io/tags/Music/"},{"name":"Trio","slug":"Trio","permalink":"https://linlshare.github.io/tags/Trio/"}]},{"title":"WebHook","slug":"it/concept/WebHook","date":"2018-12-27T01:58:14.000Z","updated":"2019-01-13T11:37:46.372Z","comments":true,"path":"2018/12/27/it/concept/WebHook/","link":"","permalink":"https://linlshare.github.io/2018/12/27/it/concept/WebHook/","excerpt":"","text":"概念什么是 WebHook？WebHook，网络钩子，就是一个 HTTP 回调，一个简单的基于 HTTP POST 的事件通知。 WebHook 这个词是由杰夫·林德赛（Jeff Lindsay）于 2007 年首次提出，创意来自编程术语 “Hook”。 WebHook 能干嘛？ 推送（Push）：实时接收数据；不需要轮询，当事件发生时 Web 应用会推送通知。 管道（Pipeline）：接收并传递数据；当接收到通知时，对方可以编程将数据通过各种方式传递出去。 插件（Plugin）：处理数据并响应；将整个互联网变成一个可编程平台。 工作过程其工作流程就是一个发布-订阅模型，或者说是 Web 上的观察者模式。试画简要的时序图如下： 实现目前 WebHook 的实现没有统一的标准。但 webhooks.pbworks.com 提供了一种基于 RESTful 的 WebHooks 实现标准。包括发现、订阅、发布等一系列的规范。 实现 WebHook 时需要关注： 事件（Events），该 Web 应用可提供多少种事件用于订阅； 载荷（Payload），各种事件的通知实体是怎样的，有哪些字段； 更细微的还需要关注： 在通知中说明收到通知的原因——是由于哪个事件触发的，Github 中是使用请求头 X-GitHub-Event 说明； 唯一标识每个通知，Github 是使用请求头 X-GitHub-Delivery 说明； 如有需要，进行签名校验保证请求和响应内容未被修改，Github 中是使用请求头 X-Hub-Signature 说明。 参考 WebHooks Wiki Home 网络钩子 - 维基百科 Introduction to Webhooks and An Evangelist - nearsoft.com RESTful WebHooks - webhooks.pbworks.com Webhooks - developer.github.com Webhooks do’s and dont’s: what we learned after integrating +100 APIs - restful.io","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"concept","slug":"it/concept","permalink":"https://linlshare.github.io/categories/it/concept/"}],"tags":[{"name":"WebHook","slug":"WebHook","permalink":"https://linlshare.github.io/tags/WebHook/"}]},{"title":"金剛般若波羅蜜經","slug":"philosophy/金剛般若波羅蜜經","date":"2018-12-25T15:04:16.000Z","updated":"2019-01-13T11:37:46.633Z","comments":true,"path":"2018/12/25/philosophy/金剛般若波羅蜜經/","link":"","permalink":"https://linlshare.github.io/2018/12/25/philosophy/金剛般若波羅蜜經/","excerpt":"","text":"姚秦天竺三藏鳩摩羅什譯本如是我聞：一時，佛在舍衛國祇樹給孤獨園，與大比丘眾千二百五十人俱。爾時，世尊食時，著衣持鉢，入舍衛大城乞食。於其城中，次第乞已，還至本處。飯食訖，收衣鉢，洗足已，敷座而坐。時，長老須菩提在大眾中即從座起，偏袒右肩，右膝著地，合掌恭敬而白佛言：「希有世尊！如來善護念諸菩薩，善付囑諸菩薩。世尊！善男子、善女人，發阿耨多羅三藐三菩提心，應云何住？云何降伏其心？」佛言：「善哉，善哉！須菩提！如汝所說：『如來善護念諸菩薩，善付囑諸菩薩。』汝今諦聽，當為汝說。善男子、善女人，發阿耨多羅三藐三菩提心，應如是住，如是降伏其心。」「唯然。世尊！願樂欲聞。」佛告須菩提：「諸菩薩摩訶薩應如是降伏其心：『所有一切眾生之類，若卵生、若胎生、若濕生、若化生，若有色、若無色，若有想、若無想、若非有想非無想，我皆令入無餘涅槃而滅度之。』如是滅度無量、無數、無邊眾生，實無眾生得滅度者。何以故？須菩提！若菩薩有我相、人相、眾生相、壽者相，即非菩薩。「復次，須菩提！菩薩於法應無所住行於布施，所謂不住色布施，不住聲、香、味、觸、法布施。須菩提！菩薩應如是布施，不住於相。何以故？若菩薩不住相布施，其福德不可思量。「須菩提！於意云何？東方虛空可思量不？」「不也，世尊！」「須菩提！南、西、北方，四維、上、下虛空可思量不？」「不也，世尊！」「須菩提！菩薩無住相布施，福德亦復如是不可思量。須菩提！菩薩但應如所教住。「須菩提！於意云何？可以身相見如來不？」「不也，世尊！不可以身相得見如來。何以故？如來所說身相，即非身相。」佛告須菩提：「凡所有相，皆是虛妄；若見諸相非相，則見如來。」須菩提白佛言：「世尊！頗有眾生，得聞如是言說章句，生實信不？」佛告須菩提：「莫作是說。如來滅後後五百歲，有持戒修福者，於此章句能生信心，以此為實，當知是人不於一佛二佛、三、四、五佛而種善根，已於無量千萬佛所種諸善根。聞是章句，乃至一念生淨信者，須菩提！如來悉知悉見，是諸眾生得如是無量福德。何以故？是諸眾生無復我相、人相、眾生相、壽者相。「無法相，亦無非法相。何以故？是諸眾生若心取相，則為著我、人、眾生、壽者。「若取法相，即著我、人、眾生、壽者。何以故？若取非法相，即著我、人、眾生、壽者。是故不應取法，不應取非法。以是義故，如來常說：『汝等比丘，知我說法，如筏喻者，法尚應捨，何況非法。』「須菩提！於意云何？如來得阿耨多羅三藐三菩提耶？如來有所說法耶？」須菩提言：「如我解佛所說義，無有定法名阿耨多羅三藐三菩提，亦無有定法如來可說。何以故？如來所說法，皆不可取、不可說、非法、非非法。所以者何？一切賢聖皆以無為法而有差別。」「須菩提！於意云何？若人滿三千大千世界七寶以用布施，是人所得福德，寧為多不？」須菩提言：「甚多，世尊！何以故？是福德即非福德性，是故如來說福德多。」「若復有人，於此經中受持乃至四句偈等，為他人說，其福勝彼。何以故？須菩提！一切諸佛及諸佛阿耨多羅三藐三菩提法，皆從此經出。須菩提！所謂佛法者，即非佛法。「須菩提！於意云何？須陀洹能作是念，『我得須陀洹果』不？」須菩提言：「不也，世尊！何以故？須陀洹名為入流，而無所入，不入色、聲、香、味、觸、法，是名須陀洹。」「須菩提！於意云何？斯陀含能作是念，『我得斯陀含果』不？」須菩提言：「不也，世尊！何以故？斯陀含名一往來，而實無往來，是名斯陀含。」「須菩提！於意云何？阿那含能作是念，『我得阿那含果』不？」須菩提言：「不也，世尊！何以故？阿那含名為不來，而實無來，是故名阿那含。」「須菩提！於意云何？阿羅漢能作是念，『我得阿羅漢道』不？」須菩提言：「不也，世尊！何以故？實無有法名阿羅漢。世尊！若阿羅漢作是念『我得阿羅漢道』，即為著我、人、眾生、壽者。世尊！佛說我得無諍三昧，人中最為第一，是第一離欲阿羅漢。我不作是念：『我是離欲阿羅漢。』世尊！我若作是念『我得阿羅漢道』，世尊則不說須菩提是樂阿蘭那行者。以須菩提實無所行，而名須菩提是樂阿蘭那行。」佛告須菩提：「於意云何？如來昔在然燈佛所，於法有所得不？」「世尊！如來在然燈佛所，於法實無所得。」「須菩提！於意云何？菩薩莊嚴佛土不？」「不也，世尊！何以故？莊嚴佛土者，則非莊嚴，是名莊嚴。」「是故須菩提，諸菩薩摩訶薩應如是生清淨心，不應住色生心，不應住聲、香、味、觸、法生心，應無所住而生其心。「須菩提！譬如有人，身如須彌山王，於意云何？是身為大不？」須菩提言：「甚大，世尊！何以故？佛說非身，是名大身。」「須菩提！如恒河中所有沙數，如是沙等恒河，於意云何？是諸恒河沙寧為多不？」須菩提言：「甚多，世尊！但諸恒河尚多無數，何況其沙。」「須菩提！我今實言告汝，若有善男子、善女人，以七寶滿爾所恒河沙數三千大千世界以用布施，得福多不？」須菩提言：「甚多，世尊！」佛告須菩提：「若善男子、善女人於此經中，乃至受持四句偈等，為他人說，而此福德勝前福德。「復次，須菩提！隨說是經，乃至四句偈等，當知此處，一切世間天、人、阿修羅皆應供養，如佛塔廟，何況有人盡能受持讀誦？須菩提！當知是人成就最上、第一、希有之法，若是經典所在之處，則為有佛，若尊重弟子。」爾時，須菩提白佛言：「世尊！當何名此經？我等云何奉持？」佛告須菩提：「是經名為『金剛般若波羅蜜』。以是名字，汝當奉持。所以者何？須菩提！佛說般若波羅蜜，則非般若波羅蜜。須菩提！於意云何？如來有所說法不？」須菩提白佛言：「世尊！如來無所說。」「須菩提！於意云何？三千大千世界所有微塵是為多不？」須菩提言：「甚多，世尊！」「須菩提！諸微塵，如來說非微塵，是名微塵。如來說世界，非世界，是名世界。「須菩提！於意云何？可以三十二相見如來不？」「不也，世尊！不可以三十二相得見如來。何以故？如來說三十二相，即是非相，是名三十二相。」「須菩提！若有善男子、善女人，以恒河沙等身命布施；若復有人，於此經中，乃至受持四句偈等，為他人說，其福甚多。」爾時，須菩提聞說是經，深解義趣，涕淚悲泣，而白佛言：「希有世尊！佛說如是甚深經典，我從昔來所得慧眼，未曾得聞如是之經。世尊！若復有人得聞是經，信心清淨，則生實相，當知是人，成就第一希有功德。世尊！是實相者，則是非相，是故如來說名實相。世尊！我今得聞如是經典，信解、受持不足為難，若當來世後五百歲，其有眾生得聞是經，信解、受持，是人則為第一希有。何以故？此人無我相、人相、眾生相、壽者相。所以者何？我相即是非相，人相、眾生相、壽者相即是非相。何以故？離一切諸相，則名諸佛。」佛告須菩提：「如是，如是！若復有人得聞是經，不驚、不怖、不畏，當知是人甚為希有。何以故？須菩提！如來說第一波羅蜜，非第一波羅蜜，是名第一波羅蜜。須菩提！忍辱波羅蜜，如來說非忍辱波羅蜜。何以故？須菩提！如我昔為歌利王割截身體，我於爾時，無我相、無人相、無眾生相、無壽者相。何以故？我於往昔節節支解時，若有我相、人相、眾生相、壽者相，應生瞋恨。須菩提！又念過去於五百世作忍辱仙人，於爾所世，無我相、無人相、無眾生相、無壽者相。是故，須菩提！菩薩應離一切相，發阿耨多羅三藐三菩提心，不應住色生心，不應住聲、香、味、觸、法生心，應生無所住心。若心有住，則為非住。是故，佛說菩薩心不應住色布施。「須菩提！菩薩為利益一切眾生，應如是布施。如來說：『一切諸相，即是非相。』又說：『一切眾生，則非眾生。』「須菩提！如來是真語者、實語者、如語者、不誑語者、不異語者。「須菩提！如來所得法，此法無實無虛。須菩提！若菩薩心住於法而行布施，如人入闇，則無所見；若菩薩心不住法而行布施，如人有目，日光明照，見種種色。「須菩提！當來之世，若有善男子、善女人，能於此經受持、讀誦，則為如來以佛智慧悉知是人，悉見是人，皆得成就無量無邊功德。「須菩提！若有善男子、善女人，初日分以恒河沙等身布施，中日分復以恒河沙等身布施，後日分亦以恒河沙等身布施，如是無量百千萬億劫以身布施；若復有人，聞此經典，信心不逆，其福勝彼，何況書寫、受持、讀誦、為人解說。「須菩提！以要言之，是經有不可思議、不可稱量、無邊功德。如來為發大乘者說，為發最上乘者說。若有人能受持、讀誦、廣為人說，如來悉知是人，悉見是人，皆得成就不可量、不可稱、無有邊、不可思議功德，如是人等，則為荷擔如來阿耨多羅三藐三菩提。何以故？須菩提！若樂小法者，著我見、人見、眾生見、壽者見，則於此經，不能聽受、讀誦、為人解說。「須菩提！在在處處若有此經，一切世間天、人、阿修羅所應供養；當知此處則為是塔，皆應恭敬、作禮、圍繞，以諸華香而散其處。「復次，須菩提！善男子、善女人受持、讀誦此經，若為人輕賤，是人先世罪業應墮惡道，以今世人輕賤故，先世罪業則為消滅，當得阿耨多羅三藐三菩提。「須菩提！我念過去無量阿僧祇劫，於然燈佛前，得值八百四千萬億那由他諸佛，悉皆供養承事，無空過者；若復有人，於後末世，能受持、讀誦此經，所得功德，於我所供養諸佛功德，百分不及一，千萬億分、乃至算數、譬喻所不能及。「須菩提！若善男子、善女人於後末世，有受持、讀誦此經所得功德，我若具說者，或有人聞，心則狂亂，狐疑不信。須菩提！當知是經義不可思議，果報亦不可思議。」爾時，須菩提白佛言：「世尊！善男子、善女人發阿耨多羅三藐三菩提心，云何應住？云何降伏其心？」佛告須菩提：「善男子、善女人發阿耨多羅三藐三菩提者，當生如是心：『我應滅度一切眾生。滅度一切眾生已，而無有一眾生實滅度者。』何以故？須菩提！若菩薩有我相、人相、眾生相、壽者相，則非菩薩。所以者何？須菩提！實無有法發阿耨多羅三藐三菩提者。「須菩提！於意云何？如來於然燈佛所，有法得阿耨多羅三藐三菩提不？」「不也，世尊！如我解佛所說義，佛於然燈佛所，無有法得阿耨多羅三藐三菩提。」佛言：「如是，如是！須菩提！實無有法如來得阿耨多羅三藐三菩提。須菩提！若有法如來得阿耨多羅三藐三菩提者，然燈佛則不與我受記：『汝於來世當得作佛，號釋迦牟尼。』以實無有法得阿耨多羅三藐三菩提，是故然燈佛與我受記，作是言：『汝於來世當得作佛，號釋迦牟尼。』何以故？如來者，即諸法如義。「若有人言『如來得阿耨多羅三藐三菩提』，須菩提！實無有法，佛得阿耨多羅三藐三菩提。須菩提！如來所得阿耨多羅三藐三菩提，於是中無實無虛，是故如來說：『一切法皆是佛法。』須菩提！所言一切法者，即非一切法，是故名一切法。「須菩提！譬如人身長、大。」須菩提言：「世尊！如來說人身長、大，則為非大身，是名大身。」「須菩提！菩薩亦如是，若作是言『我當滅度無量眾生』，則不名菩薩。何以故？須菩提！實無有法名為菩薩。是故，佛說：『一切法無我、無人、無眾生、無壽者。』須菩提！若菩薩作是言『我當莊嚴佛土』，是不名菩薩。何以故？如來說莊嚴佛土者，即非莊嚴，是名莊嚴。須菩提！若菩薩通達無我、法者，如來說名真是菩薩。「須菩提！於意云何？如來有肉眼不？」「如是，世尊！如來有肉眼。」「須菩提！於意云何？如來有天眼不？」「如是，世尊！如來有天眼。」「須菩提！於意云何？如來有慧眼不？」「如是，世尊！如來有慧眼。」「須菩提！於意云何？如來有法眼不？」「如是，世尊！如來有法眼。」「須菩提！於意云何？如來有佛眼不？」「如是，世尊！如來有佛眼。」「須菩提！於意云何？恒河中所有沙，佛說是沙不？」「如是，世尊！如來說是沙。」「須菩提！於意云何？如一恒河中所有沙，有如是等恒河，是諸恒河所有沙數佛世界，如是寧為多不？」「甚多，世尊！」佛告須菩提：「爾所國土中，所有眾生若干種心，如來悉知。何以故？如來說諸心，皆為非心，是名為心。所以者何？須菩提！過去心不可得，現在心不可得，未來心不可得。「須菩提！於意云何？若有人滿三千大千世界七寶以用布施，是人以是因緣得福多不？」「如是，世尊！此人以是因緣得福甚多。」「須菩提！若福德有實，如來不說得福德多；以福德無故，如來說得福德多。「須菩提！於意云何？佛可以具足色身見不？」「不也，世尊！如來不應以具足色身見。何以故？如來說具足色身，即非具足色身，是名具足色身。」「須菩提！於意云何？如來可以具足諸相見不？」「不也，世尊！如來不應以具足諸相見。何以故？如來說諸相具足，即非具足，是名諸相具足。」「須菩提！汝勿謂如來作是念，『我當有所說法』。莫作是念，何以故？若人言『如來有所說法』，即為謗佛，不能解我所說故。須菩提！說法者，無法可說，是名說法。」爾時，慧命須菩提白佛言：「世尊！頗有眾生於未來世，聞說是法生信心不？」佛言：「須菩提！彼非眾生，非不眾生。何以故？須菩提！眾生、眾生者，如來說非眾生，是名眾生。」須菩提白佛言：「世尊！佛得阿耨多羅三藐三菩提，為無所得耶？」「如是，如是！須菩提！我於阿耨多羅三藐三菩提乃至無有少法可得，是名阿耨多羅三藐三菩提。「復次，須菩提！是法平等，無有高下，是名阿耨多羅三藐三菩提；以無我、無人、無眾生、無壽者，修一切善法，則得阿耨多羅三藐三菩提。須菩提！所言善法者，如來說非善法，是名善法。「須菩提！若三千大千世界中所有諸須彌山王，如是等七寶聚，有人持用布施；若人以此《般若波羅蜜經》，乃至四句偈等，受持、讀誦、為他人說，於前福德百分不及一，百千萬億分，乃至算數、譬喻所不能及。「須菩提！於意云何？汝等勿謂如來作是念：『我當度眾生。』須菩提！莫作是念。何以故？實無有眾生如來度者，若有眾生如來度者，如來則有我、人、眾生、壽者。須菩提！如來說有我者，則非有我，而凡夫之人以為有我。須菩提！凡夫者，如來說則非凡夫。「須菩提！於意云何？可以三十二相觀如來不？」須菩提言：「如是，如是！以三十二相觀如來。」佛言：「須菩提！若以三十二相觀如來者，轉輪聖王則是如來。」須菩提白佛言：「世尊！如我解佛所說義，不應以三十二相觀如來。」爾時，世尊而說偈言：「若以色見我，以音聲求我，是人行邪道，不能見如來。「須菩提！汝若作是念：『如來不以具足相故，得阿耨多羅三藐三菩提。』須菩提！莫作是念。如來不以具足相故，得阿耨多羅三藐三菩提。「須菩提！汝若作是念『發阿耨多羅三藐三菩提者，說諸法斷滅相』，莫作是念。何以故？發阿耨多羅三藐三菩提心者，於法不說斷滅相。「須菩提！若菩薩以滿恒河沙等世界七寶布施；若復有人知一切法無我，得成於忍，此菩薩勝前菩薩所得功德。須菩提！以諸菩薩不受福德故。」須菩提白佛言：「世尊！云何菩薩不受福德？」「須菩提！菩薩所作福德，不應貪著，是故說不受福德。「須菩提！若有人言『如來若來若去、若坐若臥』，是人不解我所說義。何以故？如來者，無所從來，亦無所去，故名如來。「須菩提！若善男子、善女人以三千大千世界碎為微塵，於意云何？是微塵眾寧為多不？」「甚多，世尊！何以故？若是微塵眾實有者，佛則不說是微塵眾。所以者何？佛說微塵眾，則非微塵眾，是名微塵眾。世尊！如來所說三千大千世界，則非世界，是名世界。何以故？若世界實有者，則是一合相。如來說一合相，則非一合相，是名一合相。」「須菩提！一合相者，則是不可說，但凡夫之人貪著其事。「須菩提！若人言『佛說我見、人見、眾生見、壽者見』，須菩提！於意云何？是人解我所說義不？」「世尊！是人不解如來所說義。何以故？世尊說我見、人見、眾生見、壽者見，即非我見、人見、眾生見、壽者見，是名我見、人見、眾生見、壽者見。」「須菩提！發阿耨多羅三藐三菩提心者，於一切法，應如是知，如是見，如是信解，不生法相。須菩提！所言法相者，如來說即非法相，是名法相。「須菩提！若有人以滿無量阿僧祇世界七寶持用布施，若有善男子、善女人發菩薩心者，持於此經乃至四句偈等，受持、讀誦、為人演說，其福勝彼。云何為人演說？不取於相，如如不動。何以故？「一切有為法，如夢、幻、泡、影，如露亦如電，應作如是觀。」佛說是經已，長老須菩提及諸比丘、比丘尼、優婆塞、優婆夷，一切世間天、人、阿修羅，聞佛所說，皆大歡喜，信受奉行。 唐三藏法師玄奘譯本如是我聞一時薄伽梵在室羅筏住誓多林給孤獨園與大苾蒭眾千二百五十人俱尒時世尊於日初分整理常服執持衣鉢入室羅筏大城乞食時薄伽梵於其城中行乞食已出還本處飯食訖收衣鉢洗足已於食後時敷如常座結加趺坐端身正願住對面念時諸苾蒭來詣佛所到已頂禮世尊雙足右遶三匝退坐一面具壽善現亦於如是眾會中坐。 尒時眾中具壽善現從座而起偏袒一肩右膝著地合掌恭敬而白佛言希有世尊乃至如來應正等覺能以㝡勝攝受攝受諸菩薩摩訶薩乃至如來應正等覺能以㝡勝付囑付囑諸菩薩摩訶薩世尊諸有發趣菩薩乘者應云何住云何修行云何攝伏其心作是語已。 尒時世尊告具壽善現曰善哉善哉善現如是如是如汝所說乃至如來應正等覺能以㝡勝攝受攝受諸菩薩摩訶薩乃至如來應正等覺能以㝡勝付囑付囑諸菩薩摩訶薩是故善現汝應諦聽極善作意吾當為汝分別解說諸有發趣菩薩乘者應如是住如是修行如是攝伏其心具壽善現白佛言如是世尊願樂欲聞。 佛言善現諸有發趣菩薩乘者應當發起如是之心所有諸有情有情攝所攝若卵生若胎生若濕生若化生若有色若無色若有想若無想若非有想非無想乃至有情界施設所施設如是一切我當皆令於無餘依妙涅槃界而般涅槃雖度如是無量有情令滅度已而無有情得滅度者何以故善現若諸菩薩摩訶薩有情想轉不應說名菩薩摩訶薩所以者何善現若諸菩薩摩訶薩不應說言有情想轉如是命者想士夫想補特伽羅想意生想摩納婆想作者想受者想轉當知亦尒何以故善現無有少法名為發趣菩薩乘者。 復次善現菩薩摩訶薩不住於事應行布施都無所住應行布施不住於色應行布施不住聲香味觸法應行布施善現如是菩薩摩訶薩如不住相想應行布施何以故善現若菩薩摩訶薩都無所住而行布施其福德聚不可取量佛告善現於汝意云何東方虛空可取量不善現答言不也世尊善現如是南西北方四維上下周遍十方一切世界虛空可取量不善現答言不也世尊佛言善現如是如是若菩薩摩訶薩都無所住而行布施其福德聚不可取量亦復如是善現菩薩如是如不住相想應行布施。 佛告善現於汝意云何可以諸相具足觀如來不善現答言不也世尊不應以諸相具足觀於如來何以故如來說諸相具足即非諸相具足說是語已佛復告具壽善現言善現乃至諸相具足皆是虛妄乃至非相具足皆非虛妄如是以相非相應觀如來說是語已具壽善現復白佛言世尊頗有有情於當來世後時後分後五百歲正法將滅時分轉時聞說如是色經典句生實想不佛告善現勿作是說頗有有情於當來世後時後分後五百歲正法將滅時分轉時聞說如是色經典句生實想不然復善現有菩薩摩訶薩於當來世後時後分後五百歲正法將滅時分轉時具足尸羅具德具慧復次善現彼菩薩摩訶薩非於一佛所承事供養非於一佛所種諸善根然復善現彼菩薩摩訶薩於其非一百千佛所承事供養於其非一百千佛所種諸善根乃能聞說如是色經典句當得一淨信心善現如來以其佛智悉已知彼如來以其佛眼悉已見彼善現如來悉已覺彼一切有情當生無量無數福聚當攝無量無數福聚何以故善現彼菩薩摩訶薩無我想轉無有情想無命者想無士夫想無補特伽羅想无意生想無摩納婆想無作者想無受者想轉善現彼菩薩摩訶薩無法想轉無非法想轉無想轉亦無非想轉所以者何善現若菩薩摩訶薩有法想轉彼即應有我執有情執命者執補特伽羅等執若有非法想轉彼亦應有我執有情執命者執補特伽羅等執何以故善現不應取法不應取非法是故如來密意而說筏喻法門諸有智者法尚應断何况非法。 佛復告具壽善現言善現於汝意云何頗有少法如來應正等覺證得阿耨多羅三藐三菩提耶頗有少法如來應正等覺是所說耶善現答言世尊如我解佛所說義者無有少法如來應正等覺證得阿耨多羅三藐三菩提亦無有少法是如來應正等覺所說何以故世尊如來應正等覺所證所說所思惟法皆不可取不可宣說非法非非法何以故以諸賢聖補特伽羅皆是無為之所顯故。 佛告善現於汝意云何若善男子或善女人以此三千大千世界盛滿七寶持用布施是善男子或善女人由此因緣所生福聚寧為多不善現答言甚多世尊甚多善逝是善男子或善女人由此因緣所生福聚其量甚多何以故世尊福德聚福德聚者如來說為非福德聚是故如來說名福德聚福德聚。 佛復告善現言善現若善男子或善女人以此三千大千世界盛滿七寶持用布施若善男子或善女人於此法門乃至四句伽他受持讀誦究竟通利及廣為他宣說開示如理作意由是因緣所生福聚甚多於前無量無數何以故一切如來應正等覺阿耨多羅三藐三菩提皆從此經出諸佛世尊皆從此經生所以者何善現諸佛法諸佛法者如來說為非諸佛法是故如來說名諸佛法諸佛法。 佛告善現於汝意云何諸預流者頗作是念我能證得預流果不善現答言不也世尊諸預流者不作是念我能證得預流之果何以故世尊諸預流者無少所預故名預流不預色聲香味觸法故名預流世尊若預流者作如是念我能證得預流之果即為執我有情命者士夫補特伽羅等佛告善現於汝意云何諸一來者頗作是念我能證得一來果不善現答言不也世尊諸一來者不作是念我能證得一來之果何以故世尊以無少法證一來性故名一來佛告善現於汝意云何諸不還者頗作是念我能證得不還果不善現答言不也世尊諸不還者不作是念我能證得不還之果何以故世尊以無少法證不還性故名不還佛告善現於汝意云何諸阿羅漢頗作是念我能證得阿羅漢不善現答言不也世尊諸阿羅漢不作是念我能證得阿羅漢性何以故世尊以無少法名阿羅漢由是因緣名阿羅漢世尊若阿羅漢作如是念我能證得阿羅漢性即為執我有情命者士夫補特伽羅等所以者何世尊如來應正等覺說我得無諍住㝡為第一世尊我雖是阿羅漢永離貪欲而我未曾作如是念我得阿羅漢永離貪欲世尊我若作如是念我得阿羅漢永離貪欲者如來不應記說我言善現善男子得無諍住㝡為第一以都無所住是故如來說名無諍住無諍住。 佛告善現於汝意云何如來昔在然燈如來應正等覺所頗於少法有所取不善現答言不也世尊如來昔在然燈如來應正等覺所都無少法而有所取佛告善現若有菩薩作如是言我當成辦佛土功德莊嚴如是菩薩非真實語何以故善現佛土功德莊嚴佛土功德莊嚴者如來說非莊嚴是故如來說名佛土功德莊嚴佛土功德莊嚴是故善現菩薩如是都無所住應生其心不住於色應生其心不住非色應生其心不住聲香味觸法應生其心不住非聲香味觸法應生其心都無所住應生其心。 佛告善現如有士夫具身大身其色自體假使譬如妙高山王善現於汝意云何彼之自體為廣大不善現答言彼之自體廣大世尊廣大善逝何以故世尊彼之自體如來說非彼體故名自體非以彼體故名自體。 佛告善現於汝意云何乃至殑伽河中所有沙數假使有如是沙等殑伽河是諸殑伽河沙寧為多不善現答言甚多世尊甚多善逝諸殑伽河尚多無數何况其沙佛言善現吾今告汝開覺於汝假使若善男子或善女人以妙七寶盛滿尒所殑伽河沙等世界奉施如來應正等覺善現於汝意云何是善男子或善女人由此因緣所生福聚寧為多不善現答言甚多世尊甚多善逝是善男子或善女人由此因緣所生福聚其量甚多。 佛復告善現若以七寶盛滿尒所沙等世界奉施如來應正等覺若善男子或善女人於此法門乃至四句伽他受持讀誦究竟通利及廣為他宣說開示如理作意由此因緣所生福聚甚多於前無量無數。 復次善現若地方所於此法門乃至為他宣說開示四句伽他此地方所尚為世間諸天及人阿素洛等之所供養如佛靈廟何况有能於此法門具足究竟書寫受持讀誦究竟通利及廣為他宣說開示如理作意如是有情成就㝡勝希有功德此地方所大師所住或隨一一尊重處所若諸有智同梵行者說是語已。 具壽善現復白佛言世尊當何名此法門我當云何奉持作是語已佛告善現言具壽今此法門名為能断般若波羅蜜多如是名字汝當奉持何以故善現如是般若波羅蜜多如來說為非般若波羅蜜多是故如來說名般若波羅蜜多。 佛告善現於汝意云何頗有少法如來可說不善現答言不也世尊無有少法如來可說佛告善現乃至三千大千世界大地微塵寧為多不善現答言此地微塵甚多世尊甚多善逝。 佛言善現大地微塵如來說非微塵是故如來說名大地微塵諸世界如來說非世界是故如來說名世界。 佛告善現於汝意云何應以三十二大士夫相觀於如來應正等覺不善現答言不也世尊不應以三十二大士夫相觀於如來應正等覺何以故世尊三十二大士夫相如來說為非相是故如來說名三十二大士夫相。 佛復告善現言假使若有善男子或善女人於日日分捨施殑伽河沙等自體如是經殑伽河沙等劫數捨施自體復有善男子或善女人於此法門乃至四句伽他受持讀誦究竟通利及廣為他宣說開示如理作意由是因緣所生福聚甚多於前无量無數。 尒時具壽善現聞法威力悲泣墮淚俛仰捫淚而白佛言甚奇希有世尊㝡極希有善逝如來今者所說法門普為發趣㝡上乘者作諸義利普為發趣㝡勝乘者作諸義利世尊我昔生智以來未曾得聞如是法門世尊若諸有情聞說如是甚深經典生真實想當知成就㝡勝希有何以故世尊諸真實想真實想者如來說為非想是故如來說名真實想真實想世尊我今聞說如是法門領悟信解未為希有若諸有情於當來世後時後分後五百歲正法將滅時分轉時當於如是甚深法門領悟信解受持讀誦究竟通利及廣為他宣說開示如理作意當知成就㝡勝希有何以故世尊彼諸有情無我想轉無有情想無命者想無士夫想無補特伽羅想無意生想無摩納婆想無作者想無受者想轉所以者何世尊諸我想即是非想諸有情想命者想士夫想補特伽羅想意生想摩納婆想作者想受者想即是非想何以故諸佛世尊離一切想作是語已。 尒時世尊告具壽善現言如是如是善現若諸有情聞說如是甚深經典不驚不懼無有怖畏當知成就㝡勝希有何以故善現如來說㝡勝波羅蜜多謂般若波羅蜜多善現如來所說㝡勝波羅蜜多無量諸佛世尊所共宣說故名㝡勝波羅蜜多如來說㝡勝波羅蜜多即非波羅蜜多是故如來說名㝡勝波羅蜜多。 復次善現如來說忍辱波羅蜜多即非波羅蜜多是故如來說名忍辱波羅蜜多何以故善現我昔過去世曾為羯利王断支節肉我於尒時都無我想或有情想或命者想或士夫想或補特伽羅想或意生想或摩納婆想或作者想或受者想我於尒時都無有想亦非無想何以故善現我於尒時若有我想即於尒時應有恚想我於尒時若有有情想命者想士夫想補特伽羅想意生想摩納婆想作者想受者想即於尒時應有恚想何以故善現我憶過去五百生中曾為自號忍辱仙人我於尒時都无我想無有情想無命者想無士夫想无補特伽羅想無意生想無摩納婆想無作者想無受者想我於尒時都無有想亦非無想是故善現菩薩摩訶薩遠離一切想應發阿耨多羅三藐三菩提心不住於色應生其心不住非色應生其心不住聲香味觸法應生其心不住非聲香味觸法應生其心都無所住應生其心何以故善現諸有所住則為非住是故如來說諸菩薩應無所住而行布施不應住色聲香味觸法而行布施。 復次善現菩薩摩訶薩為諸有情作義利故應當如是棄捨布施何以故善現諸有情想即是非想一切有情如來即說為非有情善現如來是實語者諦語者如語者不異語者。 復次善現如來現前等所證法或所說法或所思法即於其中非諦非妄善現譬如士夫入於闇室都無所見當知菩薩若墮於事謂墮於事而行布施亦復如是善現譬如明眼士夫過夜曉已日光出時見種種色當知菩薩不墮於事謂不墮事而行布施亦復如是。 復次善現若善男子或善女人於此法門受持讀誦究竟通利及廣為他宣說開示如理作意則為如來以其佛智悉知是人則為如來以其佛眼悉見是人則為如來悉覺是人如是有情一切當生無量福聚。 復次善現假使善男子或善女人日初時分以殑伽河沙等自體布施日中時分復以殑伽河沙等自體布施日後時分亦以殑伽河沙等自體布施由此異門經於俱𦙁𨚗𢈔多百千劫以自體布施若有聞說如是法門不生誹謗由此因緣所生福聚尚多於前無量無數何况能於如是法門具足畢竟書寫受持讀誦究竟通利及廣為他宣說開示如理作意復次善現如是法門不可思議不可稱量應當悕冀不可思議所感異熟善現如來宣說如是法門為欲饒益趣㝡上乘諸有情故為欲饒益趣㝡勝乘諸有情故善現若有於此法門受持讀誦究竟通利及廣為他宣說開示如理作意即為如來以其佛智悉知是人即為如來以其佛眼悉見是人則為如來悉覺是人如是有情一切成就無量福聚皆當成就不可思議不可稱量无邊福聚善現如是一切有情其肩荷擔如來無上正等菩提何以故善現如是法門非諸下劣信解有情所能聽聞非諸我見非諸有情見非諸命者見非諸士夫見非諸補特伽羅見非諸意生見非諸摩納婆見非諸作者見非諸受者見所能聽聞此等若能受持讀誦究竟通利及廣為他宣說開示如理作意無有是處。 復次善現若地方所開此經典此地方所當為世間諸天及人阿素洛等之所供養禮敬右遶如佛靈廟。 復次善現若善男子或善女人於此經典受持讀誦究竟通利及廣為他宣說開示如理作意若遭輕毀極遭輕毀所以者何善現是諸有情宿生所造諸不淨業應感惡趣以現法中遭輕毀故宿生所造諸不淨業皆悉消盡當得無上正等菩提何以故善現我憶過去於無數劫復過無數於然燈如來應正等覺先復過先曾值八十四俱𦙁𨚗𢈔多百千諸佛我皆承事既承事已皆無違犯善現我於如是諸佛世尊皆得承事既承事已皆無違犯若諸有情後時後分後五百歲正法將滅時分轉時於此經典受持讀誦究竟通利及廣為他宣說開示如理作意善現我先福聚於此福聚百分計之所不能及如是千分若百千分若俱𦙁百千分若俱𦙁𨚗𢈔多百千分若數分若計分若筭分若喻分若鄔波尼煞曇分亦不能及善現我若具說當於尒時是善男子或善女人所生福聚乃至是善男子是善女人所攝福聚有諸有情則便迷悶心或狂亂是故善現如來宣說如是法門不可思議不可稱量應當悕冀不可思議所感異熟尒時具壽善現復白佛言世尊諸有發趣菩薩乘者應云何住云何修行云何攝伏其心。 佛告善現諸有發趣菩薩乘者應當發起如是之心我當皆令一切有情於無餘依妙涅槃界而般涅槃雖度如是一切有情令滅度已而無有情得滅度者何以故善現若諸菩薩摩訶薩有情想轉不應說名菩薩摩訶薩所以者何若諸菩薩摩訶薩不應說言有情想轉如是命者想士夫想補特伽羅想意生想摩納婆想作者想受者想轉當知亦尒何以故善現無有少法名為發趣菩薩乘者。 佛告善現於汝意云何如來昔於然燈如來應正等覺所頗有少法能證阿耨多羅三藐三菩提不作是語已具壽善現白佛言世尊如我解佛所說義者如來昔於然燈如來應正等覺所無有少法能證阿耨多羅三藐三菩提說是語已佛告具壽善現言如是如是善現如來昔於然燈如來應正等覺所無有少法能證阿耨多羅三藐三菩提何以故善現如來昔於然燈如來應正等覺所若有少法能證阿耨多羅三藐三菩提者然燈如來應正等覺不應授我記言汝摩納婆於當來世名釋迦牟尼如來應正等覺善現以如來無有少法能證阿耨多羅三藐三菩提是故然燈如來應正等覺授我記言汝摩納婆於當來世名釋迦牟尼如來應正等覺所以者何善現言如來者即是真實真如增語言如來者即是無生法性增語言如來者即是永断道路增語言如來者即是畢竟不生增語何以故善現若實無生即㝡勝義善現若如是說如來應正等覺能證阿耨多羅三藐三菩提者當知此言為不真實所以者何善現由彼謗我起不實執何以故善現無有少法如來應正等覺能證阿耨多羅三藐三菩提善現如來現前等所證法或所說法或所思法即於其中非諦非妄是故如來說一切法皆是佛法善現一切法一切法者如來說非一切法是故如來說名一切法一切法佛告善現譬如士夫具身大身具壽善現即白佛言世尊如來所說士夫具身大身如來說為非身是故說名具身大身佛言善現如是如是若諸菩薩作如是言我當滅度無量有情是則不應說名菩薩何以故善現頗有少法名菩薩不善現答言不也世尊無有少法名為菩薩佛告善現有情有情者如來說非有情故名有情是故如來說一切法無有有情无有命者無有士夫无有補特伽羅等善現若諸菩薩作如是言我當成辦佛土功德莊嚴亦如是說何以故善現佛土功德莊嚴佛土功德莊嚴者如來說非莊嚴是故如來說名佛土功德莊嚴佛土功德莊嚴善現若諸菩薩於無我法無我法深信解者如來應正等覺說為菩薩菩薩。 佛告善現於汝意云何如來等現有肉眼不善現答言如是世尊如來等現有肉眼佛言善現於汝意云何如來等現有天眼不善現答言如是世尊如來等現有天眼佛言善現於汝意云何如來等現有慧眼不善現答言如是世尊如來等現有慧眼佛言善現於汝意云何如來等現有法眼不善現答言如是世尊如來等現有法眼佛言善現於汝意云何如來等現有佛眼不善現答言如是世尊如來等現有佛眼。 佛告善現於汝意云何乃至殑伽河中所有諸沙如來說是沙不善現答言如是世尊如是善逝如來說是沙。 佛言善現於汝意云何乃至殑伽河中所有沙數假使有如是等殑伽河乃至是諸殑伽河中所有沙數假使有如是等世界是諸世界寧為多不善現答言如是世尊如是善逝是諸世界其數甚多佛言善現乃至尒所諸世界中所有有情彼諸有情各有種種其心流注我悉能知何以故善現心流注心流注者如來說非流注是故如來說名心流注心流注所以者何善現過去心不可得未來心不可得現在心不可得。 佛告善現於汝意云何若善男子或善女人以此三千大千世界盛滿七寶奉施如來應正等覺是善男子或善女人由是因緣所生福聚寧為多不善現答言甚多世尊甚多善逝佛言善現如是如是彼善男子或善女人由此因緣所生福聚其量甚多何以故善現若有福聚如來不說福聚福聚。 佛告善現於汝意云何可以色身圓實觀如來不善現答言不也世尊不可以色身圓實觀於如來何以故世尊色身圓實色身圓實者如來說非圓實是故如來說名色身圓實色身圓實。 佛告善現於汝意云何可以諸相具足觀如來不善現答言不也世尊不可以諸相具足觀於如來何以故世尊諸相具足諸相具足者如來說為非相具足是故如來說名諸相具足諸相具足。 佛告善現於汝意云何如來頗作是念我當有所說法耶善現汝今勿當作如是觀何以故善現若言如來有所說法即為謗我為非善取何以故善現說法說法者無法可說是名說法。 尒時具壽善現白佛言世尊於當來世後時後分後五百歲正法將滅時分轉時頗有有情聞說如是色類法已能深信不佛言善現彼非有情非不有情何以故善現一切有情者如來說非有情故名一切有情。 佛告善現於汝意云何頗有少法如來應正等覺現證無上正等菩提耶具壽善現白佛言世尊如我解佛所說義者無有少法如來應正等覺現證無上正等菩提佛言善現如是如是於中少法無有無得故名無上正等菩提復次善現是法平等於其中間無不平等故名無上正等菩提以無我性無有情性無命者性無士夫性無補特伽羅等性平等故名無上正等菩提一切善法無不現證一切善法無不妙覺善現善法善法者如來一切說為非法是故如來說名善法善法。 復次善現若善男子或善女人集七寶聚量等三千大千世界其中所有妙高山王持用布施若善男子或善女人於此般若波羅蜜多經中乃至四句伽他受持讀誦究竟通利及廣為他宣說開示如理作意善現前說福聚於此福聚百分計之所不能及如是千分若百千分若俱𦙁百千分若俱𦙁𨚗𢈔多百千分若數分若計分若筭分若喻分若鄔波尼煞曇分亦不能及。 佛告善現於意云何如來頗作是念我當度脫諸有情耶善現汝今勿當作如是觀何以故善現無少有情如來度者善現若有有情如來度者如來即應有其我執有有情執有命者執有士夫執有補特伽羅等執善現我等執者如來說為非執故名我等執而諸愚夫異生強有此執善現愚夫異生者如來說為非生故名愚夫異生。 佛告善現於汝意云何可以諸相具足觀如來不善現答言如我解佛所說義者不應以諸相具足觀於如來。 佛言善現善哉善哉如是如是如汝所說不應以諸相具足觀於如來善現若以諸相具足觀如來者轉輪聖王應是如來是故不應以諸相具足觀於如來如是應以諸相非相觀於如來尒時世尊而說頌曰。 諸以色觀我 以音聲尋我 彼生履邪断不能當見我 應觀佛法性 即導師法身法性非所識 故彼不能了佛告善現於汝意云何如來應正等覺以諸相具足現證無上正等覺耶善現汝今勿當作如是觀何以故善現如來應正等覺不以諸相具足現證無上正等菩提。 復次善現如是發趣菩薩乘者頗施設少法若壞若断耶善現汝今勿當作如是觀諸有發趣菩薩乘者終不施設少法若壞若断。 復次善現若善男子或善女人以殑伽河沙等世界盛滿七寶奉施如來應正等覺若有菩薩於諸無我無生法中獲得堪忍由是因緣所生福聚甚多於彼。 復次善現菩薩不應攝受福聚具壽善現即白佛言世尊云何菩薩不應攝受福聚佛言善現所應攝受不應攝受是故說名所應攝受。 復次善現若有說言如來若去若來若住若坐若臥是人不解我所說義何以故善現言如來者即是真實真如增語都無所去無所從來故名如來應正等覺。 復次善現若善男子或善女人乃至三千大千世界大地極微塵量等世界即以如是無數世界色像為墨如極微聚善現於汝意云何是極微聚寧為多不善現答言是極微聚甚多世尊甚多善逝何以故世尊若極微聚是實有者佛不應說為極微聚所以者何如來說極微聚即為非聚故名極微聚如來說三千大千世界即非世界故名三千大千世界何以故世尊若世界是實有者即為一合執如來說一合執即為非執故名一合執佛言善現此一合執不可言說不可戲論然彼一切愚夫異生強執是法何以故善現若作是言如來宣說我見有情見命者見士夫見補特伽羅見意生見摩納婆見作者見受者見於汝意云何如是所說為正語不善現答言不也世尊不也善逝如是所說非為正語所以者何如來所說我見有情見命者見士夫見補特伽羅見意生見摩納婆見作者見受者見即為非見故名我見乃至受者見。 佛告善現諸有發趣菩薩乘者於一切法應如是知應如是見應如是信解如是不住法想何以故善現法想法想者如來說為非想是故如來說名法想法想。 復次善現若菩薩摩訶薩以無量无數世界盛滿七寶奉施如來應正等覺若善男子或善女人於此般若波羅蜜多經中乃至四句伽他受持讀誦究竟通利如理作意及廣為他宣說開示由此因緣所生福聚甚多於前無量無數云何為他宣說開示如不為他宣說開示故名為他宣說開示尒時世尊而說頌曰。 諸和合所為 如星翳燈幻 露泡夢電雲應作如是觀時薄伽梵說是經已尊者善現及諸苾蒭苾蒭尼鄔波索迦鄔波斯迦并諸世間天人阿素洛健達縛等聞薄伽梵所說經已皆大歡喜信受奉行。 參考 T0235 金剛般若波羅蜜經 - CBETA K0016 能斷金剛般若波羅蜜多經 - CBETA","categories":[{"name":"philosophy","slug":"philosophy","permalink":"https://linlshare.github.io/categories/philosophy/"}],"tags":[{"name":"Philosophy","slug":"Philosophy","permalink":"https://linlshare.github.io/tags/Philosophy/"},{"name":"佛經","slug":"佛經","permalink":"https://linlshare.github.io/tags/佛經/"}]},{"title":"复合任务及其状态","slug":"it/concept/复合任务及其状态","date":"2018-12-24T09:49:56.000Z","updated":"2019-01-13T11:37:46.373Z","comments":true,"path":"2018/12/24/it/concept/复合任务及其状态/","link":"","permalink":"https://linlshare.github.io/2018/12/24/it/concept/复合任务及其状态/","excerpt":"","text":"在代码设计字段时我们经常会碰到需要加状态字段的场景。状态即此刻的情况、形态。从一个状态到另个状态是质变，而质变是由量变累积而成，譬如年老的状态，是时间累积、内分泌系统渐衰，而从年轻到年老的质变。代码中的状态字段亦复如是。 原子任务的状态转移是单一操作的，该任务只有 TODO 和 DONE 两种状态，该任务无法被部分完成，只能整体完成或没完成。 1234public class Task&#123; // 状态可取值：[\"TODO\",\"DONE\"] private String status;&#125; 然而现实世界中的任务大多是复合任务，据我所知有以下几种简单复合方式： 多个平行原子任务复合，且称之为平行复合任务； 多个链状原子任务复合，且称之为链状复合任务； 多个树状原子任务复合，且称之为树状复合任务； 上面复合方式还可以嵌套，产生更复杂的复合方式，即多重复合。 这时，我们面临一个挑战，我们该如何定义这些复合任务的状态呢？ 我们说是量的积累导致了状态的质变，那么可不可以从过程量入手呢？ 答案是明确的，我认为这应该是绝妙而又充满哲学意味的手段。现以最简单的平行复合任务为例，试编码如下： （1）首先我们需要一个计数器，用来统计总数和已完成的任务数量。 12345678910111213141516171819public class Counter&#123; private int total; private int done; public void setTotal(int total)&#123; this.total = total; &#125; public void increaseTotal()&#123; this.total ++; &#125; public void increaseDone()&#123; this.done ++; &#125; public boolean totallyDone() &#123; return total == done; &#125;&#125; （2）再者，我们在复合任务内部刷新状态，每当一个子任务完成时检查并刷新内部状态。这样，状态的刷新就内聚了，外部量变，内部质变。 123456789101112131415161718192021222324public class CompoundTask&#123; // 状态可取值：[\"TODO\", \"DONE\", \"PARTIALLY_DONE\"] private String status = \"TODO\"; private Counter counter = new Counter(); private List&lt;Task&gt; tasks = new ArrayList&lt;&gt;(); public void addTask(Task task)&#123; tasks.add(task); counter.increaseTotal(); &#125; public void increaseTaskDone()&#123; counter.increaseDone(); refreshStatus(); &#125; private void refreshStatus()&#123; if(counter.totallyDone())&#123; status = \"DONE\"; &#125;else&#123; status = \"PARTIALLY_DONE\"; &#125; &#125;&#125; 以上是基础实现，旨在探求一种通用的描述复合任务状态的解决方案。多重复合任务可以通过同类归并压平成一个计数器，不同类的任务建议使用不同的计数器。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"concept","slug":"it/concept","permalink":"https://linlshare.github.io/categories/it/concept/"}],"tags":[{"name":"复合任务","slug":"复合任务","permalink":"https://linlshare.github.io/tags/复合任务/"},{"name":"状态","slug":"状态","permalink":"https://linlshare.github.io/tags/状态/"}]},{"title":"Proxy","slug":"it/robot/Proxy","date":"2018-12-20T08:33:35.000Z","updated":"2019-01-13T11:37:46.466Z","comments":true,"path":"2018/12/20/it/robot/Proxy/","link":"","permalink":"https://linlshare.github.io/2018/12/20/it/robot/Proxy/","excerpt":"","text":"代理（Proxy）代理是一种提供客户端与服务器进行非直接链接的服务。提供代理服务的服务器称之为代理服务器（Proxy Server）。而持有资源实体的服务器称之为源服务器。 代理服务器分类按代理协议 HTTP 代理：应用层协议代理，支持访问未加密站点 SOCKS 4/5 代理：会话层协议代理，SOCKS 5 支持所有底层使用 TCP 和 UDP 的网络应用代理，SOCKS 4 仅支持 TCP 代理。另外 SOCKS 5 还支持 IPv6。 TLS / SSL 代理：应用层协议代理，支持访问加密站点 POP3 / SMTP 代理：邮件服务代理 FTP 代理：文件传输代理 … 按匿名程度以下四种代理的区别是由于代理服务器配置的 REMOTE_ADDR、HTTP_VIA 和 HTTP_X_FORWARDED_FOR 值不同导致。当没有使用代理时仅 REMOTE_ADDR 是有值的。 高度匿名代理（Elite proxy或High Anonymity Proxy） 高匿代理其实就是修改请求头，将 HTTP_VIA 与 HTTP_X_FORWARDED_FOR 属性删除，服务器由此误认为客户端没有使用代理。 123REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined 匿名代理（Anonymous Proxy） 123REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP 透明代理（Transparent Proxy） 123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP 混淆代理（Distorting Proxy） 123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address 安全性上：高匿 &gt; 混淆 &gt; 匿名 &gt; 透明。 抓包工具Charles开始之前 安装 JDK 环境； 前往官网下载安装适合操作系统的 Charles； 如系统使用了 VPN 等软件，先暂时关闭。 快速开始 启用 HTTP 代理 在菜单栏选择 Proxy -&gt; Mac OS X Proxy 启动 HTTP 代理，如无效，可以直接打开 系统偏好设置 -&gt; 网络 -&gt; 进阶 -&gt; 代理服务器，然后设置为 127.0.0.1:8888 即可。 启用 SSL 代理 在菜单栏选择 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate 然后在系统的钥匙串访问中，双击这个证书，然后展开信任一栏，在 SSL 一栏选择始终信任； 然后在 Proxy -&gt; SSL Proxying Settings -&gt; add 添加 Host 为 *，Port 为 443，这样就可以针对所有站点进行 SSL 代理了。 参考 代理服务器 - 维基百科 proxy代理类型:透明代理 匿名代理 混淆代理和高匿代理 - gohom.win 透明代理和匿名代理的区别 - cnblogs.com Mac下使用charles遇到的问题以及解决办法 - cnblogs.com Charles 从入门到精通 - devtang.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"robot","slug":"it/robot","permalink":"https://linlshare.github.io/categories/it/robot/"}],"tags":[{"name":"Proxy","slug":"Proxy","permalink":"https://linlshare.github.io/tags/Proxy/"},{"name":"Charles","slug":"Charles","permalink":"https://linlshare.github.io/tags/Charles/"}]},{"title":"Beatles","slug":"music/Beatles","date":"2018-12-19T13:44:42.000Z","updated":"2019-01-13T11:37:46.628Z","comments":true,"path":"2018/12/19/music/Beatles/","link":"","permalink":"https://linlshare.github.io/2018/12/19/music/Beatles/","excerpt":"","text":"KEY VALUE 原名 The Beatles 译名 甲壳虫乐队 \\ 披头士乐队（大陆）、披頭四樂團（台灣）、披頭士樂隊 \\ 狂人樂隊（港澳） 出生地 英国英格兰利物浦 活跃年代 1960年–1970年 风格 摇滚、流行、民谣 成员 约翰·列侬（John Lennon）、保罗·麦卡特尼（Paul McCartney）、乔治·哈里森（George Harrison）和林戈·斯塔尔（Ringo Starr） 代表专辑 《Rubber Soul》（1965）、《Revolver》（1966）、《Sgt. Pepper’s Lonely Hearts Club Band》（1967）、《The Beatles (White Album)》（1968）以及《Abbey Road》（1969） 流行单曲 《Yesterday》、《Let it be》、《Hey Jude》、《Something》、《Blackbird》、《A Day in the Life》、《Come Together》、《Here Comes the Sun》 等等 影响力 披头士是史上最畅销的乐队，全球总销售量估算为6亿到10亿间。2004年，《滚石杂志》把披头士列历史上最伟大的艺人。2008年，披头士在《公告牌》的“史上最成功音乐人Hot 100”榜单上登顶。 作品目录（原版英国录音室专辑） 《Please Please Me》（1963年3月22日） 《With the Beatles》（1963年11月22日） 《A Hard Day’s Night》（1964年7月10日） 《Beatles for Sale》（1964年12月4日） 《Help!》（1965年8月6日） 《Rubber Soul》（1965年12月3日） 《Revolver》（1966年8月5日） 《Sgt. Pepper’s Lonely Hearts Club Band》（1967年6月1日） 《The Beatles》（1968年11月22日） 《Yellow Submarine》（1969年1月17日） 《Abbey Road》（1969年9月26日） 《Let It Be》（1970年5月8日） 《Rubber Soul》In My Life1234567891011121314151617181920212223242526272829[Verse 1]There are places I&apos;ll rememberAll my life though some have changedSome forever not for betterSome have gone and some remainAll these places had their momentsWith lovers and friends I still can recallSome are dead and some are livingIn my life I&apos;ve loved them all[Verse 2]But of all these friends and loversThere is no one compares with youAnd these memories lose their meaningWhen I think of love as something newThough I know I&apos;ll never lose affectionFor people and things that went beforeI know I&apos;ll often stop and think about themIn my life I love you more[Piano Solo][Verse 3]Though I know I&apos;ll never lose affectionFor people and things that went beforeI know I&apos;ll often stop and think about themIn my life I love you moreIn my life I love you more 《Revolver》Yellow Submarine123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[Verse 1]In the town where I was bornLived a man who sailed to seaAnd he told us of his lifeIn the land of submarines[Verse 2]So we sailed up to the sunTill we found the sea of greenAnd we lived beneath the wavesIn our yellow submarine[Chorus]We all live in a yellow submarineYellow submarine, yellow submarineWe all live in a yellow submarineYellow submarine, yellow submarine[Verse 3]And our friends are all aboardMany more of them live next doorAnd the band begins to play[Chorus]We all live in a yellow submarineYellow submarine, yellow submarineWe all live in a yellow submarineYellow submarine, yellow submarine[Bridge]Full speed ahead, Mr. Parker, full speed aheadFull speed over here, sirAction station, action stationAye, aye, sir, fireHeaven, heaven[Verse 4]As we live a life of easeEveryone of us has all we need (has all we need)Sky of blue (sky of blue) and sea of green (and sea of green)In our (In our) yellow submarine (yellow submarine, ha-ha!)[Chorus]We all live in a yellow submarineYellow submarine, yellow submarineWe all live in a yellow submarineYellow submarine, yellow submarineWe all live in a yellow submarineYellow submarine, yellow submarineWe all live in a yellow submarineYellow submarine, yellow submarine 《Abbey Road》Come Together12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[Intro: John Lennon]Shoot me, shoot me, shoot me, shoot me[Verse 1: John Lennon]Here come old flat-top, he come groovin&apos; up slowlyHe got ju-ju eyeballs, he one holy rollerHe got hair down to his kneeGot to be a joker, he just do what he please[Interlude: John Lennon]Shoot me, shoot me, shoot me, shoot me[Verse 2: John Lennon]He wear no shoeshine, he got toe-jam footballHe got monkey finger, he shoot Coca-ColaHe say, &quot;I know you, you know me&quot;One thing I can tell you is you got to be free[Chorus: John Lennon]Come together, right nowOver me[Verse 3: John Lennon]He bag production, he got walrus gumbootHe got Ono sideboard, he one spinal crackerHe got feet down below his kneeHold you in his armchair, you can feel his disease[Chorus: John Lennon]Come together, right nowOver me[Interlude: John Lennon]Shoot me, shoot meRight![Guitar Solo][Verse 4: John Lennon]He roller-coaster, he got early warnin&apos;He got muddy water, he one mojo filterHe say, &quot;One and one and one is three&quot;Got to be good-lookin&apos; &apos;cause he&apos;s so hard to see[Chorus: John Lennon]Come together, right nowOver me[Interlude: John Lennon]Shoot me, shoot me, shoot me, shoot meUgh![Outro: John Lennon]Come together, yeahCome together, yeahCome together, yeahCome together, yeahCome together, yeahCome together, yeahCome together, yeahCome together, yeah[Fade-out]Come together, yeahCome together... Something12345678910111213141516171819202122232425262728[Verse 1]Something in the way she movesAttracts me like no other loverSomething in the way she woos meI don&apos;t want to leave her nowYou know I believe and how[Verse 2]Somewhere in her smile she knowsThat I don&apos;t need no other loverSomething in her style that shows meI don&apos;t want to leave her nowYou know I believe and how[Bridge]You&apos;re asking me will my love growI don&apos;t know, I don&apos;t knowYou stick around and it may showI don&apos;t know, I don&apos;t know[Solo][Verse 3]Something in the way she knowsAnd all I have to do is think of herSomething in the things she shows meI don&apos;t want to leave her nowYou know I believe and how Here Comes the Sun1234567891011121314151617181920212223242526272829303132333435363738[Intro]Here comes the sun (doo doo doo doo)Here comes the sun, and I sayIt&apos;s all right[Verse 1]Little darling, it&apos;s been a long cold lonely winterLittle darling, it feels like years since it&apos;s been hereHere comes the sunHere comes the sun, and I sayIt&apos;s all right[Verse 2]Little darling, the smiles returning to the facesLittle darling, it seems like years since it&apos;s been hereHere comes the sunHere comes the sun, and I sayIt&apos;s all right[Bridge]Sun, sun, sun, here it comesSun, sun, sun, here it comesSun, sun, sun, here it comesSun, sun, sun, here it comesSun, sun, sun, here it comes[Verse 3]Little darling, I feel that ice is slowly meltingLittle darling, it seems like years since it&apos;s been clearHere comes the sunHere comes the sun, and I sayIt&apos;s all right[Outro]Here comes the sunHere comes the sunIt&apos;s all rightIt&apos;s all right 《Let It Be》Across the Universe12345678910111213141516171819202122232425262728293031323334353637383940414243444546[Verse 1: John Lennon]Words are flowing out like endless rain into a paper cupThey slither while they pass, they slip away across the universePools of sorrow, waves of joy are drifting through my opened mindPossessing and caressing me[Chorus: John Lennon]Jai Guru Deva, OmNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my world[Verse 2: John Lennon]Images of broken light which dance before me like a million eyesThey call me on and on across the universeThoughts meander like a restless wind inside a letter boxThey tumble blindly as they make their way across the universe[Chorus: John Lennon]Jai Guru Deva, OmNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my world[Verse 3: John Lennon]Sounds of laughter, shades of life are ringing through my open earsInciting and inviting meLimitless undying love which shines around me like a million sunsIt calls me on and on, across the universe[Chorus: John Lennon]Jai Guru Deva, OmNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my worldNothing&apos;s going to change my world[Outro: John Lennon]Jai Guru DevaJai Guru DevaJai Guru DevaJai Guru DevaJai Guru DevaJai Guru Deva A Hard Day’s Night123456789101112131415161718192021It&apos;s been a hard day&apos;s night, and I been working like a dogIt&apos;s been a hard day&apos;s night, I should be sleeping like a logBut when I get home to you I&apos;ll find the things that you doWill make me feel alrightYou know I work all day to get you money to buy you thingsAnd it&apos;s worth it just to hear you say you&apos;re going to give me everythingSo why on earth should I moan, &apos;cause when I get you aloneYou know I feel okWhen I&apos;m home everything seems to be rightWhen I&apos;m home feeling you holding me tight, tightOwww!So why on earth should I moan, &apos;cause when I get you aloneYou know I feel okWhen I&apos;m home everything seems to be rightWhen I&apos;m home feeling you holding me tight, tight, yeahIt&apos;s been a hard day&apos;s night, and I been working like a dogIt&apos;s been a hard day&apos;s night, I should be sleeping like a logBut when I get home to you I&apos;ll find the things that you doWill make me feel alrightYou know I feel alrightYou know I feel alright... 参考 披头士乐队 - 维基百科 The Beatles - YouTube Music The Beatles - genius.com The Beatles complete and original digital discography in stereo - digitalk7.com","categories":[{"name":"music","slug":"music","permalink":"https://linlshare.github.io/categories/music/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://linlshare.github.io/tags/Music/"},{"name":"Beatles","slug":"Beatles","permalink":"https://linlshare.github.io/tags/Beatles/"}]},{"title":"Port","slug":"it/net/Port","date":"2018-12-19T02:33:02.000Z","updated":"2019-01-13T11:37:46.463Z","comments":true,"path":"2018/12/19/it/net/Port/","link":"","permalink":"https://linlshare.github.io/2018/12/19/it/net/Port/","excerpt":"","text":"端口的概念端口有两种含义需要仔细区分： 物理端口，指用于连接其他网络设备的接口，比如 RJ-45端口； 协议端口，指 TCP/IP 协议中的定义的逻辑端口，用于标识，比如 80 端口。 协议端口TCP/IP 协议中的协议端口用于解决远程主机进程定位的问题。IP + Port 才能真正定位想要访问的远程服务。 其工作流程如下： 进程请求主机系统分配端口； 主机系统分配端口； 主机收到数据包，根据数据包报文首部的端口号，发送到相应的端口队列； 进程取用端口队列中的数据包。 端口其实就是队，操作系统为各个进程分配了不同的队，数据包按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，不过操作系统允许各进程指定和调整自己的队的大小。 — 端口 - 百度百科 一些常见的端口号： 应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP 熟知端口号 21 23 25 53 69 80 443 161 参考 理解 TCP 和 UDP - gitbook.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"net","slug":"it/net","permalink":"https://linlshare.github.io/categories/it/net/"}],"tags":[{"name":"Port","slug":"Port","permalink":"https://linlshare.github.io/tags/Port/"},{"name":"端口","slug":"端口","permalink":"https://linlshare.github.io/tags/端口/"}]},{"title":"RESTful API","slug":"it/design/RESTful API","date":"2018-12-18T03:24:29.000Z","updated":"2019-01-13T11:37:46.375Z","comments":true,"path":"2018/12/18/it/design/RESTful API/","link":"","permalink":"https://linlshare.github.io/2018/12/18/it/design/RESTful API/","excerpt":"","text":"注意 API 版本号放入到 URL 中； 更新信息时仅返回被更新的字段。 参考 RESTful API 设计指南 - ruanyifeng.com RESTful API Design. Best Practices in a Nutshell. - philipphauer.de REST API 使用详解 - leancloud.cn","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"design","slug":"it/design","permalink":"https://linlshare.github.io/categories/it/design/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://linlshare.github.io/tags/RESTful/"},{"name":"API","slug":"API","permalink":"https://linlshare.github.io/tags/API/"}]},{"title":"Node.js","slug":"it/node/Node.js","date":"2018-12-18T01:47:20.000Z","updated":"2019-01-18T10:08:39.724Z","comments":true,"path":"2018/12/18/it/node/Node.js/","link":"","permalink":"https://linlshare.github.io/2018/12/18/it/node/Node.js/","excerpt":"","text":"安装使用 nvm 安装（可以自由切换 node 版本）（1）下载并执行安装脚本 1234# curl curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash# 或者 wgetwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash （2）下载并使用指定版本的 node.js 12345678# 列出仓库中所有的 node 版本$ nvm ls-remote# 安装指定版本$ nvm install 8.11.1# 使用已安装的某个版本$ nvm use 8.11.1# 查看当前使用的 node 版本$ nvm -v （3）卸载指定版本的 node.js 123# 如果要卸载的版本是当前使用的版本，那么需要先停用它$ nvm deactivate$ nvm uninstall 8.11.1 异步编程 callback promise async/await 排错/usr/bin/env: node: No such file or directory（1）背景：执行 npm start 命令时出现上述错误。 （2）原因：npm 执行时默认使用 /usr/bin/node 去执行，而通过 sudo apt install nodejs 安装的位置是在 /usr/bin/nodejs 。 （3）解决方案： 方案一：使用nvm 安装 node，并统一管理 node.js 版本，这是最佳方案； 方案二：创建 node 执行文件到 /usr/bin/node 的软连接，如 ln -s /usr/local/NODEJS_HOME/bin/node /usr/bin/node 参考 How To Install Node.js on Ubuntu 18.04 - digitalocean.com creationix/nvm - github.com 【node错误】/usr/bin/env: node: No such file or directory - tencent.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"node","slug":"it/node","permalink":"https://linlshare.github.io/categories/it/node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://linlshare.github.io/tags/Node-js/"}]},{"title":"Package & Deploy","slug":"it/java/base/Package & Deploy","date":"2018-12-15T06:37:41.000Z","updated":"2019-01-21T10:11:13.051Z","comments":true,"path":"2018/12/15/it/java/base/Package & Deploy/","link":"","permalink":"https://linlshare.github.io/2018/12/15/it/java/base/Package & Deploy/","excerpt":"","text":"开发测试阶段的打包部署 [ ] 配置登录远程机器的 SSH config [ ] 本地使用 Gradle 或者 Maven 打包 [ ] 使用 scp 安全拷贝 jar 包到远程机器 [ ] 使用 sudo apt install openjdk-8-jre-headless （Ubuntu） 或者 sudo yum install java-1.8.0-openjdk （CentOS）安装 JDK 环境 [ ] 使用 java -jar 完成部署 分布式打包部署 [ ] 部署 docker 环境 [ ] 在 docker 中部署 etcd [ ] 部署 kafka [ ] 部署应用服务 排错Can’t execute jar- file: “no main manifest attribute”在 Linux 上运行 jar 包时出现无法执行的错误，原来是没有配置主类，解决方案如下： 1234567apply plugin: 'java'jar &#123; manifest &#123; attributes 'Main-Class': 'com.package.app.Class' &#125;&#125; 打出的包不包含任何第三方依赖解压打出来的 jar 包发现里面没有第三方依赖无法运行，这时候有两种解决方案： （1）把第三方的 jar 包收集放到一个 class path 目录，然后就可以正常启动了。不过这种方法很笨，因为现在的依赖都是通过 gradle 或者 maven 引入，手动去找这些 jar 包并放到服务器上的 class path 目录，这很费劲，不过好处是打出的包很小，上传很快。 （2）使用 shadow 将所有依赖合并成一个 jar 包，这很神奇。 12345678910111213141516171819buildscript &#123; repositories &#123; maven &#123; url \"https://plugins.gradle.org/m2/\" &#125; &#125; dependencies &#123; classpath \"com.github.jengelman.gradle.plugins:shadow:4.0.3\" &#125;&#125;apply plugin: 'java'apply plugin: \"com.github.johnrengelman.shadow\"shadowJar &#123; manifest &#123; attributes 'Main-Class': 'com.example.Main' &#125;&#125; 改完 gradle 脚本之后打包命令不再是 ./gradlew assemble 而是用 ./gradlew shadowJar。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JavaEE","slug":"JavaEE","permalink":"https://linlshare.github.io/tags/JavaEE/"},{"name":"Package","slug":"Package","permalink":"https://linlshare.github.io/tags/Package/"},{"name":"Deploy","slug":"Deploy","permalink":"https://linlshare.github.io/tags/Deploy/"}]},{"title":"CSV","slug":"it/media/CSV","date":"2018-12-15T02:51:47.000Z","updated":"2019-01-13T11:37:46.463Z","comments":true,"path":"2018/12/15/it/media/CSV/","link":"","permalink":"https://linlshare.github.io/2018/12/15/it/media/CSV/","excerpt":"","text":"CSV 是什么格式？CSV，全称 Comma-Separated Value，即逗号分隔值，使用逗号（或者自定义的分隔符）分隔并以纯文本形式存储表格数据。通常使用第一行作为表头。 快速开始（1）打开编辑器，粘贴以下内容。 123Brand,Product,DescApple,IPhone,ExpensiveSamsung,S9,Nice （2） 存储为 .csv 结尾的文件。 （3）使用 Excel 或者 Number 打开，就会以表格形式呈现内容。 内容中含有逗号？（1）自定义分隔符如下，并保存文件。 123Brand`Product`DescApple`IPhone,Mac`ExpensiveSamsung`S8,Galaxy Watch`Nice （2）打开 Excel 新建文档，然后点击 文档 --&gt; 导入，选取刚才保存的 csv 文件。在弹出的提示框中选择 分隔符号 --&gt; 下一步 --&gt; 其他， 输入自定义的分隔符号，点击 完成 即可。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"media","slug":"it/media","permalink":"https://linlshare.github.io/categories/it/media/"}],"tags":[{"name":"CSV","slug":"CSV","permalink":"https://linlshare.github.io/tags/CSV/"}]},{"title":"Amazon S3","slug":"it/java/aws/Amazon S3","date":"2018-12-14T04:02:45.000Z","updated":"2019-01-13T11:37:46.381Z","comments":true,"path":"2018/12/14/it/java/aws/Amazon S3/","link":"","permalink":"https://linlshare.github.io/2018/12/14/it/java/aws/Amazon S3/","excerpt":"","text":"Amazon S3 是什么？Amazon S3 是亚马逊推出的一款存储服务，名为 Amazon Simple Storage Service，即亚马逊简单存储服务。 有些 S3 的概念需要了解一下： 存储桶（Buckets）：S3 中用于存储对象的容器，相当于文件系统中的目录（Directory）的概念。 对象（Objects）：S3 中存储的基本实体，由对象数据和元数据组成，元数据是描述对象的一组键值对。在存储中的对象由键和版本 ID 唯一标识。 键（Keys）：存储桶中对象的唯一标识符。 区域（Regions）：地理区域。 S3 中的对象映射：存储桶 + 键 + 版本 –&gt; 对象 API 1.0排错身份验证错误BasicProfileConfigLoader - Your profile name includes a ‘profile ‘ prefix. This is considered part of the profile name in the Java SDK, so you will need to include this prefix in your profile name when you reference this profile from your Java code.","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"aws","slug":"it/java/aws","permalink":"https://linlshare.github.io/categories/it/java/aws/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"aws","slug":"aws","permalink":"https://linlshare.github.io/tags/aws/"},{"name":"S3","slug":"S3","permalink":"https://linlshare.github.io/tags/S3/"}]},{"title":"日語漢字","slug":"language/日語/日語漢字","date":"2018-12-14T00:48:25.000Z","updated":"2019-01-13T11:37:46.596Z","comments":true,"path":"2018/12/14/language/日語/日語漢字/","link":"","permalink":"https://linlshare.github.io/2018/12/14/language/日語/日語漢字/","excerpt":"","text":"日語漢字源自中國中古漢字，由於地理、貿易和政治的隔絕，中日獨立發展了漢字，使得日語漢字在音、形及意上與中國漢字有所差異。 簡化方式不同中國大陸以及日本都獨立地進行了漢字簡化運動，繁體字的部件被簡化了。下面來看看哪些部件被簡化了，簡化成什麼樣了？ 日語漢字 中文繁體 中文簡體 売、読 賣、讀 卖、读 済 齊、濟 齐、济 採用了古字形有些日語漢字至今沿用了中古漢字的字形，而中文漢字方面已經有流變了。 日語漢字 中文繁體 中文簡體 帯 帶 带 縄 繩 绳 舎 舍 舍 軽 輕 轻 不用的漢字表示同一個意思有些日語漢字採用的漢字在中文漢字中很少使用了，已經用新造的漢字表示了，他們是不同的漢字，而不是同一漢字的不同字形，這點要區分開。 日語漢字 中文繁體 中文簡體 曇 陰 阴 芸 藝 艺","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日語","slug":"日語","permalink":"https://linlshare.github.io/tags/日語/"}]},{"title":"Jconsole","slug":"it/tool/Jconsole","date":"2018-12-13T13:27:50.000Z","updated":"2019-01-13T11:37:46.482Z","comments":true,"path":"2018/12/13/it/tool/Jconsole/","link":"","permalink":"https://linlshare.github.io/2018/12/13/it/tool/Jconsole/","excerpt":"","text":"Jconsole 是干嘛的？Jsonsole 是 JDK_HOME/bin 目录下的一个可执行程序，用于 Java 性能分析，其 GUI 虽简陋，但功能还是可以的。 快速开始在终端运行以下命令后就可以监控本地的 Java 程序了。 1$ jconsole 更进一步1234# 监控远程 Java 程序$ jconsole hostName:portNum# 监控指定进程 ID 的程序$ jconsole processID 参考 Using JConsole - oracle.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Tool","slug":"Tool","permalink":"https://linlshare.github.io/tags/Tool/"},{"name":"Jconsole","slug":"Jconsole","permalink":"https://linlshare.github.io/tags/Jconsole/"}]},{"title":"澳門博彩業簡史","slug":"history/澳門博彩業簡史","date":"2018-12-12T14:41:13.000Z","updated":"2019-01-13T11:37:46.360Z","comments":true,"path":"2018/12/12/history/澳門博彩業簡史/","link":"","permalink":"https://linlshare.github.io/2018/12/12/history/澳門博彩業簡史/","excerpt":"","text":"簡史 16 世紀開埠，內地工人移民澳門工作，并開設賭檔，監管不利，賭風盛行； 1842年，香港被割，影響了澳門的貿易港地位，為增加多元收入，1847 年澳葡政府決定博彩業合法化，博彩業迅猛發展； 1851年 ~ 1863年，澳葡政府對博彩場所實行發牌制度，賭檔曾一度多達二百餘家，其時盧九的宜安公司集賭場、妓院、酒館、鴉片煙窟於一體； 1930年，豪興公司獲得所有博彩遊戲的專營權； 1937年，澳葡政府決定博彩專營，由泰興公司投得； 1961年底，泰興公司期滿，由澳門旅遊娛樂有限公司投得； 2000年7月，澳門特區政府成立博彩委員會； 2000年8月，立法會通過《娛樂場幸運博彩經營法律制度》，規定只發出最多三個賭牌，打破博彩業壟斷； 2002年2月8日，澳門特區政府宣佈將娛樂場幸運博彩經營權批給原「澳門旅遊娛樂有限公司」新組成的「澳門博彩股份有限公司」(簡稱「澳博」)、「銀河娛樂場股份有限公司」(簡稱「銀河」)及「永利渡假村(澳門)股份有限公司」(簡稱「永利」)，其中「澳博」有效期18年，直到2020年3月，「銀河」和「永利」有效期20年，直到2022年6月。 名詞幸運博彩1961年2月，經第119任總督馬濟時界定了賭博與博彩的定義：“凡博彩，其結果為偶然性，純粹幸運致勝者”，概稱“幸運博彩”。 東方蒙地卡羅蒙地卡羅（法語：Monte-Carlo）是歐洲地中海沿岸的小國摩納哥的一座城市，有「賭博之國」之稱。「東方蒙地卡羅」自然就是指澳門了。 參考 澳 門 博 彩 業 歷 史 - 澳門博彩監察局 澳門博彩業 - 維基百科 澳門博彩業大事追尋 - 澳門社會發展研究會","categories":[{"name":"history","slug":"history","permalink":"https://linlshare.github.io/categories/history/"}],"tags":[{"name":"History","slug":"History","permalink":"https://linlshare.github.io/tags/History/"},{"name":"澳門","slug":"澳門","permalink":"https://linlshare.github.io/tags/澳門/"},{"name":"博彩業","slug":"博彩業","permalink":"https://linlshare.github.io/tags/博彩業/"}]},{"title":"FunnyTool","slug":"it/tool/FunnyTool","date":"2018-12-12T03:57:21.000Z","updated":"2019-01-13T11:37:46.476Z","comments":true,"path":"2018/12/12/it/tool/FunnyTool/","link":"","permalink":"https://linlshare.github.io/2018/12/12/it/tool/FunnyTool/","excerpt":"","text":"这里是各类有趣的在线工具的收集箱。收藏品如下： Tool Features asciiflow.com 绘制 ASCII 格式的代码注释","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://linlshare.github.io/tags/Tool/"}]},{"title":"Bach","slug":"music/Bach","date":"2018-12-09T12:41:49.000Z","updated":"2019-01-13T11:37:46.627Z","comments":true,"path":"2018/12/09/music/Bach/","link":"","permalink":"https://linlshare.github.io/2018/12/09/music/Bach/","excerpt":"","text":"KEY VALUE 原名 Johann Sebastian Bach（德语） 译名 約翰·塞巴斯蒂安·巴哈（台灣）、约翰·塞巴斯蒂安·巴赫（大陆） 国籍 神圣罗马帝国（德国） 生卒 1685年3月21日（Eisenach，埃森纳赫）－1750年7月28日（St Thomas Church，莱比锡圣多马教堂） 风格 巴洛克、复调音乐 身份 作曲家，管风琴、小提琴和大键琴演奏家，宫廷乐长 作品 按作品目录分类，冠之以 BWV（巴赫作品目录），共有 1126 件各类音乐作品。注意：BWV 中少数非巴赫所作。 影响力 生前未得到正确的评价，死后数十年亦然，直到1829年，门德尔松改编并指挥了巴赫的《马太受难曲》，震惊音乐界，随后开始了“复兴巴赫”运动，才逐渐恢复应有的地位。如今巴赫与维瓦尔第、亨德尔并称巴洛克三巨匠，在音乐史上和莫扎特、贝多芬齐名。 十二平均律键盘曲集（BWV 846-893）巴赫的十二平均律键盘曲集（BWV 846-893）是其较著名作品之一，古尔德和里赫特都曾演奏过。里赫特演奏的版本收录在其专辑 《The Well-Tempered Clavier》中。古尔德演奏的版本收录在其专辑《Bach: The Well-Tempered Clavier Book I, BWV 846-869》及《The Glenn Gould Edition - Bach: The Well-Tempered Clavier, Book II》中。注意：这里所用的专辑名称来自网易云音乐。 入选旅行者金唱片（Voyager Golden Records）1977 年 NASA 发射了两艘旅行者号太空探测器，其中放置了一张旅行者金唱片，里面收录了用以表述地球上各种文化及生命的声音及图像。其中就有三首属于巴赫的作品： 《F大调第二勃兰登堡协奏曲》第一乐章，BWV 1047 《E大调无伴奏小提琴组曲第三号》之回旋曲式的加沃特（Gavotte en rondeaux），BWV 1006 《平均律钢琴曲集》第二卷第一号，C大调前奏曲及赋格，BWV 870 小贴士：旅行者金唱片可以通过访问网站 goldenrecord.org ，在线播放其中的声音和图像，很有意思。 参考 约翰·塞巴斯蒂安·巴赫 - 维基百科 旅行者金唱片 - 维基百科","categories":[{"name":"music","slug":"music","permalink":"https://linlshare.github.io/categories/music/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://linlshare.github.io/tags/Music/"},{"name":"Bach","slug":"Bach","permalink":"https://linlshare.github.io/tags/Bach/"}]},{"title":"海蒂和爷爷","slug":"movie/海蒂和爷爷","date":"2018-12-08T15:14:31.000Z","updated":"2019-01-13T11:37:46.618Z","comments":true,"path":"2018/12/08/movie/海蒂和爷爷/","link":"","permalink":"https://linlshare.github.io/2018/12/08/movie/海蒂和爷爷/","excerpt":"","text":"1234567891011导演: 阿兰·葛斯彭纳编剧: 约翰娜·施皮里 / 佩特拉·比翁迪娜·沃尔普主演: 阿努克·斯特芬 / 布鲁诺·甘茨 / 昆林·艾格匹 / 安娜·申茨 / 伊莎贝尔·奥特曼 / 更多...类型: 剧情 / 家庭 / 冒险官方网站: www.heidi.studiocanal.de制片国家/地区: 德国 / 瑞士 / 南非语言: 德语 / 瑞士德语 / 南非语上映日期: 2015-12-10(德国)片长: 111分钟又名: 飘零燕(港) / 海蒂 / 阿尔卑斯山少女海蒂IMDb链接: tt3700392 海蒂，一个瑞士小女孩，父母双亡，由姨妈带大。后来姨妈想要去法兰克福工作，不能再带海蒂了，于是把她带到她爷爷住的山上。爷爷是一个性情冷淡的老人，邻居都不敢靠近他，甚至流言说他杀过人。爷爷不肯接纳海蒂，但是姨妈已经弃海蒂而去了。尽管爷爷心里抗拒，关闭了房门，可海蒂已经跳进羊圈跟小羊度过了第一天。慢慢地，爷爷接纳了海蒂，让她睡阁楼的草垫上，还给她做了一把小木椅。海蒂也融入了爷爷阿尔卑斯山里自由自在的生活，认识了小牧羊人皮特，并成为了好朋友。 有一天，海蒂的姨妈又来了，骗走了海蒂，把她卖给了法兰克福一个富裕人家，给他们的小姐克拉拉做玩伴。“粗鲁”的海蒂要遵守各种繁文缛节，常常闹出笑话，给孤独而且双脚不便的克拉拉带来了很多欢乐。克拉拉的奶奶还给海蒂读故事书，海蒂很喜欢，可是奶奶读了不到一半就停了，告诉海蒂想知道后面的故事，要认字。于是，海蒂认真地听私人教师的课。没多久就学会了念读故事书，大家都很高兴。但海蒂心里一直想着阿尔卑斯山、爷爷、皮特还有山羊，还因此梦游去开门，风吹门发出奇怪的声音，大家都以为是闹鬼了。主人家的医生发现后建议主人送她回家以免积郁成疾。尽管克拉拉不肯而发脾气，主人也不情愿，但还是送海蒂回到了阿尔卑斯山。 海蒂又回到了故乡，那人，那山，那山羊，心里无限欢快。海蒂写信给克拉拉，告诉她这里的生活，要她过来这里看看。克拉拉的奶奶把信读给克拉拉听了。不久，她们就来到了海蒂身边，两人紧紧拥抱，笑容可掬。奶奶留下了克拉拉几天，跟着海蒂一起在大山里玩耍。这时皮特不乐意了，因为他觉得海蒂好像被克拉拉抢走了。于是，在一天早上，把克拉拉的轮椅推向了山谷。这一天，爷爷背着克拉拉，海蒂在后面，一起去放羊。克拉拉坐在石头上，一只蝴蝶落在她的脚上，她伸手去抓，蝴蝶飞起来了，她站起来想要去抓。是的，她站起来了！海蒂和皮特搀扶着她，每天练习走路。在他爸爸来接她的时候，她缓步走向她爸爸，她爸爸和奶奶感动得眼泪夺眶而出，抱起了克拉拉。克拉拉回家了。海蒂和爷爷，也回家了。他们春天放羊，冬天滑雪橇。","categories":[{"name":"movie","slug":"movie","permalink":"https://linlshare.github.io/categories/movie/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://linlshare.github.io/tags/电影/"}]},{"title":"WebMagic","slug":"it/robot/WebMagic","date":"2018-12-07T02:06:53.000Z","updated":"2019-01-13T11:37:46.468Z","comments":true,"path":"2018/12/07/it/robot/WebMagic/","link":"","permalink":"https://linlshare.github.io/2018/12/07/it/robot/WebMagic/","excerpt":"","text":"WebMagic 是干嘛的？WebMagic 是一个 Java 平台上的开源爬虫框架，其设计参考了 Scrapy，实现则参考了 HttpClient 和 Jsoup。其由四大组件组成： Downloader，负责下载网页，使用 HttpClient。 PageProcessor，负责解析网页和链接发现，使用 Jsoup 和 Xsoup。 Scheduler，负责管理待抓取的 URL 和去重。 Pipeline，负责结果数据的持久化。 快速开始（1）依赖引入1234567891011121314151617ext &#123; versions = [ \"web_magic\": '0.7.3' ]&#125;dependencies &#123; // 这里有自己项目的日志实现 compile project(':base') compile(\"us.codecraft:webmagic-core:$&#123;versions.web_magic&#125;\") &#123; exclude group: 'org.slf4j', module: 'slf4j-log4j12' // 移除默认的日志实现 &#125; compile(\"us.codecraft:webmagic-extension:$&#123;versions.web_magic&#125;\") &#123; exclude group: 'org.slf4j', module: 'slf4j-log4j12' &#125;&#125; （2）快速开始爬取 https://github.com/code4craft/ 页面上可以发现的所有 Github 仓库信息。 123456789101112131415161718192021222324252627282930313233343536373839public class GithubRepoPageProcessor implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(200).setTimeOut(10000); @Override public void process(Page page) &#123; String regex = \"(https://github\\\\.com/code4craft/([\\\\w-_]+)/)\"; page.addTargetRequests(page.getHtml() .links() .regex(regex) .all()); if(!Pattern.matches(regex,page.getUrl().get()))&#123; //skip this page page.setSkip(true); &#125; page.putField(\"author\", page.getUrl().regex(\"https://github\\\\.com/(\\\\w+)/.*\").toString()); page.putField(\"name\", page.getHtml() .xpath(\"//meta[@property='og:title']/@content\") .toString()); if (page.getResultItems().get(\"name\") == null) &#123; page.setSkip(true); &#125;// page.putField(\"readme\", page.getHtml().xpath(\"//div[@id='readme']/tidyText()\")); &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) &#123; Spider.create(new GithubRepoPageProcessor()) .addUrl(\"https://github.com/code4craft/\") .thread(5) .run(); &#125;&#125; 更进一步Pipeline 接口参数分析Pipeline 接口会在每个 Page 解析完成之后回调一次。其中的参数如下： （1）Task 12345678910111213141516171819202122232425262728293031&#123; \"exitWhenComplete\": true, \"pageCount\": 0, // 抓取的第几页 \"scheduler\": &#123; \"duplicateRemover\": &#123;&#125; &#125;, \"site\": &#123; \"acceptStatCode\": [ 200 ], \"allCookies\": &#123;&#125;, \"cookies\": &#123;&#125;, \"cycleRetryTimes\": 0, \"disableCookieManagement\": false, \"domain\": \"github.com\", \"headers\": &#123; \":method\": \"GET\", \"origin\": \"https://github.com\" &#125;, \"retrySleepTime\": 1000, \"retryTimes\": 3, \"sleepTime\": 100, \"timeOut\": 10000, \"useGzip\": true &#125;, \"spawnUrl\": true, \"startTime\": 1544165065094, \"status\": \"Running\", \"threadAlive\": 1, \"uUID\": \"github.com\"&#125; （2）ResultItems 1234567891011121314&#123; \"all\": &#123; // 自定义的字段在这里 \"a_key\":\"a_value\" &#125;, \"request\": &#123; \"binaryContent\": false, \"cookies\": &#123;&#125;, \"headers\": &#123;&#125;, \"priority\": 0, \"url\": \"https://github.com/code4craft?tab=repositories\" &#125;, \"skip\": false&#125; 排错Https下无法抓取只支持TLS1.2的站点作者 code4craft 针对 ISSUE 701 提供了如下的解决方案： 12345678更新会在0.7.4版本发布。临时适配方式，修改HttpClientGenerator中的buildSSLConnectionSocketFactory方法，return new SSLConnectionSocketFactory(createIgnoreVerifySSL(), new String[]&#123;&quot;SSLv3&quot;, &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;&#125;, null, new DefaultHostnameVerifier())重写自己实现的HttpClientDownloader，并设置到Spider中。 java.net.UnknownHostException请检查网络连接。 参考 WebMagic in Action - webmagic.io","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"robot","slug":"it/robot","permalink":"https://linlshare.github.io/categories/it/robot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Robot","slug":"Robot","permalink":"https://linlshare.github.io/tags/Robot/"},{"name":"WebMagic","slug":"WebMagic","permalink":"https://linlshare.github.io/tags/WebMagic/"}]},{"title":"Spring Cache","slug":"it/java/cache/Spring Cache","date":"2018-12-05T14:46:21.000Z","updated":"2019-01-13T11:37:46.451Z","comments":true,"path":"2018/12/05/it/java/cache/Spring Cache/","link":"","permalink":"https://linlshare.github.io/2018/12/05/it/java/cache/Spring Cache/","excerpt":"","text":"为什么要使用 Spring Cache 管理缓存？让 Spring 来管理 Bean 的缓存具有以下优势： Spring 支持 HashMap 缓存，Redis 缓存以及自定义的缓存方式； Spring 缓存几乎不需要写代码，只需要配置好并声明好注解。 快速开始（1）依赖引入这里使用 Spring 的依赖管理器来管理 Spring Cache 的版本，会自动处理内部的模块间依赖，这也是推荐的方式。 1234567891011121314151617181920buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE\") &#125;&#125;apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'repositories &#123; mavenCentral()&#125;dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-cache\")&#125; （2）启用缓存在 SpringApplication 配置类的地方添加以下注解以启用缓存功能。 12@SpringBootApplication@EnableCaching （3）ConcurrentHashMap 缓存当没有配置其他缓存库时，默认使用 ConcurrentHashMap 作为缓存仓库。 （3.1）一个简单的实体类123456789101112public class Customer &#123; public String id; public String firstName; public String lastName; public Customer() &#123;&#125; public Customer(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; （3.2）一个 Repository12345678public class CustomerRepository &#123; @Cachable Customer getByFirstName(String firstName)&#123; // 这里应该是从数据库查询数据，DEMO 简省成直接新建了。 return new Customer(firstName, \"Jobs\"); &#125;&#125; （3.3）测试一下如果缓存成功了，那么以下代码执行结果的 HashCode 是一致的。 123456789101112131415161718@Componentpublic class AppRunner implements CommandLineRunner &#123; private static final Logger logger = LoggerFactory.getLogger(AppRunner.class); private final CustomerRepository customerRepository; public AppRunner(CustomerRepository customerRepository) &#123; this.customerRepository = customerRepository; &#125; @Override public void run(String... args) throws Exception &#123; logger.info(\"John --&gt;\" + customerRepository.getByFirstName(\"John\").hashCode()); logger.info(\"John --&gt;\" + customerRepository.getByFirstName(\"John\").hashCode()); logger.info(\"John --&gt;\" + customerRepository.getByFirstName(\"John\").hashCode()); &#125;&#125; （4）配合 Redis 缓存（4.1）添加 Redis 依赖在前面的依赖之下再额外新增 Redis 相关的依赖，如下： 1234// 本环境中的 spring-data-redis 为 1.8.7.RELEASE 版本// 高版本的配置略有不同，请留意compile (\"org.springframework.data:spring-data-redis\") compile \"redis.clients:jedis:2.9.0\" （4.2）配置 Redis12345678910111213141516171819202122232425262728293031323334353637383940414243@Configurationpublic class RedisConfig &#123; private final static Logger LOGGER = LoggerFactory.getLogger(RedisConfig.class); private final static Map&lt;String, Long&gt; CACHE_EXPIRE_MAP = new HashMap&lt;&gt;(); static &#123; CACHE_EXPIRE_MAP.put(\"cache1\", 5 * 60L); //second &#125; @Bean RedisConnectionFactory redisConnectionFactory() &#123; JedisConnectionFactory jedisConFactory = new JedisConnectionFactory(); jedisConFactory.setHostName(\"localhost\"); jedisConFactory.setPort(6379); return jedisConFactory; &#125; @Bean StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125; @Bean RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); template.afterPropertiesSet(); // 默认为 JdkSerializationRedisSerializer, 配合 @Cacheable 时 KEY 会有序列化值在中间 // 使用 StringRedisSerializer 则不会如此 template.setKeySerializer(new StringRedisSerializer()); return template; &#125; @Bean public RedisCacheManager cacheManager(RedisTemplate redisTemplate) &#123; RedisCacheManager cm = new RedisCacheManager(redisTemplate); cm.setCacheNames(CACHE_EXPIRE_MAP.keySet()); cm.setExpires(CACHE_EXPIRE_MAP); cm.setUsePrefix(true); cm.setCachePrefix(cacheName -&gt; (cacheName + \":\").getBytes()); return cm; &#125;&#125; （4.2）序列化实体类Spring 在将实体类缓存到 Redis 中时进行了序列化操作，如果不对实体类进行序列化将会报错。 123456789101112public class Customer implements Serializable &#123; public String id; public String firstName; public String lastName; public Customer() &#123;&#125; public Customer(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; （4.3）在需要缓存的位置使用注解，并指定缓存名如果在使用 Redis 缓存时，没有指定缓存名，将会报错：no cache could be resolved for at least one cache should be provided per cache operation。 12345678public class CustomerRepository &#123; @Cachable(\"cache1\") Customer getByFirstName(String firstName)&#123; // 这里应该是从数据库查询数据，DEMO 简省成直接新建了。 return new Customer(firstName, \"Jobs\"); &#125;&#125; （4.4）测试一下测试代码同（3.3）。除此之外还可以通过 Redis CLI 检验缓存结果： 1234&gt; KEYS *1) \"cache1:cb5775e6-1b39-4f63-85c8-13f134a54f32\"&gt; GET \"cache1:cb5775e6-1b39-4f63-85c8-13f134a54f32\"&gt; TTL \"cache1:cb5775e6-1b39-4f63-85c8-13f134a54f32\" 更进一步创建自定义的 KeyGenerator 使上述的 RedisConfig 继承 CachingConfigurerSupport，这一步很重要，否则创建自定义的 KeyGenerator 失败； 使用 @Bean 声明自定义的 KeyGenerator。代码如下： 1234567891011121314@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean @Override public KeyGenerator keyGenerator() &#123; return new SimpleKeyGenerator() &#123; @Override public Object generate(Object target, Method method, Object... params) &#123; // 这里使用 [`] 分割参数，更进一步的还可以加入 method 名，或者直接重写一个 KeyGenerator。 return super.generate(target, method, StringUtils.arrayToDelimitedString(params, \"`\")); &#125; &#125;; &#125;&#125; 这样，就可以覆盖 Spring Cache 默认的 SimpleKeyGenerator 了。 参考 Caching Data with Spring - spring.io Caching - spring.io A Guide To Caching in Spring - baeldung.com Spring Data Redis spring使用redis做缓存 - cnblogs.com Spring Cache – Creating a Custom KeyGenerator","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"cache","slug":"it/java/cache","permalink":"https://linlshare.github.io/categories/it/java/cache/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"},{"name":"Cache","slug":"Cache","permalink":"https://linlshare.github.io/tags/Cache/"}]},{"title":"Spring Data MongoDB","slug":"it/java/persistence/Spring Data MongoDB","date":"2018-12-05T06:25:40.000Z","updated":"2019-01-13T11:37:46.458Z","comments":true,"path":"2018/12/05/it/java/persistence/Spring Data MongoDB/","link":"","permalink":"https://linlshare.github.io/2018/12/05/it/java/persistence/Spring Data MongoDB/","excerpt":"","text":"用途快速集成 MongoDB，不用写一行 MongoDB 的 CRUD 语句。而是使用 Spring Data 独有的方法命名方式定义数据库操作，并且可以方便地替换各种数据库，比如 MySQL。 快速开始（0）开始之前确保已有可连接的 MongoDB （1）依赖引入在 build.gradle 中添加如下依赖。 1234567891011121314151617181920212223buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE\") &#125;&#125;apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'repositories &#123; mavenCentral()&#125;sourceCompatibility = 1.8targetCompatibility = 1.8dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-data-mongodb\")&#125; （2）配置 MongoDB 连接这里配置了 MongoDB 的连接地址和使用的数据库，还配置了扫描 Repositories 的位置。Repositories 我们后面会讲到是什么。 123456789101112131415@Configuration@EnableMongoRepositories(basePackages = \"com.example.dao\")public class MongoConfig &#123; @Bean public MongoOperations mongoTemplate() throws UnknownHostException &#123; return new MongoTemplate(mongoDbFactory()); &#125; @Bean public MongoDbFactory mongoDbFactory() throws UnknownHostException &#123; return new SimpleMongoDbFactory(new MongoClientURI(\"mongodb://localhost:27017/test\")); &#125;&#125; （3）定义一个简单的实体类实体类是一个 POJO，不过会多一些注解。简单介绍下这些注解吧： @Document ，用于自定义 MongoDB 中 Collection 的名称，默认情况下 collection 值为空，使用类名的小写形式作为 Collection 的名称； @Id ，用于指定 MongoDB 内部使用字段 _id 的值，如果不指定，则使用自动生成的值。 @Field ，用于指定字段存储时的名称，如果不指定，则直接使用字段名。如果字段名为id，那么一定要使用该注解，否则会读取时使用系统的_id作为 id 的值。 @Indexed，用于为指定字段添加索引，会调用 MongoDB 的 createIndex 方法。值得注意的是：必须 @Document 注解，否则不会自动生成索引。 12345678910111213141516171819@Document(collection = \"Customer\")public class Customer &#123; @Id public String id; @Indexed @Field(\"first_name\") public String firstName; @Field(\"last_name\") public String lastName; public Customer() &#123;&#125; public Customer(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; （4）定义一个 RepositoryMongoRepository 中定义的基本的 CRUD 操作，你可以自定义查询方法，不过要遵守一定的规范，Spring Data MongoDB 会根据方法名和参数去执行数据库操作。这个规范参见下文 支持的查询方法关键字列表。此处只需要了解有 findByXx 的方法名即可。 12345public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123; public Customer findByFirstName(String firstName); public List&lt;Customer&gt; findByLastName(String lastName);&#125; （5）让 Spring Boot 自动装配 CustomerRepository123456789101112131415161718192021222324@SpringBootApplicationpublic class Application implements CommandLineRunner &#123; @Autowired private CustomerRepository repository; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Override public void run(String... args) throws Exception &#123; repository.deleteAll(); // save a couple of customers repository.save(new Customer(\"Alice\", \"Smith\")); repository.save(new Customer(\"Bob\", \"Smith\")); System.out.println(\"-------------------------------\"); // fetch an individual customer System.out.println(repository.findByFirstName(\"Alice\")); &#125;&#125; （6）使用 MongoDB 命令行查询123$ mongo&gt; use test&gt; db.Customer.find(&#123;&#125;) 深入探讨常用的匹配注解列表 Annotation Desc @Id 用于指定 MongoDB 内部使用字段 _id 的值，如果不指定，则使用自动生成的值。 @Field 用于指定数据库中存储的字段名。 @Document 用于指定该类的实例对应 MongoDB 的某个指定 Collection 下的 Document。 @Indexed 用于为指定字段添加索引。@Indexed(unique = true) 可注解唯一键 @CompoundIndex 用于指定复合索引。 @Transient 用于将某些字段排除，不与数据库匹配。 @Version 用于指定字段的版本，默认值为 0，在每次更新字段后自增。 复合索引用例： 12345678@Document@CompoundIndexes(&#123; // lastName 升序，age 降序的复合索引，名称为 age_idx。 @CompoundIndex(name = \"age_idx\", def = \"&#123;'lastName': 1, 'age': -1&#125;\")&#125;)public class Person&lt;T extends Address&gt; &#123; //...&#125; 支持的查询方法关键字列表 Keyword Sample Logical result After findByBirthdateAfter(Date date) {&quot;birthdate&quot; : {&quot;$gt&quot; : date}} GreaterThan findByAgeGreaterThan(int age) {&quot;age&quot; : {&quot;$gt&quot; : age}} GreaterThanEqual findByAgeGreaterThanEqual(int age) {&quot;age&quot; : {&quot;$gte&quot; : age}} Before findByBirthdateBefore(Date date) {&quot;birthdate&quot; : {&quot;$lt&quot; : date}} LessThan findByAgeLessThan(int age) {&quot;age&quot; : {&quot;$lt&quot; : age}} LessThanEqual findByAgeLessThanEqual(int age) {&quot;age&quot; : {&quot;$lte&quot; : age}} Between findByAgeBetween(int from, int to) {&quot;age&quot; : {&quot;$gt&quot; : from, &quot;$lt&quot; : to}} In findByAgeIn(Collection ages) {&quot;age&quot; : {&quot;$in&quot; : [ages…]}} NotIn findByAgeNotIn(Collection ages) {&quot;age&quot; : {&quot;$nin&quot; : [ages…]}} IsNotNull, NotNull findByFirstnameNotNull() {&quot;firstname&quot; : {&quot;$ne&quot; : null}} IsNull, Null findByFirstnameNull() {&quot;firstname&quot; : null} Like, StartingWith, EndingWith findByFirstnameLike(String name) {&quot;firstname&quot; : name} (name as regex) NotLike, IsNotLike findByFirstnameNotLike(String name) {&quot;firstname&quot; : { &quot;$not&quot; : name }} (name as regex) Containing on String findByFirstnameContaining(String name) {&quot;firstname&quot; : name} (name as regex) NotContaining on String findByFirstnameNotContaining(String name) {&quot;firstname&quot; : { &quot;$not&quot; : name}} (name as regex) Containing on Collection findByAddressesContaining(Address address) {&quot;addresses&quot; : { &quot;$in&quot; : address}} NotContaining on Collection findByAddressesNotContaining(Address address) {&quot;addresses&quot; : { &quot;$not&quot; : { &quot;$in&quot; : address}}} Regex findByFirstnameRegex(String firstname) {&quot;firstname&quot; : {&quot;$regex&quot; : firstname }} (No keyword) findByFirstname(String name) {&quot;firstname&quot; : name} Not findByFirstnameNot(String name) {&quot;firstname&quot; : {&quot;$ne&quot; : name}} Near findByLocationNear(Point point) {&quot;location&quot; : {&quot;$near&quot; : [x,y]}} Near findByLocationNear(Point point, Distance max) {&quot;location&quot; : {&quot;$near&quot; : [x,y], &quot;$maxDistance&quot; : max}} Near findByLocationNear(Point point, Distance min, Distance max) {&quot;location&quot; : {&quot;$near&quot; : [x,y], &quot;$minDistance&quot; : min, &quot;$maxDistance&quot; : max}} Within findByLocationWithin(Circle circle) {&quot;location&quot; : {&quot;$geoWithin&quot; : {&quot;$center&quot; : [ [x, y], distance]}}} Within findByLocationWithin(Box box) {&quot;location&quot; : {&quot;$geoWithin&quot; : {&quot;$box&quot; : [ [x1, y1], x2, y2]}}} IsTrue, True findByActiveIsTrue() {&quot;active&quot; : true} IsFalse, False findByActiveIsFalse() {&quot;active&quot; : false} Exists findByLocationExists(boolean exists) {&quot;location&quot; : {&quot;$exists&quot; : exists }} Tip：将以上的 findBy 替换成 deleteBy 含义就变成了：查找后进行删除操作。 下面是一个使用示例：查询指定状态集合的 JobFlow。 12345// 方式一：使用 SqEL(Spring 表达式)@Query(\"&#123; 'status': &#123; $in: ?0 &#125; &#125;\")List&lt;JobFlow&gt; findByStatus(String... status);// 方式二：使用 InList&lt;JobFlow&gt; findByStatusIn(List&lt;String&gt; statusList); save 的原理1234567891011121314151617181920212223242526272829303132333435363738// SimpleMongoRepository.javapublic &lt;S extends T&gt; S save(S entity) &#123; Assert.notNull(entity, \"Entity must not be null!\"); if (entityInformation.isNew(entity)) &#123; mongoOperations.insert(entity, entityInformation.getCollectionName()); &#125; else &#123; mongoOperations.save(entity, entityInformation.getCollectionName()); &#125; return entity;&#125;public &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; entities) &#123; Assert.notNull(entities, \"The given Iterable of entities not be null!\"); List&lt;S&gt; result = convertIterableToList(entities); boolean allNew = true; for (S entity : entities) &#123; if (allNew &amp;&amp; !entityInformation.isNew(entity)) &#123; allNew = false; &#125; &#125; if (allNew) &#123; mongoOperations.insertAll(result); &#125; else &#123; for (S entity : result) &#123; save(entity); &#125; &#125; return result;&#125; 12345678910111213141516// AbstractEntityInformation.javapublic boolean isNew(T entity) &#123; ID id = getId(entity); Class&lt;ID&gt; idType = getIdType(); if (!idType.isPrimitive()) &#123; return id == null; &#125; if (id instanceof Number) &#123; return ((Number) id).longValue() == 0L; &#125; throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s!\", idType));&#125; 参考 Spring Data MongoDB - Reference Documentation - spring.io Accessing Data with MongoDB - spring.io Working with Spring Data Repositories - spring.io","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://linlshare.github.io/tags/MongoDB/"}]},{"title":"澳門編年史 - 二十世紀(1900-1949)","slug":"history/澳門編年史 - 二十世紀(1900-1949) ","date":"2018-12-04T15:21:55.000Z","updated":"2019-01-13T11:37:46.360Z","comments":true,"path":"2018/12/04/history/澳門編年史 - 二十世紀(1900-1949) /","link":"","permalink":"https://linlshare.github.io/2018/12/04/history/澳門編年史 - 二十世紀(1900-1949) /","excerpt":"","text":"KEY VALUE 作者/編者 施白蒂著、金國平譯 出版日期 01/04/1999 頁數 368 在線閱讀 1900～1901年 在義和拳起義期間，當時有“老佛爺”之稱的慈禧太后一露 猙獰面目。她運用手腕，再次出掌大權，充當反對革新精神、洋人的急先鋒。爲此，她煽動民衆助其一臂之力。她 勒令各省成立團練，其中存在大量本來在中華大地叢生 的秘密社團。最著名的爲義和拳。外人稱之爲Boxer，因 爲其徒眾常在集市上耍拳買藝。中國上下掀起了一場驅 逐洋人的如聖戰般的群眾運動。慈禧太后欲將外人斬盡 殺絕，爲此她懸賞割取在京洋人的首級。外人退集東交民巷，以眞絲做土袋，壘築工事。在中華大地逐殺歐洲人的 血雨腥風中，他們渡過了難以言狀的痛苦。正當糧盡彈絕之際，獲聯軍援救。聯軍失去了軍紀，闖入京城，不分靑紅 皂白一通燒殺劫掠，許多價値連城的宮殿化爲灰燼。慈禧 太后扮作民女出逃熱河。中國忍辱賠償6750萬英鎊。賠 款利息以海關收入作爲抵押。但美國將其應得部份用來 以新的敎育方式培養中國靑年。因此，不具備漢唐和睦精 神、遠大目光的滿淸，在出現嚴重的外來危險時，不知所 措，將國家帶入內戰與無政府的狀況。在義和拳運動中，5 位主敎遇難，40名傳敎上（12名屬天主教，餘爲新敎敎士） 及18000敎徒（其中包括53個兒童）喪生。 慈禧無才無德，坐上了大位，只會瞎搞，挑動暴民，引火自焚。聯軍也並非文明之師，火燒圓明園之恥永記！ 1945年（8月6日）長崎這一葡萄牙人建立的城市遭受原子彈襲 擊。 維基百科：長崎的歷史開始於1570年（元龜元年）吉利支丹大名大村純忠將長崎浦開放給葡萄牙人作為貿易港。所以這裡說長崎是葡萄牙人建立的城市。 1945 （9月2日）於停泊於東京灣中的“密蘇里”航空母艦上簽 署日本正式投降書。第二次世界大戰結束。不包括死於 大屠殺的5百萬猶太人在內，該戰爭共造成5千5百萬人死亡，其中3千萬爲平民。 希望和平，因為戰爭中死傷最多的永遠都是平民。 1945年（12月4日）經過4個月的追剿後，活動於澳門、香港及二 地之間島嶼的最後海盜之一王孔祺（音譯：Wong Kong Kit）被捕並被處以極刑。此人非戰爭罪犯，而是一殺人魔 王、十足的舊式海盜。 文明國家不允許海盜存在，但罪惡仍在滋生，只是換了一種身份而已。 1948年（1月30日）甘地（Mohadas Gandhi）遇刺 （參見1915年 條），這一偉人的消失在全世界引起反響。 默哀。 1949年（10月1日）在毛澤東取得戰勝蔣介石（在美國的援助下 撤退臺灣）的國民黨的勝利後，成立中華人民共和國。中 國共產黨的歷史領袖毛澤東在北京天安門廣場宣告中華 人民共和國的誕生。新中國政府成立時，身兼外交部部長 的周恩來總理明確宣佈中國政府願在平等、互相尊重的基 礎上與所有國家（臺北除外）政府建立外交關係。共產黨 掌權。文化革命開始（譯注：原文如此）。柵欄墓地被宣佈 爲文物保護單位。 中國終於結束了內戰，但另一場革命又即將來襲。 柵欄墓地，即是滕公柵欄，位於北京市西城區車公莊大街6號中共北京市委黨校（北京行政學院）院內，是明朝至中華民國時期的天主教墓地，安葬了許多來華西方天主教傳教士及其他天主教教士、教民。現僅存利瑪竇墓等一小部分。 1949年 在此之前，中國擁有21個少數民族。40年後昇至55個。 其中僅有回族和滿族使用漢語。50% 少數民族聚居雲南 （參見《中國少數民族服飾展》目錄，市政廳—賈梅士博物 館，澳門1988年）。根據最新人口普查，漢族佔絕大多數 （10億4千2百萬），而55個少數民族總數爲9千1百20 萬（8%）（參見安東尼奧•卡爾莫，前引書）。澳門包括在此 數字之內。鑒於社會、文化及宗敎影響範圍從未受到國界 的限制，澳門爲在此交匯融合的各種思潮的自然延伸，有 必要在本編年史中對上述數字加以引用。 少數民族的確定有利於民族政策的制定和實施。50%的少數民族聚居雲南這點令人吃驚，這個比例是應該是民族個數佔比而不是種族人數佔比。 1949年 荷蘭承認印度尼西亞獨立。蘇加諾總統於1955年提議召 開萬隆會議。23個亞洲國家及6個非洲國家應邀出席， 仍在歐洲統治下的地區亦有代表參加。它的主題是“讓我 們迎接一個新亞洲及一個新非洲的誕生”，要求結束歐洲 人最後的帝國。荷蘭人撤離印度尼西亞。 原來印尼是1949年萬隆會議后獨立的。","categories":[{"name":"history","slug":"history","permalink":"https://linlshare.github.io/categories/history/"}],"tags":[{"name":"History","slug":"History","permalink":"https://linlshare.github.io/tags/History/"},{"name":"澳門","slug":"澳門","permalink":"https://linlshare.github.io/tags/澳門/"}]},{"title":"Alfred","slug":"it/tool/Alfred","date":"2018-12-04T12:17:22.000Z","updated":"2019-01-13T11:37:46.472Z","comments":true,"path":"2018/12/04/it/tool/Alfred/","link":"","permalink":"https://linlshare.github.io/2018/12/04/it/tool/Alfred/","excerpt":"","text":"实用的 Alfred Workflow Alfred Workflow 介绍 alfred-pkgman-workflow 快速从各个软件仓库(maven, gradle 等等)中查找需要的软件包 AlfredHanziSourceWorkflow 快速从象形字典、汉语字典、说文解字等站点查询字源 AlfredGoogleTranslateWorkflow 快速进行多语言翻译 jetbrains-alfred-workflow 快速打开 JetBrains 家族构建的项目，包括 Android Studio、IDEA 等的项目 noogel/Alfred-Workflow 开发工程师常用工具箱，包括查询 IP、时间戳转换和 Base64编码之类的工具 小知识 当 alfred 查询的结果是一个网页链接时，点击右边的 Shift 键可以启动快速预览而不用打开网页。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Alfred","slug":"Alfred","permalink":"https://linlshare.github.io/tags/Alfred/"}]},{"title":"Spring Data JPA","slug":"it/java/persistence/Spring Data JPA","date":"2018-12-04T10:02:06.000Z","updated":"2019-01-13T11:37:46.457Z","comments":true,"path":"2018/12/04/it/java/persistence/Spring Data JPA/","link":"","permalink":"https://linlshare.github.io/2018/12/04/it/java/persistence/Spring Data JPA/","excerpt":"","text":"用途特性 支持自由替换 Hibernate, EclipseLink, OpenJpa。 快速开始依赖引入123456789101112131415161718192021222324buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE\") &#125;&#125;apply plugin: 'java'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile(\"org.springframework.boot:spring-boot-starter-data-jpa\")&#125;","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"https://linlshare.github.io/tags/JPA/"}]},{"title":"JPA","slug":"it/java/persistence/JPA","date":"2018-12-04T07:51:06.000Z","updated":"2019-01-13T11:37:46.454Z","comments":true,"path":"2018/12/04/it/java/persistence/JPA/","link":"","permalink":"https://linlshare.github.io/2018/12/04/it/java/persistence/JPA/","excerpt":"","text":"JPA 是干嘛的？JPA（Java Persistence API，Java 持久化 API），是一组 ORM（Object Relational Mapping，对象关系映射）规范。所谓持久化，包含三层意思： API 本身，定义在 javax.persistence 包下； JPQL（Java Persistence Query Language，Java 持久化查询语言）； 对象与关联表之间的元数据。 实现 项目 开发公司 数据库支持 备注 Hibernate RedHat SQL JPA 制定的参考。 Spring Data JPA Pivotal SQL 支持 RESTful API 查询，支持 CRUD EclipseLink Eclipse Foundation SQL 及NoSQL 基于 TopLink OpenJPA Apache SQL 支持缓存。 * 2001年，澳大利亚墨尔本一位名为Gavin King的27岁的程序员，上街买了一本SQL编程的书，他厌倦了实体bean，认为自己可以开发出一个匹配对象关系映射理论，并且真正好用的Java持久化层框架，因此他需要先学习一下SQL。这一年的11月，Hibernate的第一个版本发布了。 * Pivotal 和 VMware 都是 EMC 的子公司，2015 年 Dell 以 670 亿美元收购 EMC。 * MyBatis 是一套持久化框架，但不是 ORM 的，而且 Java 方法与 SQL 语句的关联。 * OpenJPA 至今已有 4933 次 commit，更新也很频繁，但其 Github 上的 star 却只有 56，坚持不懈的精神令人肃然起敬。 参考 Java 持久化 API - 维基百科","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"https://linlshare.github.io/tags/JPA/"}]},{"title":"MyBatis","slug":"it/java/persistence/MyBatis","date":"2018-12-04T07:51:06.000Z","updated":"2019-01-13T11:37:46.455Z","comments":true,"path":"2018/12/04/it/java/persistence/MyBatis/","link":"","permalink":"https://linlshare.github.io/2018/12/04/it/java/persistence/MyBatis/","excerpt":"","text":"MyBatis 是干嘛的？MyBatis 是一个 SQL 映射框架，它通过 XML 描述符或者注解将对象与关系型数据库的存储过程或 SQL 语句关联起来。 特性缓存 支持声明式数据缓存； 提供基于 HashMap 的默认缓存实现； 提供 API 供其他缓存实现。 使用单独使用1compile 'org.mybatis:mybatis:3.4.6' 如使用其他依赖引入方式，参看 mybatis - maven.org。 集成使用 与 Spring Framework 集成 与 Google Guice 集成 参考 MyBatis - 维基百科 mybatis-3 - mybatis.org","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://linlshare.github.io/tags/MyBatis/"}]},{"title":"JDBC","slug":"it/java/persistence/JDBC","date":"2018-12-04T07:51:06.000Z","updated":"2019-01-13T11:37:46.453Z","comments":true,"path":"2018/12/04/it/java/persistence/JDBC/","link":"","permalink":"https://linlshare.github.io/2018/12/04/it/java/persistence/JDBC/","excerpt":"","text":"JDBC 是干什么的？是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC 是面向关系型数据库的。 JPA 与 JDBC 的异同？（1）相同点 都是面向关系型数据库的； 都具备查询保存数据的能力。 （2）不同点 JPA 是 Java 持久化 API 的规范，关注将数据库中的表与实体类做映射； JDBC 是 Java 数据库访问的接口，将数据访问与具体的关系型数据库分离，使用驱动完成具体的数据操作。 参看 JPA or JDBC, how are they different? - stackoverfow 参考 Java 数据库连接 - 维基百科","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://linlshare.github.io/tags/JDBC/"}]},{"title":"Groovy","slug":"it/tool/Groovy","date":"2018-12-03T03:09:17.000Z","updated":"2019-01-13T11:37:46.481Z","comments":true,"path":"2018/12/03/it/tool/Groovy/","link":"","permalink":"https://linlshare.github.io/2018/12/03/it/tool/Groovy/","excerpt":"","text":"Q&amp;AGradle 中的 ext 究竟是什么？gradle 中我们使用 ext 定义额外的各种属性，可是 ext 究竟是什么呢？ 参看 ExtraPropertiesExtension - Gradle DSL，发现 ext 不是 Groovy 固有的定义，而是领域特定的语言（DSL）。使用方式是： 123456789// 以下的 project 常常被省略project.ext &#123; foo = \"bar\" &#125;assert project.ext.get(\"foo\") == \"bar\"assert project.ext.foo == \"bar\"assert project.ext[\"foo\"] == \"bar\"assert project.foo == \"bar\"assert project[\"foo\"] == \"bar\" ext 实质上是一个内置的简单对象，但可以动态添加新属性，这个对象叫 ExtraPropertiesExtension，它内置在所有 ExtensionAware 中，ExtenstionAware 的已知子类有 Project、Settings、Task 、SourceSet，所以在这些类中可以直接使用所谓的 namespace method 动态新增新属性。 1234567891011121314151617181920212223// Extensions are just plain objects, there is no interface/typeclass MyExtension &#123; String foo MyExtension(String foo) &#123; this.foo = foo &#125;&#125;// Add new extensions via the extension containerproject.extensions.create('custom', MyExtension, \"bar\")// («name», «type», «constructor args», …)// extensions appear as properties on the target object by the given nameassert project.custom instanceof MyExtensionassert project.custom.foo == \"bar\"// also via a namespace methodproject.custom &#123; assert foo == \"bar\" foo = \"other\"&#125;assert project.custom.foo == \"other\" Gradle 依赖排除12345678dependencies &#123; compile('com.zhyea:ar4j:1.0') &#123; //excluding a particular transitive dependency: exclude module: 'cglib' //by artifact name exclude group: 'org.jmock' //by group exclude group: 'org.unwanted', module: 'iAmBuggy' //by both name and group &#125;&#125; 参考 Gradle 依赖排除","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Groovy","slug":"Groovy","permalink":"https://linlshare.github.io/tags/Groovy/"}]},{"title":"CompletableFuture","slug":"it/java/schedule/CompletableFuture","date":"2018-12-03T02:49:29.000Z","updated":"2019-01-13T11:37:46.459Z","comments":true,"path":"2018/12/03/it/java/schedule/CompletableFuture/","link":"","permalink":"https://linlshare.github.io/2018/12/03/it/java/schedule/CompletableFuture/","excerpt":"","text":"","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"schedule","slug":"it/java/schedule","permalink":"https://linlshare.github.io/categories/it/java/schedule/"}],"tags":[{"name":"CompletableFuture","slug":"CompletableFuture","permalink":"https://linlshare.github.io/tags/CompletableFuture/"}]},{"title":"Quartz","slug":"it/java/schedule/Quartz","date":"2018-12-03T02:49:29.000Z","updated":"2019-01-13T11:37:46.460Z","comments":true,"path":"2018/12/03/it/java/schedule/Quartz/","link":"","permalink":"https://linlshare.github.io/2018/12/03/it/java/schedule/Quartz/","excerpt":"","text":"Quartz 是什么？Quartz 是一款 Java 平台上开源的任务调度器。 快速开始（1）引入依赖12compile \"org.quartz-scheduler:quartz:2.3.0\"compile \"org.quartz-scheduler:quartz-jobs:2.3.0\" （2）初始化12345// 从工厂中获取 Scheduler 对象Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();// 启动scheduler.start(); （3）新建一个 Job1234567public class TestJob implements Job&#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.err.println(\"Hello World! TestJob is executing.\"); &#125;&#125; （4）调度一个 Job12345678910// 添加 Job 的携带数据JobDetail job = newJob(TestJob.class).withIdentity(\"job1\", \"group1\").build();// 新建一个触发器Trigger trigger = newTrigger().withIdentity(\"trigger1\", \"group1\") .startNow() .withSchedule(simpleSchedule().withIntervalInSeconds(5) .repeatForever()) .build();// 开始调度scheduler.scheduleJob(job, trigger); CronTriggerQuartz 的 Cron 表达式不同于 Linux 系统上使用的 Cron 表达式。区别如下： 1234# Linuxminute hour day month week# Quartzsecond minute hour day month week year(optional field) 是的，Quartz 扩充了 second 和 year，这是要特别注意的。 关于 Quartz Cron 表达式每个字段的取值，整理如下： second：[0, 59]。 minute： [0, 59]。 hour：[0, 23]。 day：一个月中的第几天，取值 [1, 31]，注意不同月份有不同的上限值。 month：[0, 11]，注意这跟 Linux 的有差异。还可取 [JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC] week：星期几，取值 [1, 7]，其中 1 代表星期日。还可取 [SUN, MON, TUE, WED, THU, FRI, SAT] 字段中使用的特殊字符跟 Linux 无异，如下： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 参考 quartz-2.2.x/quick-start Lesson 6: CronTrigger - Quartz Tutorials 每天一个linux命令（50）：crontab命令","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"schedule","slug":"it/java/schedule","permalink":"https://linlshare.github.io/categories/it/java/schedule/"}],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"https://linlshare.github.io/tags/Quartz/"}]},{"title":"ZooKeeper","slug":"it/java/base/ZooKeeper","date":"2018-11-29T04:10:22.000Z","updated":"2019-01-13T11:37:46.448Z","comments":true,"path":"2018/11/29/it/java/base/ZooKeeper/","link":"","permalink":"https://linlshare.github.io/2018/11/29/it/java/base/ZooKeeper/","excerpt":"","text":"","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://linlshare.github.io/tags/ZooKeeper/"}]},{"title":"服务发现","slug":"it/concept/服务发现","date":"2018-11-28T14:29:25.000Z","updated":"2019-01-13T11:37:46.374Z","comments":true,"path":"2018/11/28/it/concept/服务发现/","link":"","permalink":"https://linlshare.github.io/2018/11/28/it/concept/服务发现/","excerpt":"","text":"什么是服务发现？服务发现，Service Discovery，是一项提供服务发布和查找的服务，其实质就是键值存储，通过键（Key，在当前语境应是服务名）找到值（Value，在当前语境是服务）。DNS 就是一个简单的例子，人们或其他服务使用域名向 DNS 请求 IP 地址，Key 就是域名，Value 就是 IP 地址。 服务发现是支持大规模 SOA（service-oriented architecture）的核心服务，需具备以下关键特性： 注册（Registration），新增服务到服务列表； 目录（Directory），即服务列表； 查找（Lookup），通过服务名找到服务。 服务元数据（metadata，包括服务的 IP、端口、提供的服务等等信息）存储是服务发现的关键。 服务发现还需提供查询所有服务的部署状态和集中控制所有服务实例的方式。 服务发现解决方案 解决方案 特性 发起人 Redis 用 Redis 作为服务中介是最简单的，但不适用于分布式系统，不具备下面的解决方案的优点 无 ZooKeeper 提供了包括配置管理、领导人选举和分布式锁在内的完整解决方案 Apache etcd 与 ZooKeeper 具有相似的架构和功能 CoreOS doozerd 与 ZooKeeper 具有相似的架构和功能 Blake Mizerany &amp; Keith Rarick Consul 提供了 DNS 和 HTTP 两种 API Hashicorp Eureka 在出现网络分区时， Eureka 选择可用性，而不是一致性，适合 AP( Availability and Partition ) 系统。 Netflix 参考 六个问题带你了解服务发现 - dockone.io Service Discovery: 6 questions to 4 experts - highops.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"concept","slug":"it/concept","permalink":"https://linlshare.github.io/categories/it/concept/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"服务发现","slug":"服务发现","permalink":"https://linlshare.github.io/tags/服务发现/"}]},{"title":"分布式与集群","slug":"it/concept/分布式与集群","date":"2018-11-28T14:09:37.000Z","updated":"2019-01-13T11:37:46.373Z","comments":true,"path":"2018/11/28/it/concept/分布式与集群/","link":"","permalink":"https://linlshare.github.io/2018/11/28/it/concept/分布式与集群/","excerpt":"","text":"分布式与集群的区别（Distributed vs Cluster） 分布式：一个业务分拆多个子业务，部署在不同的服务器上。 集群：同一个业务，部署在多个服务器上。 — 分布式与集群的区别是什么？ - 知乎用户的回答 - 知乎","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"concept","slug":"it/concept","permalink":"https://linlshare.github.io/categories/it/concept/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"分布式","slug":"分布式","permalink":"https://linlshare.github.io/tags/分布式/"},{"name":"集群","slug":"集群","permalink":"https://linlshare.github.io/tags/集群/"}]},{"title":"Logback","slug":"it/java/base/Logback","date":"2018-11-28T06:35:54.000Z","updated":"2019-01-13T11:37:46.436Z","comments":true,"path":"2018/11/28/it/java/base/Logback/","link":"","permalink":"https://linlshare.github.io/2018/11/28/it/java/base/Logback/","excerpt":"","text":"Logback 是什么？Logback 是一个 Java 平台上的日志框架，是 log4j 的加强版本，目前分为以下模块： logback-core，放置为下面两个模块服务的基础代码； logback-classic，log4j 的加强版本，实现了 SLF4J API，以便于切换其他日志框架； logback-access，与 Servlet 容器集成，提供 HTTP 访问日志功能。 SLF4J：The Simple Logging Facade for Java（简单日志门面抽象框架），提供的是日志的 Facade API，需要配合 Log4j、Logback 或 java.util.logging 使用。 快速开始（1）引入依赖 123compile \"org.slf4j:slf4j-api:1.7.+\"compile \"ch.qos.logback:logback-core:1.2.+\"compile \"ch.qos.logback:logback-classic:1.2.+\" （2）编写 logback.xml 并放置到 resources 文件夹中 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; （3）在代码中使用 12Logger LOGGER = LoggerFactory.getLogger(Main.class);LOGGER.debug(\"Hello, Logback\"); 参考 Logback Project - logback.qos.ch LogBack 入门实践","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Logback","slug":"Logback","permalink":"https://linlshare.github.io/tags/Logback/"}]},{"title":"zsh","slug":"it/tool/zsh","date":"2018-11-28T03:55:54.000Z","updated":"2019-01-13T11:37:46.487Z","comments":true,"path":"2018/11/28/it/tool/zsh/","link":"","permalink":"https://linlshare.github.io/2018/11/28/it/tool/zsh/","excerpt":"","text":"禁止粘贴命令时自动对特殊字符进行转义（1）编辑 misc.zsh 文件 1vim ~/.oh-my-zsh/lib/misc.zsh （2）注释掉 url-quote-magic 12345678910111213#if [[ $ZSH_VERSION != 5.1.1 ]]; then# for d in $fpath; do# if [[ -e &quot;$d/url-quote-magic&quot; ]]; then# if is-at-least 5.1; then# autoload -Uz bracketed-paste-magic# zle -N bracketed-paste bracketed-paste-magic# fi# autoload -Uz url-quote-magic# zle -N self-insert url-quote-magic# break# fi# done#fi","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"https://linlshare.github.io/tags/zsh/"}]},{"title":"Docker","slug":"it/tool/Docker","date":"2018-11-27T09:47:54.000Z","updated":"2019-01-13T11:37:46.474Z","comments":true,"path":"2018/11/27/it/tool/Docker/","link":"","permalink":"https://linlshare.github.io/2018/11/27/it/tool/Docker/","excerpt":"","text":"Docker 是什么？Docker 是一种虚拟化的容器，隔离了文件系统、网络互联和进程等等，但比之传统的虚拟化技术，精简了内核和硬件的虚拟，容器内的应用进程直接运行在宿主内核。 安装macOS（1）Homebrew 安装 1&gt; brew cask install docker （2）下载安装 Docker.dmg 下载 Ubuntu 16+（1）测试环境使用一键自动安装脚本 12&gt; curl -fsSL get.docker.com -o get-docker.sh&gt; sudo sh get-docker.sh --mirror Aliyun （2）按部就班安装 12345678910111213141516171819# 添加使用 HTTPS 传输的软件包以及 CA 证书&gt; sudo apt-get update&gt; sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common # 添加软件源的 GPG 密钥&gt; curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 向 source.list 中添加 Docker 软件源&gt; sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\"# 安装 docker-ce&gt; sudo apt-get update&gt; sudo apt-get install docker-ce 检查安装情况123&gt; docker --version&gt; docker-compose --version&gt; docker-machine --version 使用镜像加速器鉴于国内的网络情况，拉取镜像会很慢，这时候需要配置镜像加速器，使用国内的镜像服务器。 国内的镜像服务器地址： https://registry.docker-cn.com。 配置方式：对于使用 Docker 客户端的用户，依次点击 Docker 图标 --&gt; Settings/ Perferences --&gt; Daemon --&gt; Registry mirrors，输入加速器地址，然后点击 Apply &amp; Restart 即可。 检查配置是否生效：执行 docker info 查看 Registry Mirrors 字段的值。 启动和停止Mac跟启动普通软件的方式一样。 Ubuntu 16+12&gt; sudo systemctl enable docker&gt; sudo systemctl start docker 快速开始：启动一个 Nginx 服务器（1）安装并启动一个 Nginx 服务器，将本地的 8080 端口映射到 Docker 的 80 端口。 1&gt; docker run -d -p 8080:80 --name webserver nginx （2）通过 docker ps 查看运行中的 docker 容器列表。 （3） curl http://localhost:8080 。 （4）停止 Nginx 服务器 1&gt; docker stop webserver （4）从 Docker 中删除 Nginx 服务器 1&gt; docker rm webserver 基本概念镜像（Image）虚拟概念，并非一个 ISO 的压缩文件，而是使用 Union FS 分层存储技术存储的多层文件系统联合组成，存放的是 root 文件系统，包括容器运行时所需的程序、库、资源、配置等文件，但不包含动态数据。 容器（Container）容器是镜像运行时的实体，实质就是一个个的 Docker 进程，可以对 Docker 进程进行如下操作： 创建 启动 停止 删除 暂停 容器也采用分层存储，容器运行时，以镜像为基础层，在其上创建一个当前容器的存储层，称之为容器存储层。容器存储层的生命周期与容器同步，故不应向存储层写入任何数据，所有的文件写入操作，都应使用数据卷（Volume）或者绑定宿主目录。 Registry用来集中存储和分发 Docker 镜像的服务，一个 Registry 可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。 常用的 Public Registry 列表： Docker Hub Quay.io Google Container Registry 网易云镜像服务 DaoCloud 镜像市场 阿里云镜像库 时速云镜像仓库 国内针对 Docker Hub 的镜像服务（加速器）有： 阿里云加速器 DaoCloud 加速器 命令镜像相关 命令 功能 docker images 列出所有拉取的镜像 docker inspect [name] 检视镜像的详细信息 docker rmi [REPOSITORY]:[TAG] 删除镜像 docker pull [name] 拉取镜像 容器相关 命令 功能 docker ps -a 列出所有容器及其状态 docker ps 列出所有运行中的容器 docker rm [容器 ID] 删除容器 docker crate -it [镜像标签或镜像 ID] 新建一个容器 docker start [容器 ID] 运行处于终止状态的容器 docker kill [容器 ID] 强制终止容器 docker kill [容器 ID] 停止容器 docker restart [容器 ID] 重启一个容器 docker logs [容器ID] 查看容器日志 更进一步 命令 功能 docker exec -ti [容器ID] /bin/bash 进入具体容器中运行交互命令 docker exec [容器 ID 或容器 name] 具体命令 直接执行具体容器的命令 DockerfileDockerfile 用来定制镜像，是一组指令，描述如何在基础镜像中一步步构建自定义的镜像。下面以修改 nginx 服务器首页为例： （1）新建名为 Dockerfile 的文件，内容如下： 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html （2）使用 docker build 开始构建 1234# 确保在 Dockerfile 所在的目录下执行该命令，# 否则需要使用 `-f [file_name]` 指定 Dockerfile# 使用 `-t [name:tag]` 指定镜像的名称和标签docker build -t nginx:v3 命令解析（1）FROM指定基础镜像。 （2）RUN执行命令行命令，支持 shell 格式和 exec 格式。 注意：Dockerfile 每个指令都会建立一层，Union FS 有最大层数限制。多个命令行指令可以使用 &amp;&amp; 串联。 Docker ComposeDocker Compose 是 Docker 官方的开源项目之一，用来快速地部署分布式应用。官方定位是「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」。衍生概念有： 服务（Service）, 一个 Docker 容器称之为一个服务； 项目（Project），一个 Compose，或者说一组相关联的服务，称之为一个项目 。 安装Docker Compose 在 Docker 客户端中已经包含，可以直接使用。 12# 检查是否可用docker-compose --version 快速开始（1）使用 Dockerfile 定义应用的环境； （2）使用 docker-compose.yml 定义组成应用的各项服务； （2）执行 docker-compose up 进行部署。 排错Error: Cannot Start Container: stat /bin/sh: no such file or directory”（1）使用 docker inspect 检视镜像的 Cmd 选项； （2）如果 Cmd 中不包含 /bin/sh 那意味着可能被你重写了。 permission denied while trying to connect to the Docker daemon socket（1）默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 1&gt; sudo usermod -aG docker $USER 接着重启 docker，并新开一个会话连接。 （2）如果还是不行，那么只好使用 sudo 运行 docker 命令了。 参考 Docker – 从入门到实践（绝佳的入门文档） docker-library/docs - Github （docker 官方镜像的使用文档）","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linlshare.github.io/tags/Docker/"}]},{"title":"etcd","slug":"it/java/base/etcd","date":"2018-11-27T06:17:35.000Z","updated":"2019-01-21T03:59:07.999Z","comments":true,"path":"2018/11/27/it/java/base/etcd/","link":"","permalink":"https://linlshare.github.io/2018/11/27/it/java/base/etcd/","excerpt":"","text":"etcd 是什么？（What is etcd）etcd 是一个一致的分布式可靠的键值存储技术。可被用来做配置共享和服务发现。 开发语言：Go 共识算法：Raft 命名来源：表示分布式的 etc 目录，发音为/ˈɛtsiːdiː/。 使用的端口：2.0 后，使用 2379 作为外部客户端通信，使用 2380 作为内部服务间通信。 发起团队：CoreOS 安装Mac 安装12345# 安装brew install etcd# 验证安装etcd -versionetcdctl -version Docker 安装参考 Running etcd under Docker - CoreOS 及 docker_practice/etcd/install ： 1234567891011121314151617181920# 使用 host IPexport ETCD_NODE1=127.0.0.1# 安装 etcddocker run --name etcd \\ -p 2379:2379 \\ -p 2380:2380 \\ --volume=etcd-data:/etcd-data \\ quay.io/coreos/etcd:latest \\ /usr/local/bin/etcd \\ --data-dir=/etcd-data --name node1 \\ --initial-advertise-peer-urls http://$&#123;ETCD_NODE1&#125;:2380 --listen-peer-urls http://0.0.0.0:2380 \\ --advertise-client-urls http://$&#123;ETCD_NODE1&#125;:2379 --listen-client-urls http://0.0.0.0:2379 \\ --initial-cluster node1=http://$&#123;ETCD_NODE1&#125;:2380# 进入etcd 命令行交互docker exec -it etcd /bin/sh# 验证安装etcd -versionetcdctl -version# 验证是否启动curl http://127.0.0.1:2379/version Docker Compose 快速部署参考 Docker Compose 的使用说明，编辑 docker-compose.yml 文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112version: \"3.6\"services: node1: image: quay.io/coreos/etcd volumes: - node1-data:/etcd-data expose: - 2379 - 2380 networks: cluster_net: ipv4_address: 172.16.238.100 environment: - ETCDCTL_API=3 command: - /usr/local/bin/etcd - --data-dir=/etcd-data - --name - node1 - --initial-advertise-peer-urls - http://172.16.238.100:2380 - --listen-peer-urls - http://0.0.0.0:2380 - --advertise-client-urls - http://172.16.238.100:2379 - --listen-client-urls - http://0.0.0.0:2379 - --initial-cluster - node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380 - --initial-cluster-state - new - --initial-cluster-token - docker-etcd node2: image: quay.io/coreos/etcd volumes: - node2-data:/etcd-data networks: cluster_net: ipv4_address: 172.16.238.101 environment: - ETCDCTL_API=3 expose: - 2379 - 2380 command: - /usr/local/bin/etcd - --data-dir=/etcd-data - --name - node2 - --initial-advertise-peer-urls - http://172.16.238.101:2380 - --listen-peer-urls - http://0.0.0.0:2380 - --advertise-client-urls - http://172.16.238.101:2379 - --listen-client-urls - http://0.0.0.0:2379 - --initial-cluster - node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380 - --initial-cluster-state - new - --initial-cluster-token - docker-etcd node3: image: quay.io/coreos/etcd volumes: - node3-data:/etcd-data networks: cluster_net: ipv4_address: 172.16.238.102 environment: - ETCDCTL_API=3 expose: - 2379 - 2380 command: - /usr/local/bin/etcd - --data-dir=/etcd-data - --name - node3 - --initial-advertise-peer-urls - http://172.16.238.102:2380 - --listen-peer-urls - http://0.0.0.0:2380 - --advertise-client-urls - http://172.16.238.102:2379 - --listen-client-urls - http://0.0.0.0:2379 - --initial-cluster - node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380 - --initial-cluster-state - new - --initial-cluster-token - docker-etcdvolumes: node1-data: node2-data: node3-data:networks: cluster_net: driver: bridge ipam: driver: default config: - subnet: 172.16.238.0/24 etcdctl v3（主流） Tip：可以通过 ETCDCTL_API=3 etcdctl -h 查看 v3 版本的命令行帮助页 （1）查看所有键值对12# 指定版本为 v3 且 key 前缀为空，也就是所有 key 了ETCDCTL_API=3 etcdctl get --prefix=true \"\" （2）put1ETCDCTL_API=3 etcdctl put /testdir/testkey \"你好 etcd\" etcdctl v2（兼容） Tip：可以通过 etcdctl -h 查看 v2 版本的命令行帮助页 （1）set设置某个键的值，支持选项： 123--ttl '0' 该键值的超时时间（单位为秒），不配置（默认为 0）则永不超时--swap-with-value value 若该键现在的值是 value，则进行设置操作--swap-with-index '0' 若该键现在的索引值是指定索引，则进行设置操作 示例： 1etcdctl set /testdir/testkey \"Hello etcd\" （2）get获取指定键的值，支持选项： 12--sort 对结果进行排序--consistent 将请求发给主节点，保证获取内容的一致性 示例： 1etcdctl get /testdir/testkey （3）update更新某个键的值，支持选项： 1--ttl '0' 该键值的超时时间（单位为秒），不配置（默认为 0）则永不超时 示例： 1etcdctl update /testdir/testkey \"你好 etcd\" （4）rm删除某个键，支持选项： 1234--dir 删除空目录或键值对--recursive, -r 删除当前键及其子键(当为目录时)--with-value 当值匹配时删除--with-index '0' 当索引匹配时删除 示例： 1etcdctl rm /testdir/testkey --with-value \"Hello etcd\" （5）ls列出目录（默认为根目录 /）下的键和子目录，默认不显示子目录中内容。支持选项： 123--sort 将输出结果排序--recursive 如果目录下有子目录，则递归输出其中的内容-p 对于输出为目录，在最后添加 / 进行区分 示例： 1etcdctl ls -r -p 集群操作使用 member 命令进行 etcd 实例与集群的操作： list 列出 etcd 集群中的所有实例 add 添加 etcd 实例到集群中 remove 从集群中删除 etcd 实例 update 更新集群中的 etcd 实例 示例： 1234# v2etcdctl member list# v3ETCDCTL_API=3 etcdctl member list REST API （v2）1234# 查看版本curl http://127.0.0.1:2379/version# getcurl http://127.0.0.1:2379/v2/keys/testdir/testkey REST API （v3alpha）1234567891011121314151617181920HOST=http://ecp-etcd-7fbedb40ccf7b594.elb.us-east-1.amazonaws.com:2379declare -A KV=([\"config/http_server_port\"]=8080 [\"config/db_type\"]=\"dynamo\" [\"config/aws_region\"]=\"us-east-1\" [\"config/kafka_brokers\"]=\"172.19.0.9:9092\")# show versioncurl $HOST/version# put key valuefor k in $&#123;!KV[@]&#125;do key=$(echo -n $k | base64) value=$(echo -n $&#123;KV[$k]&#125; | base64) ## delete key before curl -L $HOST/v3alpha/kv/deleterange -X POST -d \"&#123;\\\"key\\\": \\\"$&#123;key&#125;\\\"&#125;\" ## put new key and value curl -L $HOST/v3alpha/kv/put -X POST -d \"&#123;\\\"key\\\":\\\"$&#123;key&#125;\\\", \\\"value\\\": \\\"$&#123;value&#125;\\\"&#125;\"done# show all keyscurl -L $HOST/v3alpha/kv/range -X POST -d '&#123;\"key\": \"AA==\", \"range_end\": \"AA==\"&#125;'#curl -X POST -d '&#123;\"key\": \"L2FwcA==\", \"range_end\": \"L2I=\"&#125;' $HOST/v3alpha/kv/range 已知问题： 当 put 的 value 中包含字符 “-” 时会抛出 {\\&quot;error\\&quot;:\\&quot;invalid character &#39;\\\\\\\\n&#39; in string literal\\&quot;,\\&quot;code\\&quot;:3}。 参考（Reference） etcd-io/etcd - Github etcd-io/jetcd - Github etcd Documentation etcd 服务注册与发现 初试ETCD - Tony Deng","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"ETCD","slug":"ETCD","permalink":"https://linlshare.github.io/tags/ETCD/"}]},{"title":"设计模式","slug":"it/design/设计模式","date":"2018-11-26T07:45:40.000Z","updated":"2019-01-13T11:37:46.375Z","comments":true,"path":"2018/11/26/it/design/设计模式/","link":"","permalink":"https://linlshare.github.io/2018/11/26/it/design/设计模式/","excerpt":"","text":"策略模式（Strategy Pattern）（1）适用场景当解决问题的方法有多种方式，需要可替换时。 （2）核心使用组合，封装成一个个算法，即是策略。 （3）类图 抽象工厂模式（Abstract Factory Pattern）（1）适用场景 产品有不同的提供商，不同的提供商提供不同品牌和风味的产品； 同一提供商有不同的流水线，不同的流水线生产不同的产品。 （2）核心从创建开始就对产品进行了区分，生而不同。 （3）类图 适配器模式（Adapter Pattern）（1）适用场景将外部服务融合进内部而外部接口与现有服务不兼容（表现在命名、返回值、入参等不同），需要进行适配才能使用时。 （2）核心使用组合或者多继承，包装旧接口到包装类（或称为适配器）中。使用组合的称之为对象适配器，使用多继承的称之为类适配器。 （3）类图 参考（Reference） 图说设计模式 Head First 设计模式","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"design","slug":"it/design","permalink":"https://linlshare.github.io/categories/it/design/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"设计模式","slug":"设计模式","permalink":"https://linlshare.github.io/tags/设计模式/"}]},{"title":"广州生物岛摄影 20181124","slug":"photography/广州生物岛摄影 20181124","date":"2018-11-24T14:00:12.000Z","updated":"2019-01-13T11:37:46.634Z","comments":true,"path":"2018/11/24/photography/广州生物岛摄影 20181124/","link":"","permalink":"https://linlshare.github.io/2018/11/24/photography/广州生物岛摄影 20181124/","excerpt":"","text":"KEY VALUE 地点 广州生物岛（官洲岛） 景点 水墨园、叠翠园、空旷的道路 时间 2018年 11月 24日 上午 气候 阳光明媚，温度 25°C 设备 Sony RX100 Ⅲ 主题 冬天在哪里？ 照片数量 8/99 路（Road）（1）车道-人行道-水墨园生物岛的斑马线是黄白交替的，旁边有如红色地毯的自行车道，另外还有环岛的蓝色自行车道。 PS WHY 增强了饱和度 拍摄时太亮，导致黄色和红色不明显 （2）竹林小道水墨园里有一片竹林，风吹竹曳，可以解暑气。 PS WHY 无 无 （3）生锈的水栓 - 活动的机器人路边看到一锈迹斑斑的水栓，看起来好似一活动的机器人正在分析路况。 PS WHY 增强了亮度 拍摄时逆光了 （4）清道夫的单车装备道路旁边放着一辆上了锁的单车，车篮放着一顶草帽，货架延伸出一个箩筐，放着扫帚之类的清道工具，装备齐全。 PS WHY 无 无 水墨园（Shuimo Park）（1）建设-完工水墨园两边的建筑，一边还在雏形还没建好，一边已经完工了。 PS WHY 一分为二，左边使用黑白+黄色色调处理，右边不做处理 增强建设中和完工的对比 （2）屏风 - 人家水墨园里，接近别墅区的地方有一处做了屏风处理，感觉很是相宜。 PS WHY 无 无 （3）奇怪的建筑水墨园旁边有一处奇怪的建筑，两边伸出像手臂一样的铁疙瘩，主体部分好像损毁的斗兽场，目前还在维护。 PS WHY 无 无 中国海警（Chinese Maritime Police）在水墨园偶然间听到军队嘹亮的歌声，往岛边一望，原来是中国海警舰艇的身影，穿着白色 T 恤，肩上有红蓝条纹，前额很尖。 PS WHY 增强了亮度 拍摄时逆光了","categories":[{"name":"photography","slug":"photography","permalink":"https://linlshare.github.io/categories/photography/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://linlshare.github.io/tags/摄影/"},{"name":"生物岛","slug":"生物岛","permalink":"https://linlshare.github.io/tags/生物岛/"}]},{"title":"Guava Cache","slug":"it/java/cache/Guava Cache","date":"2018-11-23T09:32:02.000Z","updated":"2019-01-13T11:37:46.450Z","comments":true,"path":"2018/11/23/it/java/cache/Guava Cache/","link":"","permalink":"https://linlshare.github.io/2018/11/23/it/java/cache/Guava Cache/","excerpt":"","text":"Guava Cache 是做什么的？内存缓存，类似于 ConcurrentMap，支持自动缓存、缓存回收和缓存移除回调。 两种加载方式使用CacheLoader当有默认的加载或计算方式使用该方式。示例如下： 12345678910111213141516LoadingCache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder() .maximumSize(1000) .expireAfterWrite(10, TimeUnit.MINUTES) .removalListener(MY_LISTENER) .build( new CacheLoader&lt;Key, Value&gt;() &#123; public Value load(Key key) throws Exception &#123; return createExpensiveValue(key); &#125; &#125;);//...try &#123; cache.get(key);&#125; catch (ExecutionException e)&#123; throw new OtherException(e.getCause());&#125; 使用 Callable当没有默认加载运算，或者想要覆盖默认的加载运算，同时保留 “获取缓存 – 如果没有 – 则计算”（get-if-absent-compute）的原子语义时使用该方式。示例如下： 12345678910111213141516171819Cache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder() .expireAfterWrite(1,TimeUnit.MINUTES) .removalListener(this) .build();//...// 1. gettry &#123; cache.get(key, new Callable&lt;Value&gt;() &#123; @Override public Value call() throws AnyException &#123; return doThingsTheHardWay(key); &#125; &#125;);&#125; catch (ExecutionException e) &#123; throw new OtherException(e.getCause());&#125;// 2. getIfPresentcache.getIfPresent(key); 参考 CachesExplained - guava [Google Guava] 3-缓存 - 并发编程网","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"cache","slug":"it/java/cache","permalink":"https://linlshare.github.io/categories/it/java/cache/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"Guava","slug":"Guava","permalink":"https://linlshare.github.io/tags/Guava/"},{"name":"Cache","slug":"Cache","permalink":"https://linlshare.github.io/tags/Cache/"}]},{"title":"Kafka","slug":"it/java/base/Kafka","date":"2018-11-22T09:44:02.000Z","updated":"2019-01-13T11:37:46.435Z","comments":true,"path":"2018/11/22/it/java/base/Kafka/","link":"","permalink":"https://linlshare.github.io/2018/11/22/it/java/base/Kafka/","excerpt":"","text":"概念Kafka 是一个快速、可扩展和高可用的基于发布-订阅模式（pub-sub model）的消息系统，用作消息中间件，在系统之间传递消息。其核心概念有： Topic（话题） Producer（生产者） Consumer（消费者） Broker（经纪人） 在 Kafka 中，所有的消息都由 Topic 来组织，Producer 把消息发送到特定的 Topic，Consumer 从特定的 Topic 中读取消息。作为一个分布式系统，Kafka 运行在集群中，集群中的每个节点称之为 Broker。 快速开始安装下载 kafka_2.11-2.1.0.tgz，也可以使用命令 wget &quot;http://mirrors.hust.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz&quot; 下载，注意 kafka 中已经包含了 zookeeper。执行以下命令解压并切换工作目录： 12tar -xzf kafka_2.11-2.1.0.tgzcd kafka_2.11-2.1.0 启动1234# 启动 zookeeper，默认监听端口 2181bin/zookeeper-server-start.sh config/zookeeper.properties# 启动 kafka，默认监听端口 9092bin/kafka-server-start.sh config/server.properties 停止12345# 停止 zookeeperbin/zookeeper-server-stop.sh config/zookeeper.properties# 停止 kafkaps aux | grep kafka | grep -v grep | awk '&#123;print $2&#125;'kill [pid] 发送消息1bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test 接收消息1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning 查看 Topic 列表1bin/kafka-topics.sh --list --zookeeper localhost:2181 查看指定 Topic 的信息1bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic a_topic 排错KeeperException：NoNode for /config/topics/xxx（1）背景在本机先后启动 Zookeeper 和 Kafka，然后发送 PING 主题。但消费失败，错误日志如下： 1[2018-12-06 16:48:06,120] INFO Got user-level KeeperException when processing sessionid:0x1000a6787410000 type:setData cxid:0xcb zxid:0xc4 txntype:-1 reqpath:n/a Error Path:/config/topics/PONG Error:KeeperErrorCode = NoNode for /config/topics/PING (org.apache.zookeeper.server.PrepRequestProcessor) （2）查看 Zookeeper 终端日志发现 host.name 不是 localhost 而是内网地址。 1[2018-12-06 16:21:18,687] INFO Server environment:host.name=192.168.1.2 (org.apache.zookeeper.server.ZooKeeperServer) （3）修改 config/server.properties 文件参看 Kafka系列2-producer和consumer报错 ，修改如下： 1234// 之前#listeners=PLAINTEXT://:9092// 现在listeners=PLAINTEXT://localhost:9092 （4）重启 Zookeeper 和 KafkaConcurrentModificationException: KafkaConsumer is not safe for multi-threaded access一个线程只能有一个 Consumer，如果多个线程共用一个 Consumer，那么就会出现这个错误。 解决方案就是去解决线程问题，确保只有一个线程调用一个 Consumer。 Kafka 消息不按顺序消费背景：查看消息日志发现原本按顺序发送的消息 1,2,3 被消费的时候变成 1,3,2 了。 原因：Kafka 不保证全局的消息有序性，但保证同一个 Partition 消息的有序性。 解决方案：发消息时设置同一个 Key 或者直接指定同一个 Partition 即可。 参考 Quickstart - kafka.apache.org","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JavaEE","slug":"JavaEE","permalink":"https://linlshare.github.io/tags/JavaEE/"},{"name":"Kafka","slug":"Kafka","permalink":"https://linlshare.github.io/tags/Kafka/"}]},{"title":"NIO","slug":"it/java/base/NIO","date":"2018-11-22T03:27:06.000Z","updated":"2019-01-13T11:37:46.438Z","comments":true,"path":"2018/11/22/it/java/base/NIO/","link":"","permalink":"https://linlshare.github.io/2018/11/22/it/java/base/NIO/","excerpt":"","text":"概念（NIO vs BIO）NIO, Non-blocking I/O, 非阻塞式 I/O 模型。也可以解释为 New I/O, 区别于旧的阻塞式 I/O 模型（BIO）。 BIO 与 NIO 的区别如下： 类别 I/O 方式 最低可用的 JDK 版本 BIO 流式 JDK 1.0 NIO 块式 JDK 1.4 所谓流式处理，就是单个字节的数据移动，通过一个称为 Stream 的对象一次移动一个字节；而块式处理，就是单个字节数组的数据移动，通过一个叫 Buffer 的对象一次移动一个字节数组。JDK 中的 NIO 库已经集成了原来的标准 I/O 功能。 缓冲区和通道（Buffer &amp; Channel）NIO 中的缓冲区（Buffer）实质是一个数组，通常为字节数组（ByteBuffer），用作读写缓冲，以及对数据的结构化访问，还可以用来跟踪系统的读写进程。 Buffer 类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer NIO 中的通道（Channel）类似 BIO 中的流（Stream），但是是双向的，可以用来读、写或者同时读写。流之所以是单向的，是因为一个 Stream 要么是 InputStream，要么是 OutputStream，不能兼有。 缓冲区内部细节（Buffer Internals）状态变量（State Variables） Position，表征读了或写了多少数据到数组中，指向下一个元素的位置； Limit，表征剩余可读或可写的的数据量，初始情况下 Limit = Capacity。 Capacity，表征 Buffer 的最大容量。 三者关系：Position &lt;= Limit &lt;= Capacity 下面从微观角度观察各状态变量在读写操作中的变化： （1） Init 初始状态下，Position 指向第一个元素的位置，Limit 和 Capacity 指向最后一个元素的下一个虚拟元素的位置。由于 Capacity 保持不变，下面的讨论中予以略过。 （2）Channel.read 读取 5 个元素到缓冲区后，Position 指向第六个元素的位置，Limit 不变。 （3）Buffer.flip 进行 Flip 操作后，Limit 指向当前的 Position 的位置，Position 指回第一个元素的位置， （4）Channel.write 从缓冲区读取 5 个元素写入 Channel 后，Position 指向 Limit 所在的位置。 （5）Buffer.clear clear 后缓冲区重置到初始状态。 存取方法（Accessor ）存取方法分为： 相对方法（Relative Method）：在当前 position 进行读写操作，随后 position 自增1。 绝对方法（Absolute Method）：在某个索引位置进行读写操作，不影响 position 和 limit。 （1）get 系列方法（包括 array() )，用于读取缓冲区的数据，其中 byte get(int index) 为绝对方法。 （2）put 系列方法，用于写入数据到缓冲区，其中 ByteBuffer put(int index, byte b) 为绝对方法。 使用（Show U the Code）读取文件 从 FileInputStream 中获取 Channel； 创建 Buffer； 将数据从 Channel 读到 Buffer 中。 示例如下： 123456789// 将 a_file 读到 StringBuilder 中FileInputStream fin = new FileInputStream(\"/path/to/a_file\");FileChannel fc = fin.getChannel();ByteBuffer buffer = ByteBuffer.allocate(1024);StringBuilder sb = new StringBuilder();while (fc.read(buffer) != -1) &#123; sb.append(new String(buffer.array(), 0, buffer.position()));&#125; 写入文件 从 FileOutputStream 中获取 Channel； 创建 Buffer； 写入数据到 Buffer； 将数据从 Buffer 写入 Channel 中。 示例如下： 12345678910111213// 将 \"Something\" 写入 a_file 中FileOutputStream fos = new FileOutputStream(\"/path/to/a_file\");FileChannel fc = fos.getChannel();ByteBuffer buffer = ByteBuffer.allocate(1024);byte[] content = \"Something\".getBytes();for (byte aContent : content) &#123; buffer.put(aContent);&#125;buffer.flip();fc.write(buffer); 边读边写 清除 Buffer； 从输入流的 Channel 读数据到 Buffer； 写入 Buffer 中的数据到输出流的 Channel； 循环直到输入流的 Channel 中没有数据。 示例如下： 1234567891011121314151617FileInputStream fin = new FileInputStream(\"path/to/in_file\");FileOutputStream fout = new FileOutputStream(\"path/to/out_file\");FileChannel fcin = fin.getChannel();FileChannel fcout = fout.getChannel();ByteBuffer buffer = ByteBuffer.allocate(1024);while (true) &#123; buffer.clear(); int r = fcin.read(buffer); if (r == -1) &#123; break; &#125; buffer.flip(); fcout.write(buffer);&#125; 参考 NIO 入门 - IBM Getting started with new I/O (NIO) - IBM","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"NIO","slug":"NIO","permalink":"https://linlshare.github.io/tags/NIO/"}]},{"title":"Netty","slug":"it/java/base/Netty","date":"2018-11-22T03:23:41.000Z","updated":"2019-01-13T11:37:46.443Z","comments":true,"path":"2018/11/22/it/java/base/Netty/","link":"","permalink":"https://linlshare.github.io/2018/11/22/it/java/base/Netty/","excerpt":"","text":"Netty 是干什么的？Netty 是一个 NIO 客户端服务器框架，用于快速开发网络应用。 支持扩展协议。 快速开始（1）引入依赖 1compile \"io.netty:netty-all:4.1.+\"","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Netty","slug":"Netty","permalink":"https://linlshare.github.io/tags/Netty/"}]},{"title":"服务鉴权机制","slug":"it/secure/服务鉴权机制","date":"2018-11-21T09:31:26.000Z","updated":"2019-01-13T11:37:46.470Z","comments":true,"path":"2018/11/21/it/secure/服务鉴权机制/","link":"","permalink":"https://linlshare.github.io/2018/11/21/it/secure/服务鉴权机制/","excerpt":"","text":"Token 验证机制Token 是一个字符串，由服务端生成，用于保证请求的有效性，过滤掉非法的请求。一个 Token 可以由以下三部分组成： Token 字符串（token），可以是 UUID； 生成时的时间戳（timestamp）； 校验因子（sign），由 token + timestamp，通过一定的规则（比如 MD5）生成。 示例（sg = md5(tk+&quot;*&quot;+tm+&quot;*&quot;+&quot;k2@sz8-iA&quot;）： 12345&#123; \"tk\":\"116b6451-6028-4490-8869-d32a84082b7c\", \"tm\":\"1536595200000\", \"sg\":\"91672a6af6d7d078676e2b26e8396ea1\"&#125; 这样，当请求到达客户端时，我们先用先前的规则构造一个 md5 值，看与请求中的 sg 字段值是否相同，再判定 当前的时间戳与 tm 中的时间戳差值是否不超过预定义的过期时长。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"secure","slug":"it/secure","permalink":"https://linlshare.github.io/categories/it/secure/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"Secure","slug":"Secure","permalink":"https://linlshare.github.io/tags/Secure/"}]},{"title":"FSM","slug":"it/code/FSM","date":"2018-11-21T07:37:25.000Z","updated":"2019-01-13T11:37:46.364Z","comments":true,"path":"2018/11/21/it/code/FSM/","link":"","permalink":"https://linlshare.github.io/2018/11/21/it/code/FSM/","excerpt":"","text":"概念FSM, Finite State Machine 有限状态机，是一种数学计算模型，在任意给定的时刻只会存在在给定的有限状态中的一个。FSM 会在特定的外部输入条件下发生从一个状态到另一状态的改变，这个过程叫状态转移（transition）。 一个 FSM 由以下部分构成： 状态表（a list of its states） 初始状态（Initial state） 每个转移的条件（the conditions for each transition） 另外，在自动机理论中，FSM 也叫做 DFA（Deterministic Finite Automaton, 确定性有限自动机），与 NFA（Nondeterministic Finite Automaton, 非确定性有限自动机）相对。DFA 的特点是： 每个状态转移由当前状态和输入唯一确定； 每次状态转移都要读取输入。 描述状态转移表（State Transition Table） 当前状态→ 条件↓ 状态A 状态B 状态C 条件X … … … 条件Y … 状态C … 条件Z … … … 状态转移表描述了当某个状态下触发某个条件会达到什么状态。下面以投币式旋转门为例： 当前状态→ 条件↓ 锁定 解锁 推动旋转杠 锁定 锁定 投币 解锁 解锁 UML 状态机（UML State Machines） 使用 UML 语言在 draw.io 上绘制上述的投币式旋转门的状态图如下： 参考 Finite-state mathine - wikipedia","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"code","slug":"it/code","permalink":"https://linlshare.github.io/categories/it/code/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"FSM","slug":"FSM","permalink":"https://linlshare.github.io/tags/FSM/"}]},{"title":"NAS","slug":"it/concept/NAS","date":"2018-11-21T06:36:20.000Z","updated":"2019-01-13T11:37:46.371Z","comments":true,"path":"2018/11/21/it/concept/NAS/","link":"","permalink":"https://linlshare.github.io/2018/11/21/it/concept/NAS/","excerpt":"","text":"NAS, Network Attached Storage, 网络附属存储, 简单来说就是连接在网络上, 可以存储资料的装置。可以用来做私有网盘，同步各种设备的照片、视频、音频和文件。 常见的 NAS 硬件有： 群晖 / 威联通 惠普 ProLiant MicroServer Acer Altos C100 F3 常见的 NAS 软件有： Nextcloud Owncloud Seefile 群晖 / 威联通系列软件 参考： 搭建家庭 NAS 服务器有什么好方案？ - 知乎","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"concept","slug":"it/concept","permalink":"https://linlshare.github.io/categories/it/concept/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://linlshare.github.io/tags/IT/"},{"name":"NAS","slug":"NAS","permalink":"https://linlshare.github.io/tags/NAS/"}]},{"title":"Markdown","slug":"it/tool/Markdown","date":"2018-11-20T12:41:20.000Z","updated":"2019-01-13T11:37:46.484Z","comments":true,"path":"2018/11/20/it/tool/Markdown/","link":"","permalink":"https://linlshare.github.io/2018/11/20/it/tool/Markdown/","excerpt":"","text":"在表格中输入管道符（|）管道符与表格分隔字段用的相冲突，会导致表格显示不正常，解决方案是：使用 &amp;#124; 代替 | 。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://linlshare.github.io/tags/Markdown/"}]},{"title":"XPath","slug":"it/robot/XPath","date":"2018-11-20T11:38:55.000Z","updated":"2019-01-14T11:18:40.032Z","comments":true,"path":"2018/11/20/it/robot/XPath/","link":"","permalink":"https://linlshare.github.io/2018/11/20/it/robot/XPath/","excerpt":"","text":"何为 XPath（Introduction）维基百科：XPath 即为 XML 路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。 XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。 所谓节点有七种，分别是： 元素（element） 属性（attribute） 文本（text） 命名空间（namespace） 处理指令（processing-instruction） 注释（comment） 文档节点（document node, also called root element） 示例： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;bookstore&gt; &lt;book&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 其中， &lt;bookstore&gt; 为根节点，或者称为文档节点； &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; 为元素节点； lang=&quot;en&quot; 为属性节点； Harry Potter 为文本节点。 基础语法（Syntax）路径表达式（Path Expressions） 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 text() 选取文本。 断言（Predicates）断言被用来在查找指定的节点或者包含指定值的节点，通常放在方括号 [] 中。 示例： 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 //book[author[text()=’J K. Rowling’]] 选取 author 为 J K. Rowling 的 book 元素。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 模糊选取（Selecting Unknown Nodes） 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 合并选取（Selecting Several Paths）使用管道符 | 合并两个选取结果。 示例： 路径表达式 结果 //book/title&#124; //book/price 选取 book 元素的所有 title 和 price 元素。 //title &#124; //price 选取文档中的所有 title 和 price 元素。 /bookstore/book/title &#124; //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 正则匹配（Regular Match）可以使用 starts-with 和 ends-with 进行简单的正则匹配。 比如获取 Github 上某仓库的星星数的 Xpath 为， 1//div/a[ends-with(@href, &apos;stargazers&apos;)]/text() 表示获取 div 节点下的具备有属性为 href且值为 stargazers 结尾的 a 节点的文本内容。 测试我的 Xpath（Test Xpath） 可以使用 freeformatter.com 上提供的 Xpath Tester 进行在线测试。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"robot","slug":"it/robot","permalink":"https://linlshare.github.io/categories/it/robot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Robot","slug":"Robot","permalink":"https://linlshare.github.io/tags/Robot/"},{"name":"XPath","slug":"XPath","permalink":"https://linlshare.github.io/tags/XPath/"}]},{"title":"Selenium","slug":"it/robot/Selenium","date":"2018-11-20T09:18:59.000Z","updated":"2019-01-13T11:37:46.467Z","comments":true,"path":"2018/11/20/it/robot/Selenium/","link":"","permalink":"https://linlshare.github.io/2018/11/20/it/robot/Selenium/","excerpt":"","text":"安装 Selenium（1）Java 编程环境下 针对 Gradle 1compile 'org.seleniumhq.selenium:selenium-java:RELEASE' 针对 Maven 12345&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; （2）Python 编程环境下 1pip install selenium 安装和配置 Driver下载 Driver不同的操作系统和浏览器有不同的 Driver 需根据需求选取： Chrome driver Edge driver Firefox driver Safari driver 配置 Driver（以 Mac/Linux 为例）（1）将下载的 driver zip 压缩包解压 （2）将文件复制到系统的 bin 目录 1sudo cp path/to/driver /usr/local/bin （3）赋予 driver 可执行权限（以chromdriver为例） 1sudo chmod a+x /usr/local/bin/chromdriver 注意：Driver 的版本是跟 Selenium 相匹配的，如果发现有 NoSuchMethodError，请更新两者版本到最新稳定版。 自动生成 Selenium 代码在 Firefox 中安装插件 Katalon Recorder 可以方便地进行录制用户行为，然后导出各个语言环境下的 Selenium 代码。使用路径：Record –&gt; [Some interactions] –&gt; Stop –&gt; Export。 Headless Chrome没有 UI 界面的 Chrome 浏览器，便于进行自动化测试和在服务端环境运行，支持所有现代 Web 平台的特性。可参见 官网 了解更多。 支持情况Chrome 59+ CLI（Command Line Interface）12345&#123;chrome&#125; \\ --headless \\ # 以 Headless 模式运行 Chrome --disable-gpu \\ # 运行在带视窗的环境中时暂时需要该 Flag. --remote-debugging-port=9222 \\ https://www.chromestatus.com # 要打开的 URL, 默认为 about:blank. 上述的 {chrome} 在 Mac 中为 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome ， 在 Windows 中为 /path/to/chrome.exe。 建议设置 alias 将具体的路径对应到 chrome 命令，如下： 12345678## 编辑 .bash_profilevim ~/.bash_profile## 末尾追加alias chrome='/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome'## 保存退出:wq## 使 .bash_profile 立即生效source ~/.bash_profile 调试 Headless Chrome执行以下命令 1chrome --headless --disable-gpu --remote-debugging-port=9222 https://www.github.com 然后在 Chrome 浏览器窗口打开 http://localhost:9222 就可以使用 dev-tools 进行远程调试了。 在 Selenium 中使用 Headless Chrome（1）Java 环境下 12345ChromeOptions options = new ChromeOptions();options.addArguments(\"headless\");options.addArguments(\"window-size=1200x600\");WebDriver driver = new ChromeDriver(options);driver.get(\"http://www.github.com\"); （2）Python3 环境下 12345678import os from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.chrome.options import Optionschrome_options = Options() chrome_options.add_argument(\"--headless\")chrome_options.binary_location ='/usr/bin/google-chrome-stable'chrome_options.add_argument('--no-sandbox')driver = webdriver.Chrome(chrome_options=chrome_options)driver.get('https://www.github.com')","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"robot","slug":"it/robot","permalink":"https://linlshare.github.io/categories/it/robot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Robot","slug":"Robot","permalink":"https://linlshare.github.io/tags/Robot/"},{"name":"Selenium","slug":"Selenium","permalink":"https://linlshare.github.io/tags/Selenium/"}]},{"title":"周记 20181118","slug":"thinking/weekly/周记 20181118","date":"2018-11-18T15:19:05.000Z","updated":"2019-01-13T11:37:46.790Z","comments":true,"path":"2018/11/18/thinking/weekly/周记 20181118/","link":"","permalink":"https://linlshare.github.io/2018/11/18/thinking/weekly/周记 20181118/","excerpt":"","text":"又翻起了《瓦尔登湖》，一本自高中就伴随着我的书，王义国的译本。记得当时是在家附近的一所书店里买的，店里有卖各种盗版教辅书。书的纸质很粗糙，也不知是因为用了再生纸还是本身就是盗版的。不过，如今纸张愈加泛黄了，与书里节俭和自然的精神倒是挺配的。 每次拾起这本书都觉内心似泛着粼粼微波的湖面般平静，不管对现实有多大的不满足，对世界有什么欲求，都在此刻停止了，只觉得此刻的宁静是一种享受，很少有人能享受这份宁静，而我在这里找到了。 梭罗绝对是一个生活的冒险家，他认为当生活的必需品（食物、栖息处、衣服和燃料）满足之后，就应该开始生活的冒险，就像植物一样，根扎好了就要向上开花结果；而不是继续去追求奢侈品，或者说非必需品，那是一种被物役的表现，智者不为。 对待劳作，梭罗说：劳作的人日复一日，都没有闲情逸致获得一种真正的人格。劳作不息人就如机器，失去了人格。故而要好好对待自己的时间，合理平衡工作和生活，健全自己的人格才是。 对于生活，梭罗说：芸芸众生过的生活是既安静又绝望，又说：老的行为是让老年人来做的，而新的行为则是让年轻人来做。这是说不要只听老人言而不动脑，不要老是在旧的生活方式中打转，要敢于尝试新的东西，不要害怕失败，不要听天由命。 论及衣服，梭罗认为舒适保暖的衣服才是恰当的，像国王和王后一套衣服只穿一次的不过是挂新衣服的衣架罢了，并不知道一套合身衣服的舒适之处。同时，他也指出文明国家是以衣取人的。 说到房屋，梭罗比喻成是人类最外层的衣服，其最初的目的还是保暖。文明所创造出的现代房屋对大多数人来说是不必要的，因为文明创造出了宫殿，但要创造出贵族和国王来却并不这么容易。他认为我们的家具应该像印第安人和阿拉伯人一样简单，应该把家里乱七八糟的家具扔掉，以减少清晨清扫的工作，从而不被家具或者说现代房屋所奴役。 以上是我重温第一章节俭部分记录或划线的。《瓦尔登湖》是一本值得终身阅读的书，当时读不懂，只觉得读起来心情很平静，现在又多了一些体悟，说不定以后还会有更多的感受。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://linlshare.github.io/categories/thinking/"},{"name":"weekly","slug":"thinking/weekly","permalink":"https://linlshare.github.io/categories/thinking/weekly/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://linlshare.github.io/tags/周记/"},{"name":"自省","slug":"自省","permalink":"https://linlshare.github.io/tags/自省/"}]},{"title":"aws","slug":"it/java/aws/aws","date":"2018-11-09T09:54:48.000Z","updated":"2019-01-19T05:22:52.843Z","comments":true,"path":"2018/11/09/it/java/aws/aws/","link":"","permalink":"https://linlshare.github.io/2018/11/09/it/java/aws/aws/","excerpt":"","text":"配置12345aws configure --profile user2AWS Access Key ID [None]: AKIAI44QH8DHBEXAMPLEAWS Secret Access Key [None]: je7MtGbClwBF/2Zp9Utk/h3yCo8nvbEXAMPLEKEYDefault region name [None]: us-east-1Default output format [None]: text 清除配置的 access key（clear the credentials in aws configure）1$ rm -rf ~/.aws/credentials","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"aws","slug":"it/java/aws","permalink":"https://linlshare.github.io/categories/it/java/aws/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"aws","slug":"aws","permalink":"https://linlshare.github.io/tags/aws/"}]},{"title":"MongoDB","slug":"it/java/persistence/MongoDB","date":"2018-11-09T03:45:03.000Z","updated":"2019-01-22T07:12:27.392Z","comments":true,"path":"2018/11/09/it/java/persistence/MongoDB/","link":"","permalink":"https://linlshare.github.io/2018/11/09/it/java/persistence/MongoDB/","excerpt":"","text":"MongoDB 是一款开源的面向文档的数据库（document database）， NoSQL 中一种，同样使用文档存储实现 NoSQL 的 DB 还有 MarkLogic、OrientDB、CouchDB 等等。 安装Mac 用户可以直接使用 Homebrew 安装，命令如下： 1$ sudo brew install mongodb 也可以自己到 MongoDB 的下载中心 下载对应的系统和版本，如果是 Linux 的话可以使用 wget 下载： 1wget \"https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.4.tgz\" 并配置环境变量，如下： 1$ export PATH=&#123;MONGODB_DIR&#125;/bin:$PATH 启动12# &#123;mongo_db_file_path&#125; 为指定的数据库文件存放位置，不支持~符号。如果使用默认位置 /data/db ，也需要先手动创建。$ mongod --dbpath=&#123;mongo_db_file_path&#125; 终端连接（1）本地连接 1$ mongo （2）远程连接 1$ mongo 172.2.0.3:27017 基本概念BSONMongoDB 的文件存储格式为 BSON，所谓 BSON，即是 Binary JSON，为 JSON 文档对象的二进制编码格式，其扩展了 JSON 的数据类型，支持浮点数和整数的区分，支持日期类型，支持直接存储 JS 的正则表达式，支持 32 位和 64 位数字的区分，支持直接存储 JS 函数等等。看起来 BSON 对于 JS 还是挺友好的呵。 注意：从 Shell 终端中输入的数值都会被存储为 64 位浮点类型。 文档（Document）一个文档就相当于关系型数据库中的行的概念，由多个键值有序组成，格式为 BSON。示例如下： 1&#123; \"_id\" : ObjectId(\"5c05e74a65a27abc9a619f8a\"), \"a_key\" : \"a_value\" &#125; 其中 _id 是系统自动生成的键，当然也可以在创建时自定义值。 集合（Collection）一个集合就相当于关系型数据库中的表的概念，由多个文档组成。集合中的默认索引为 _id ，可以新建其他键的索引来优化查询，MongoDB 支持单字段索引（Single Field Index）、复合索引（Compound Index）以及多键索引（Multikey Index）等等，可以根据需求进行选用。 数据库（Database）多个集合组成一个数据库，不同的数据库之间文件是隔离的。单个 MongoDB 实例可以容纳多个独立数据库。默认系统存在以下的保留数据库： admin：用户权限相关 local：存储限于本地的集合 config：分片配置相关 Shell 操作database 级别1234567891011121314# 列出所有的数据库&gt; show dbs# 查看当前使用的数据库&gt; db# 切换当前使用的数据库&gt; use a_db# 创建数据库&gt; use new_db# 删除数据库&gt; db.dropDatabase() collection 级别1234567891011121314151617# 显示数据库中的所有 collection&gt; show collections# 列出 collection 中的所有列&gt; db.a_collection.find()# 删除 collection&gt; db.a_collection.drop()# 新建 collection&gt; db.createCollection(\"new_collection\")# 重命名 collection&gt; db.a_collection.renameCollection(\"new_name\")# 清空 collection 中数据&gt; db.a_collection.drop(&#123;&#125;) docuement 级别12345678910111213141516171819202122232425262728293031323334353637383940# 插入文档&gt; db.a_collection.insert(&#123; \"a_key\": \"a_value\", \"b_key\": 100, \"c_key\": true&#125;)# 列出所有文档，并美化&gt; db.a_collection.find().pretty()# 查询记录条数&gt; db.a_collection.find().count()# MongoDB AND 且过滤器&gt; db.a_collection.find(&#123; \"a_key\": \"a_value\", \"c_key\": true&#125;)# MongoDB OR 或过滤器&gt; db.a_collection.find(&#123; $or:[ &#123; \"a_key\": \"a_value\"&#125;, &#123; \"a_key\": \"another_value\" &#125; ]&#125;)# MongoDB 投影，只返回指定的字段&gt; db.a_collection.find(&#123;&#125;,&#123;\"a_key\", \"c_key\"&#125;)# 更新单个文档db.a_collection.update(&#123;\"a_key\": \"a_value\"&#125;,&#123;$set:&#123;\"a_key\": \"another_value\"&#125;&#125;)# 更新多个文档db.a_collection.update(&#123;\"a_key\": \"a_value\"&#125;,&#123;$set:&#123;\"a_key\": \"another_value\"&#125;&#125;,,&#123;multi: true&#125;)# 删除文档db.a_collection.remove(&#123;\"a_key\": \"a_value\"&#125;)# 后台执行创建单一复合索引操作db.a_collection.createIndex(&#123;\"a_key\": 1,\"c_key\": -1&#125;,&#123;unique: true,background: true&#125;)# 查询所有索引db.a_collection.getIndexes() Java 操作模块划分 bson：高性能的编码解码。 mongodb-driver-core：核心库，抽取出来主要是用于自定义 API。 mongodb-driver-legacy：兼容旧的 API 的同步 Java Driver。 mongodb-driver-sync：只包含 MongoCollection 泛型接口，服从一套新的跨 Driver 的 CRUD 规范。 mongodb-driver：mongodb-driver-legacy + mongodb-driver-sync，新项目推荐使用它！ mongodb-driver-async：新的异步 API，充分利用 Netty 或者 Java7 的 AsynchronousSocketChannel 已达到快而非阻塞的 IO。 mongo-java-driver（uber-jar）：包含 bson, mongodb-driver-core 和 mongodb-driver。 引入依赖123dependencies &#123; compile 'org.mongodb:mongodb-driver-sync:3.9.1'&#125; 在 v3.6.4 使用 MongoURI123456789101112131415String mongoUri = ConfigManager.getInstance().getString(DistributedConfig.MONGODB_URI);ConnectionString connectionString = new ConnectionString(mongoUri);CodecRegistry pojoCodecRegistry = fromRegistries(MongoClient.getDefaultCodecRegistry(), fromProviders(PojoCodecProvider.builder() .automatic(true) .build()));MongoClient mongoClient = new MongoClient(new MongoClientURI(mongoUri, MongoClientOptions.builder() .codecRegistry( pojoCodecRegistry)));String database = connectionString.getDatabase();if (Strings.isNullOrEmpty(database)) &#123; database = \"my_db\";&#125;MongoDatabase mongoDatabase = mongoClient.getDatabase(database); 在 v3.9.1 使用 MongoURI123456789101112131415161718192021222324252627282930public class Mongo &#123; private MongoDatabase mongoDatabase; private Mongo() &#123; String mongoUri = ConfigManager.getInstance().getString(DistributedConfig.MONGODB_URI); ConnectionString connectionString = new ConnectionString(mongoUri); CodecRegistry pojoCodecRegistry = fromRegistries(MongoClientSettings.getDefaultCodecRegistry(), fromProviders(PojoCodecProvider.builder() .automatic(true) .build())); MongoClientSettings settings = MongoClientSettings.builder() .applyConnectionString(connectionString) .codecRegistry(pojoCodecRegistry) .build(); MongoClient mongoClient = MongoClients.create(settings); String database = connectionString.getDatabase(); if (Strings.isNullOrEmpty(database)) &#123; database = \"my_db\"; &#125; MongoDatabase mongoDatabase = mongoClient.getDatabase(database); &#125; public &lt;T&gt; MongoCollection&lt;T&gt; getCollection(Class&lt;T&gt; documentClass) &#123; return mongoDatabase.getCollection(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, documentClass.getSimpleName()), documentClass); &#125;&#125; 事务支持MongoDB 的事务支持始于 MongoDB 4.0，对应 Java Driver 版本为 3.8.0，对应 Python 版本为 3.7.0，详情阅读 Transactions and MongoDB Drivers - mongodb.com. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void runTransactionWithRetry(Runnable transactional) &#123; while (true) &#123; try &#123; transactional.run(); break; &#125; catch (MongoException e) &#123; System.out.println(\"Transaction aborted. Caught exception during transaction.\"); if (e.hasErrorLabel(MongoException.TRANSIENT_TRANSACTION_ERROR_LABEL)) &#123; System.out.println(\"TransientTransactionError, aborting transaction and retrying ...\"); continue; &#125; else &#123; throw e; &#125; &#125; &#125;&#125;void commitWithRetry(ClientSession clientSession) &#123; while (true) &#123; try &#123; clientSession.commitTransaction(); System.out.println(\"Transaction committed\"); break; &#125; catch (MongoException e) &#123; // can retry commit if (e.hasErrorLabel(MongoException.UNKNOWN_TRANSACTION_COMMIT_RESULT_LABEL)) &#123; System.out.println(\"UnknownTransactionCommitResult, retrying commit operation ...\"); continue; &#125; else &#123; System.out.println(\"Exception during commit ...\"); throw e; &#125; &#125; &#125;&#125;void updateEmployeeInfo() &#123; MongoCollection&lt;Document&gt; employeesCollection = client.getDatabase(\"hr\").getCollection(\"employees\"); MongoCollection&lt;Document&gt; eventsCollection = client.getDatabase(\"hr\").getCollection(\"events\"); try (ClientSession clientSession = client.startSession()) &#123; clientSession.startTransaction(); employeesCollection.updateOne(clientSession, Filters.eq(\"employee\", 3), Updates.set(\"status\", \"Inactive\")); eventsCollection.insertOne(clientSession, new Document(\"employee\", 3).append(\"status\", new Document(\"new\", \"Inactive\").append(\"old\", \"Active\"))); commitWithRetry(clientSession); &#125;&#125;void updateEmployeeInfoWithRetry() &#123; runTransactionWithRetry(this::updateEmployeeInfo);&#125; Q&amp;A一个服务中该使用一个还是多个 MongoClient？通常一个服务应使用一个全局的 MongoClient，并且 MongoClient 中已经实现了一个连接池，最大值默认为 1000000 的连接限制，这相当于没有限制。 参考：为什么 MongoDB 连接数被用满了？ - mongoing.com Invalid BSON field name id更新文档时出现该错误，原因是使用了 updateOne 但是没有 $set 字段，改为使用 replaceOne 就不用这么麻烦了。 参考 MongoDB Driver Quick Start - mongoDB MongoDB学习（二）：数据类型和基本概念 - Hejin.Wang MongoDB索引原理 - mongoing.com","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://linlshare.github.io/tags/MongoDB/"}]},{"title":"Gradle","slug":"it/java/base/Gradle","date":"2018-11-07T11:44:00.000Z","updated":"2019-01-13T11:37:46.434Z","comments":true,"path":"2018/11/07/it/java/base/Gradle/","link":"","permalink":"https://linlshare.github.io/2018/11/07/it/java/base/Gradle/","excerpt":"","text":"使用初始化配置（1）场景 当需要所有的 gradle 项目都进行同样的配置时。 （2）过程 在 USER_HOME/.gradle 目录创建名为 init.gradle的文本文件； 在 init.gradle 编写初始化脚本。 （3）案例：配置自建的 Maven 私有服务器 123456789101112131415// init.gradleallprojects &#123; ext.RepoConfigurator = &#123; maven &#123; url 'http://maven-xx-inc.com/repository/maven-public/' &#125; maven &#123; url 'http://nexus.mobisummer-inc.com/nexus/content/groups/public' &#125; &#125; buildscript.repositories RepoConfigurator repositories RepoConfigurator&#125;","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://linlshare.github.io/tags/Gradle/"}]},{"title":"周记 20181140","slug":"thinking/weekly/周记 20181104","date":"2018-11-04T13:51:00.000Z","updated":"2019-01-13T11:37:46.789Z","comments":true,"path":"2018/11/04/thinking/weekly/周记 20181104/","link":"","permalink":"https://linlshare.github.io/2018/11/04/thinking/weekly/周记 20181104/","excerpt":"","text":"已经决定挑战，往后台方向发展了。接手了一个爬虫框架的设计和开发任务，但心里其实没底的，因为不曾独立设计和开发过一个框架，对 Java EE 世界中的各种框架其实也不甚了解。但还是硬着头皮上了，花了两三天阅读已有案例的设计文档、代码，并亲手画出一个既有框架的类图，画了又睡，睡了又画。成了之后找框架的设计者聊了一下，消解了设计上的一些疑惑。然，接下来才是重头戏，要基于此抽取并加入新的模块设计，编码还没到时候呢。加油吧，到时候多总结下。 另外，这几天不知为何睡眠质量很差，几乎没有深度睡眠，晚上早睡睡不着，早上四五点就自然醒了，搞得预定的任务缩水了。不过今晚研究《甲骨文简易词典》时倒是气定神闲，脑壳没有沉重的感觉，可能我比较适合从事文字学特别是汉字学的工作也不一定。 阅读《枕草子》时读到一首和歌很感动，原文是这样的： 心是地下逝水在翻滚了 不言语，但相思 还胜似语话 中宫久不见清少纳言，托人送信，信中引用该和歌，只写着 不言语，但相思 ，令少纳言读后顿时落泪，过几天后就进宫去了。她们见面的情形大概可以用《鹊桥仙·纤云弄巧》里的 金风玉露一相逢，便胜却，人间无数 （最近想起这句词，不自觉地背起来了）来表达了。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://linlshare.github.io/categories/thinking/"},{"name":"weekly","slug":"thinking/weekly","permalink":"https://linlshare.github.io/categories/thinking/weekly/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://linlshare.github.io/tags/周记/"},{"name":"自省","slug":"自省","permalink":"https://linlshare.github.io/tags/自省/"}]},{"title":"Pipeline 模型","slug":"it/java/arch/Pipeline 模型","date":"2018-11-04T13:49:00.000Z","updated":"2019-01-13T11:37:46.380Z","comments":true,"path":"2018/11/04/it/java/arch/Pipeline 模型/","link":"","permalink":"https://linlshare.github.io/2018/11/04/it/java/arch/Pipeline 模型/","excerpt":"","text":"解决的问题解决并发效率问题，将任务拆分成流水线，然后多线程并发执行，比之单线程执行快。 案例 CPU 流水线 Tomcat 容器 Structs","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"arch","slug":"it/java/arch","permalink":"https://linlshare.github.io/categories/it/java/arch/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"pipeline","slug":"pipeline","permalink":"https://linlshare.github.io/tags/pipeline/"}]},{"title":"Java EE","slug":"it/java/base/Java EE","date":"2018-10-29T12:14:00.000Z","updated":"2019-01-13T11:37:46.435Z","comments":true,"path":"2018/10/29/it/java/base/Java EE/","link":"","permalink":"https://linlshare.github.io/2018/10/29/it/java/base/Java EE/","excerpt":"","text":"Java EEJava平台企业版，2018年3月更名为 Jakarta EE。Jave EE 是一系列技术标准所组成的平台，包括： Servlet EJB JDBC JSP JSTL … 服务器与容器（Server and Container）服务器的定义依维基，服务器（软件）是指一个管理资源并为用户提供服务的计算机软件。可分为： 文件服务器（File Server），提供文件存取服务。 数据库服务器（Database Server），提供数据库存取服务。 邮件服务器（Mail Server），提供邮件存取服务。 网页服务器（Web Server），提供网页浏览服务，通常所说的 Web 服务器，含义更广，包括了应用程序服务器。 FTP 服务器（FTP Server），提供文件传输服务。 应用程序服务器（Application Server），提供应用程序接口服务。 代理服务器（Proxy Server），提供代理服务，分正向和反向代理。 … 正向代理（Forward Proxy）与反向代理（Reverse Proxy）正向代理和反向代理以代理对象为区分，正向代理代理的是客户端，而目标服务器对真实的客户端的请求是无感的；反向代理代理的是服务器群（或簇），而客户端对真实处理请求的服务器是无感的。更多信息参见：反向代理为何叫反向代理？ - 刘志军的回答 - 知乎。 容器的定义该语境下的容器，既不是上街买菜用的容器，也不是存取其他类的集合（比如 List），而是一个运行在 JVM 的 Java 程序，本身作为一个组件的运行时 ，起组件与服务器之间的接口作用，实际上也可以称之为服务器软件，只是当处在大的服务器软件包裹下时，选择另一种称呼罢了。 随着网络服务的要求越来越复杂，开发人员使用规范和组件的概念将服务划分，组件实现了规范，容器运行着组件，最新的 规范-组件-功能-容器 对应关系如下： 规范 组件 功能 容器 JSR 369 Servlet 4.0 Server Applet，服务端小程序，处理基于 HTTP 的 Web 请求，响应动态 Web 内容。 Servlet 容器 JSR 245 JSP 2.1 JavaServer Pages，实现动态网页，其基于 Servlet 技术，故 JSP 容器是 Servlet 容器的子集。 JSP 容器 JSR 220 EJB 3.0 Enterprise JavaBean，封装业务逻辑，包括 Session Bean，Entity Bean 和 Message Driven Bean。 EJB 容器 常见的 Web 服务器 Apache HTTP Server Nginx IIS Tomcat Jetty WildFly（原名JBoss AS或者JBoss） Netty 架构（Architecture）软件架构是指软件的基本结构，阮一峰在 软件架构入门 中谈及架构的分类，可分为：分层架构（Layered Architecture）、事件驱动架构（Event-driven Architecture）、微核架构（Microkernel Architecture）、微服务架构（Microservices Architecture）、云架构（Cloud Architecture）。 分层架构的核心是 “数据”，围绕数据的呈现、逻辑处理、持久化和存储进行分层； 事件驱动架构的核心是 “事件”，围绕事件的整个发出、队列、分发、通道、处理进行分层； 微核架构的核心是 “插件”，将每个小功能做成可插拔的插件形式嵌入内核； 微服务架构的核心是 “微服务”，将每个服务单独运行，并通过远程通信协议联系在一起； 云架构的核心是 “虚拟化”，没有中央数据库，由一个虚拟中间件（Virtualized Middleware）和若干处理单元（Processing Unit）组成，数据通过虚拟中间件中的数据中间件进行同步。 框架（Framework）参考维基，软件框架是指一种通用的，实现基本功能的软件，用户可以在上面添加业务特定的代码。软件框架可能包括支持程序，编译器，代码库，工具集和应用程序编程接口（API），它汇集了所有不同的组件，以支持项目或系统的开发。框架相较于普通的代码库有如下特征： 控制反转，由框架决定程序的控制流程。 可扩展性。 封闭性，框架代码不可修改。 常见的 Java EE 开发框架： Spring Spring MVC Spring Cloud Hibernate MyBatis Dubbo Kafka 常见的 Java EE 开发框架集： Spring Boot SSH（Spring + Spring MVC + Hibernate） SSM（Spring + Spring MVC + MyBatis）","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JavaEE","slug":"JavaEE","permalink":"https://linlshare.github.io/tags/JavaEE/"},{"name":"服务器","slug":"服务器","permalink":"https://linlshare.github.io/tags/服务器/"}]},{"title":"周记 20181028","slug":"thinking/weekly/周记 20181028","date":"2018-10-28T15:50:00.000Z","updated":"2019-01-13T11:37:46.788Z","comments":true,"path":"2018/10/28/thinking/weekly/周记 20181028/","link":"","permalink":"https://linlshare.github.io/2018/10/28/thinking/weekly/周记 20181028/","excerpt":"","text":"怎么说呢？先说坏的地方吧，Spring 的学习任务全部没完成，真遗憾，到底没能坚持，练吉他的安排也暂时搁置了，对音调的高低把握不准，再想想看有无方法解决。日语和古代汉语的学习任务完成 70% 左右，阅读《枕草子》的计划算是完成较好的，完成了 80% 。 值得开心的是，发现了原来可以使用 github page + hexo + wikitten 搭建一个个人的 wiki，知识管理又迈上了一个新台阶。 还有許進雄的《甲骨文簡易詞典》已经看完 1/3 了，等看完了一定要整理一份文档，从最简单的构件开始讲述文字隐藏的朴素的创意。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://linlshare.github.io/categories/thinking/"},{"name":"weekly","slug":"thinking/weekly","permalink":"https://linlshare.github.io/categories/thinking/weekly/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://linlshare.github.io/tags/周记/"},{"name":"自省","slug":"自省","permalink":"https://linlshare.github.io/tags/自省/"}]},{"title":"Redis","slug":"it/java/base/Redis","date":"2018-10-28T15:02:00.000Z","updated":"2019-01-15T07:30:40.000Z","comments":true,"path":"2018/10/28/it/java/base/Redis/","link":"","permalink":"https://linlshare.github.io/2018/10/28/it/java/base/Redis/","excerpt":"","text":"安装（1）Mac HomeBrew1$ brew install redis （2）按部就班12345678910# 需要前置依赖 make、gcc$ sudo apt-get update$ sudo apt install make$ sudo apt-get install gcc# 下载、解压和编译 redis$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz$ cd redis-5.0.3$ make 命令行使用启动 Redis Server1$./src/redis-server 进入 Redis 命令行（1）本地连接 12345$redis-cliredis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG （2）远程连接 1$ redis-cli -h host -p port -a password 取键相关命令12345678910111213141516# 查找所有 key&gt; KEYS *# 查找符合给定正则的 key&gt; KEYS pattern# 删除某个 key&gt; DEL a_key# 检查某个 key 是否存在&gt; EXISTS a_key# 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。&gt; TTL a_key# 获知某个 key 存储值的类型&gt; TYPE a_key# 获取Size，可能会把失效的也计算在内&gt; DBSIZE 字符串取值相关命令1234# 设置指定 key 的值&gt; SET a_key a_value# 获取指定 key 的字符串值&gt; GET a_key 注意：对有标点符号的 key，要用双引号（“”）包裹，否则会返回 nil 。比如使用 Spring Cache + Redis 时，会序列化缓存方法返回值，这是的 KEY 就要用双引号括起来，示例如下， GET &quot;cache1:\\xac\\xed\\x00\\x05t\\x00$cb5775e6-1b39-4f63-85c8-13f134a54f32&quot; List 相关命令12345678910# 获知列表长度&gt; Llen a_key# 获取列表指定范围内的元素。其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。&gt; Lrange a_key start end# 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。&gt; Ltrim a_key start end# 移除并返回列表的最后一个元素。&gt; Lpop a_key Set 相关命令12345678# 返回集合中的所有成员&gt; smembers a_key# 添加成员到集合中&gt; sadd a_key a_member# 获取集合中的成员数&gt; scard a_key# 移除集合中的一个或多个成员&gt; srem a_key a_member b_member 删库跑路相关命令1234# 删除所有数据库的所有key&gt; FLUSHALL# 删除当前数据库的所有key&gt; FLUSHDB Jedis 使用快速开始（1）引入依赖 1compile \"redis.clients:jedis:3.0.0\" （2）简单使用 123Jedis jedis = new Jedis(\"localhost\");jedis.set(\"foo\", \"bar\");String value = jedis.get(\"foo\"); 排错编译安装时出现：jemalloc/jemalloc.h: No such file or directory1make MALLOC=libc 编译安装时出现：cc adlist.o /bin/sh:1:cc:not found 缺少 gcc 环境，安装 gcc 即可。 服务器连接 Redis 失败（1）背景 服务器部署 Redis ，代码部署在另一主机，调用 Redis 时发生以下异常： 12345Caused by: redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command &apos;CONFIG SET protected-mode no&apos; from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent.2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to &apos;no&apos;, and then restarting the server.3) If you started the server manually just for testing, restart it with the &apos;--protected-mode no&apos; option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside. （2）原因 查看 redis.conf 发现 bind 127.0.0.1 ，意味着只有部署 Redis 的机器 可以正常访问 Redis。 还有 Redis 运行在保护模式下。 （3）解决方案 方案一：配置 bind 地址为内网的 IP 地址，修改 protected-mode no ，然后重启 Redis。 参考 Download - redis.io Redis 命令参考 - redis.net","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"https://linlshare.github.io/tags/Redis/"}]},{"title":"Hexo + Github Page = 个人 WiKi","slug":"it/tool/Hexo + Github Page = 个人 WiKi","date":"2018-10-27T16:00:00.000Z","updated":"2019-01-13T11:37:46.481Z","comments":true,"path":"2018/10/28/it/tool/Hexo + Github Page = 个人 WiKi/","link":"","permalink":"https://linlshare.github.io/2018/10/28/it/tool/Hexo + Github Page = 个人 WiKi/","excerpt":"","text":"Hexo 安装环境依赖 Node.js Git 开始安装12345npm install hexo-cli -gnpm install hexo --save#如果命令无法运行，可以尝试更换taobao的npm源npm install -g cnpm --registry=https://registry.npm.taobao.org 基础配置1234#Hexo 将会在指定文件夹中新建所需要的文件。hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 1234567891011121314#安装Hexo插件npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 12# 在本地查看效果hexo server 主题配置修改根目录的 _config.yml，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: IT协会 #网站标题subtitle: 学习 总结 分享 #网站副标题description: 学习 总结 分享 #网站描述author: itxiehui#网站作者email: gdinit@163.com #联系邮箱language: zh-CN# URL## If your site is put in a subdirectoryurl: http://itxiehui.github.io #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code......# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqusdisqus_shortname:# Extensions## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: jacman #修改主题exclude_generator:Plugins:- hexo-generator-feed- hexo-generator-sitemap......# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: # 部署位置 type: github repository: https://github.com/test/test.github.io.git branch: master 开始写作使用 hexo new &quot;article&quot;创建一个新文件，该文件为*.md 格式，可以使用 Typora（一款优秀的 Markdown 写作工具，支持侧边栏显示目录和文件夹，最令人惊叹的是编辑和渲染合一的写作方式）进行写作。然后使用 hexo d -g 生成相关 web 页面并部署到 Github 上。注意在 _config.yml中配置的 deploy 的 repository 要看是否电脑有多个 Github 账号。 123456#常用命令hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub 12345#简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 使用 Wikitten 主题访问 hexo-theme-Wikitten 了解如何安装该款主题。 默认显示文章目录（toc as default）在 hemes/Wikitten/layout/common 找到 article.ejs ，并修改 123456&lt;% if (post.toc) &#123; %&gt;&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;&lt;strong class=&quot;toc-title&quot;&gt;&lt;%= __(&apos;article.catalogue&apos;) %&gt;&lt;/strong&gt;&lt;%- toc(post.content) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 为 123456&lt;% if (post.toc!=false) &#123; %&gt;&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;&lt;strong class=&quot;toc-title&quot;&gt;&lt;%= __(&apos;article.catalogue&apos;) %&gt;&lt;/strong&gt;&lt;%- toc(post.content) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 然后重新生成部署（hexo g -d）即可。 引用本地图片按照官方的 asset-folders 的方法处理图片引用，在本地预览时是无法显示的，参考文章 hexo中完美插入本地图片 ，总结出如下的解决方案： （1）开启 post_asset_folder 12// config.ymlpost_asset_folder: true （2）安装 hexo-asset-image 插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save （3）使用方式 在与 _posts/my_article.md的平级位置上创建文件夹 my_article； 放置 my_article.md 文件中引用到的图片，例如 my_pic.jpg； 在 my_article.md 以 ![my_pic](my_article/my_pic.jpg) 方式引用。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linlshare.github.io/tags/Hexo/"},{"name":"Wiki","slug":"Wiki","permalink":"https://linlshare.github.io/tags/Wiki/"}]},{"title":"Draw.io","slug":"it/tool/Draw.io","date":"2018-10-23T02:14:00.000Z","updated":"2019-01-13T11:37:46.475Z","comments":true,"path":"2018/10/23/it/tool/Draw.io/","link":"","permalink":"https://linlshare.github.io/2018/10/23/it/tool/Draw.io/","excerpt":"","text":"如何给类图增加一个字段？选中一个字段，然后按 Ctrl +Enter 即可。 参考：Add row to class diagram - stackoverflow","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Draw.io","slug":"Draw-io","permalink":"https://linlshare.github.io/tags/Draw-io/"},{"name":"绘图","slug":"绘图","permalink":"https://linlshare.github.io/tags/绘图/"}]},{"title":"周记 20181021","slug":"thinking/weekly/周记 20181021","date":"2018-10-21T08:51:00.000Z","updated":"2019-01-13T11:37:46.788Z","comments":true,"path":"2018/10/21/thinking/weekly/周记 20181021/","link":"","permalink":"https://linlshare.github.io/2018/10/21/thinking/weekly/周记 20181021/","excerpt":"","text":"恍恍惚，又一周过去了。想下，周一以来工作上一直在不断地修补后台好友邀请服务的 bug，还有就是开发聊天和推送服务，顺便补了下 Spring 的知识。学习上似乎晚上会看下《枕草子》，不过速度有点慢了，后面还有好几千页呢。情感上，因为早晚听巴赫作品集的关系，基本稳定，不会有太大波动，就是有时候夜里难以入睡，解决方案是看 Kindle，看着看着不知不觉就睡过去了。最大的收获是发现了一款叫 “方片” 的产品（包含移动端和 Chrome 插件），相见恨晚，它快速简便地收集资料（文字、图片和链接），多端同步，还可以同步到印象笔记中，这样的软件即使付费使用我也愿意。哦，对了，我还重新认识了 Afred 这款 Mac 上的效率佳软，其剪贴板历史功能、查字典和文件查找快捷命令令我折服。 另一个我：工作上能意识到不足，然后补充相关的知识，这点很不错。但是要 output 啊，没见你输出什么笔记之类的，还有要有计划地学习，不能逮到什么学习什么，看到不足的可以先收集起来，然后下一周努力补上。学习上也是，那么厚的书，你有考虑到后果吗？你有安排什么时候会读完吗？不过说来你有在进行细致的读书补遗，这点很 nice，坚持补遗，才能有接近作者生活体验的读书体验。还有巴赫作品集实在是你这种单身狗的救星了，平和而又有变化的旋律可以稳定人的情绪，特别是那平均律，足以令你陶然其中。最后，效率软件要用起来，不能再依赖慢吞吞的触摸板点来点去了。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://linlshare.github.io/categories/thinking/"},{"name":"weekly","slug":"thinking/weekly","permalink":"https://linlshare.github.io/categories/thinking/weekly/"}],"tags":[{"name":"周记","slug":"周记","permalink":"https://linlshare.github.io/tags/周记/"},{"name":"自省","slug":"自省","permalink":"https://linlshare.github.io/tags/自省/"}]},{"title":"Git","slug":"it/tool/Git","date":"2018-10-17T03:44:00.000Z","updated":"2019-01-13T11:37:46.477Z","comments":true,"path":"2018/10/17/it/tool/Git/","link":"","permalink":"https://linlshare.github.io/2018/10/17/it/tool/Git/","excerpt":"","text":"提交当前分支的更改到远程的同名分支1$ git push origin HEAD 删除远程分支123$ git push origin :dev-sth# 相当于$ git push origin --delete dev-sth 撤销 git commit 但未 git push 的修改123456#找到想要撤销的 commit id$ git log#撤销，但不对代码修改进行撤销，还可以再次 commit$ git reset &lt;commit id&gt; #撤销并忽略该次 commit 的代码修改$ git reset --hard &lt;commit id&gt; 移除远程分支上的脏文件（clean remote files）1$ git rm -rf &lt;file1&gt; &lt;file2&gt; 添加子模块（submodule）1$ git submodule add git://github.com/chneukirchen/rack.git rack 入门Git是什么？Git中译为混账，是Linus先生花了一个星期写的分布式版本控制系统（VCS，Version Control System），用于Linux内核的协同开发。所谓版本控制系统，个人理解就是可以保存文本文件的历史版本信息，并且可以回溯到某个历史版本的文本文件管理系统。它的设计就是为了方便软件开发的版本迭代和协同开发。 比如，你打开电脑的记事本，一个不小心把昨天写的备忘全给删除了，而且还习惯性地按了Ctrl+S，你懵了。一般情况下是找不回来了。除非有版本备份，现在有些云笔记类软件就提供了这样的功能。其实质就是版本控制，它可以让你回溯到某个历史版本，像是吃了后悔药一般美妙。 Git怎么玩？配置Git环境玩什么都有第一步，已经司空见惯了呃。没错就是配置环境。Git的环境配置还不算复杂： 下载Git并安装Git（注意：不懂英文的按默认配置就好）; 向全世界宣称你的存在 1234//注意：--global表示你电脑里的所以Git仓库都采用相同的配置//如果有不用用户的Git仓库，就去掉吧。$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 建个仓库放点东西 建库简单：在磁盘上新建个文件夹作为工作区，然后右击打开Git Bash，执行git init，你会发现多了个.git文件夹。 放东西有点复杂 第一步：在工作区新建一个文件，命名为yuren.txt。注意：文本文件的编码是UTF-8 without BOM（使用Notepad++可以查看和修改） 第二步：git add .添加文件到暂存区 第三步：git commit -m &quot;add yuren.txt&quot;添加文件到本地仓库 历尽千辛万苦终于把文件交给Git来管理了。 时光机穿梭假定你在上个步骤中放入的文件是：yuren.txt。里面的内容是（标记为v1）： [微信红包]恭喜发财，大吉大利！是不是又冲进来了，这么激动干嘛，发几个文字而已~ 后来，你想了想，改成了（标记为v2）： [微信红包]愚人节Happy！是不是又冲进来了，这么激动干嘛，发几个文字而已~ 根据【建个仓库放点东西】里说的步骤更新本地仓库中的信息： 12$ git add .$ git commit -m \"update yuren.txt\" 不知道哪根筋不对，你又想要v1版本的yuren.txt了，但是又忘了上一次写的内容，怎么办？ 没关系，可以通过git log查看每次的提交信息。 123456789101112$ git logcommit 1ba454f3ef3e48b88b4c24f72dc8055407cd9019Author: Your Name &lt;email@example.com&gt;Date: Fri Apr 1 16:19:41 2016 +0800 update yuren.txtcommit ce58ee1a57d21c9d752e80b820b7f2968249ac2eAuthor: Your Name &lt;email@example.com&gt;Date: Fri Apr 1 16:17:35 2016 +0800 add yuren.text 回退到上一次commit，只需要执行 12$ git reset --hard HEAD^HEAD is now at ce58ee1 add yuren.text 这里，HEAD^代表上一个版本，HEAD^^代表上上个版本，HEAD~100代表上100个版本。当然可以使用具体的commit id来回退，比如上面的等价于$ git reset --hard ce58ee1 重新打开yuren.txt来看，v1版本的信息果然回来了。 人的心理真是捉摸不透，刚找回v1版本的信息了，就又怀念v2版本的信息了。然而，现在使用git log都救不了你了。 123456$ git logcommit ce58ee1a57d21c9d752e80b820b7f2968249ac2eAuthor: Lshare &lt;linlshare@gmail.com&gt;Date: Fri Apr 1 16:17:35 2016 +0800 add yuren.text v2版本的信息似乎丢失了。怎么办？ 方法一：如果你还知道v2版本的commit id的话可以$ git reset --hard &lt;commit id&gt;来解决； 方法二：假如你不知道也没关系，使用git reflog查看你的每次命令，接下来就可以用方法一解决了。 1234$ git reflogce58ee1 HEAD@&#123;0&#125;: reset: moving to HEAD^1ba454f HEAD@&#123;1&#125;: commit: update yuren.txtce58ee1 HEAD@&#123;2&#125;: commit (initial): add yuren.text","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://linlshare.github.io/tags/Git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://linlshare.github.io/tags/版本控制/"}]},{"title":"日语一周七天的记忆方法","slug":"language/日語/日语一周七天的记忆方法","date":"2018-09-29T15:46:00.000Z","updated":"2019-01-13T11:37:46.597Z","comments":true,"path":"2018/09/29/language/日語/日语一周七天的记忆方法/","link":"","permalink":"https://linlshare.github.io/2018/09/29/language/日語/日语一周七天的记忆方法/","excerpt":"","text":"速记 汉语 日语 英语 来源 星期日 日曜日 Sunday Sun Day（太阳之日） 星期一 月曜日 MonDay Moon Day（月亮之日） 星期二 火曜日 Tuesday Tiu’s Day（ Tiu 是日耳曼战争之神，代替古罗马中的战神 Mars，中国命名为火星） 星期三 水曜日 Wednesday Woden’s Day（ Woden 是日耳曼神话中的至高神，代替古罗马中的 信使 Mercury ，中国命名为水星） 星期四 木曜日 ThursDay Thor’s Day（ Thor 是北欧雷神，代替古罗马中的爱神 Jupiter，中国命名为木星） 星期五 金曜日 FriDay Freya’s Day… Or Frigg’s Day（ Freya 和 Frigg 都是北欧女神，代替古罗马中的女神 Venus，中国命名为金星） 星期六 土曜日 Saturday Saturn’s Day（ Saturn 是古罗马中的农神） Week古巴比伦人首先使用 7 日为一周的时间单位，后来犹太人把它传到古埃及，又由古埃及传到罗马，公元3世纪以后，就广泛地传播到欧洲各国。唐朝时期在西域和中国的交流中传入了中土获得发展，再传入朝鲜半岛，日本。 七曜杨士勋（唐）疏：“ 谓之七曜者，日月五星皆照天下，故谓之曜。” 一个曜日就是日月五星轮流照耀世界的一天。日本曜日的说法就是从中国传入的。 星期“星期”原是指牛郎星和织女星相会之期，现代意义的“星期”是个旧词新义词。光绪三十一年（1905年）由袁嘉谷所定用“星期”代替“曜日”，到了民国以后星期被广泛使用。 礼拜到了19世纪20年代，有人将汉语中的“礼拜”一词用作英语 week 的对应词了，如1828年马礼逊《广东省土话字汇》：“WEEK ，a ，一个礼拜。”“礼拜”原为动词，指宗教徒向所信奉的神行礼。由于基督教、伊斯兰教是一星期做一次礼拜，故此词慢慢引申用来指 week 了。 周日本还有一个表示 week 的“周”字，而且这个词还传到了中国。如1901年《清议报》七十八册《马塞多尼亚》：“前在欧洲定造水雷艇六只。目下有二只，业已竣工，数周间（即数礼拜）必到。” 参考 How every day of the week got its name 从七曜说到“礼拜”、“星期”、“周”的语源 星期 - 维基百科","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"汉语音韵中的四声八调及平仄","slug":"language/漢語言/汉语音韵中的四声八调及平仄","date":"2018-09-28T00:32:00.000Z","updated":"2019-01-13T11:37:46.601Z","comments":true,"path":"2018/09/28/language/漢語言/汉语音韵中的四声八调及平仄/","link":"","permalink":"https://linlshare.github.io/2018/09/28/language/漢語言/汉语音韵中的四声八调及平仄/","excerpt":"","text":"四声八调国语拼音中的四声为：一声、二声、三声、四声，其正式学名分别为：阴平、阳平、上声、去声。其 IPA 调值（根据五度分音法确定的相对调值）如下： 声调 IPA 调值 记号 阴平 55 ¯ 阳平 35 ˊ 上声 214 ˇ 去声 51 ˋ 在古代汉语中四声八调的说法。“四声” 源自唐宋时期中古汉语的 “平上去入” 四个声调。在发展过程中经历了以下的流变： 平分阴阳在元代受声母发音方法中的清浊从每一声中分出阴阳二调（清者为阴，浊者为阳），构成 “阴平”、“阳平”、“阴上”、“阳上”、“阴去”、“阳去”、“阴去”、“阳去”、“阴入”、“阳入” 共八个调。 如今，官话北京话只有平声分阴阳，而吴语和闽南语只有上声不分阴阳。 浊上归去指声母为全浊的上声字改读去声（而次浊上字声调和清上字相同）。次浊和全浊的关键在于声带震动的程度，笔者母语福佬话中刚好与中古音相符。 汉字 中古音 汉语拼音 闽南语台罗拼音 吴语拼音（苏州闲话） 岛 清上 dǎo tó tau5 道 全浊上 dào tō dau6 老 次浊上 lǎo láu lau6 入派三声官话及大多数方言中入声消失了，并归入了其他三声，而在南方的方言（包括粤语、闽南语、客语和吴语等）中仍然包含着入声。比如 “屋” 在在粤语、闽南语、客语和吴语都是入声，而在国语中是平声。 平仄中古汉语中，“平仄” 是指 平声为 “平”，其他三声为 “仄”。之后随着音韵的流变，原本诗词中的 “仄” 声变得难以判断。但是根据流变规律可以得出一个简易的判别方法：如果国语中为非平声，那么就是 “仄”；如果国语中为平声，而南方方言中为入声，那么就是 “仄”，否则为 “平”。 参考 【語文常識】甚麼是「四聲」、「平仄」- 教研札記 四聲 - 維基百科 吳語學堂 台灣閩南語常用詞辭典 【苏白学堂/教程】吴语苏州话语音基础入门（学堂版拼音）- Bilibili","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"漢語言","slug":"language/漢語言","permalink":"https://linlshare.github.io/categories/language/漢語言/"}],"tags":[{"name":"古漢語","slug":"古漢語","permalink":"https://linlshare.github.io/tags/古漢語/"}]},{"title":"SSH","slug":"it/tool/SSH","date":"2018-09-26T09:22:00.000Z","updated":"2019-01-13T11:37:46.485Z","comments":true,"path":"2018/09/26/it/tool/SSH/","link":"","permalink":"https://linlshare.github.io/2018/09/26/it/tool/SSH/","excerpt":"","text":"SSH 背景 解决的问题：明文登录信息暴露问题。 历史： 1995 年，芬兰赫尔辛基理工大学的 Tatu Ylonen 发现自己学校存在嗅探密码的网络攻击，于是开发了 SSH （Secure Shell）通信安全协议，用于加密登录，并随后以免费软件形式发布，并创办 SSH 通信安全公司来继续开发和销售SSH。 截至2005年，OpenSSH 是唯一一种最流行的SSH实现，而且成为了大量操作系统的默认组件。 SSH 原理核心：非对称加密。 整个过程是这样的： 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 口令登录用户使用 ssh user@host 登录远程主机时，系统会提示远程主机的公钥指纹，当用户确认接收该公钥指纹时，会保存到 $HOME/.ssh/known_hosts 中，下次登录时会跳过。 公钥指纹：公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较。 公钥登录所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 用户将自己的公钥储存在远程主机的具体过程如下： 使用 ssh-keygen 在本地目录 $HOME/.ssh/ 生成公钥 id_rsa.pub 和密钥 id_rsa ； 使用 ssh-copy-id user@host 将公钥上传至远程主机 host 中，实现细节是： 1$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub SSH CONFIG FILE可以通过配置文件快速进行 ssh 登录，配置文件有两种： 用户配置文件 ~/.ssh/config； 系统配置文件 /etc/ssh/ssh_config)。 可配置项有： Host，配置标识，使用 ssh [Host] 进行快速登录； HostName，服务器所在地址，可以是域名或 IP； User，进行 ssh 登录的用户名； Port，指定服务器端口； IdentityFile，指定私钥文件的位置。 如在 ~/.ssh/config文件中按如下配置，则可以通过 ssh xx-server 进行快速 ssh 登录。 12345Host xx-server HostName ssh.xx-server.com User xx_user Port 2200 IdentityFile ~/.ssh/local_id_rsa 名词解释 名词 含义 X.509 一种通用的证书格式，包含证书持有人的公钥，加密算法等信息 pkcs1 ~ pkcs12 公钥加密（非对称加密）的一种标准，一般存储为 *.pN，*.p12 是包含证书和密钥的封装格式 *.der 证书的二进制存储格式（不常用） *.pem 证书或密钥的 Base64 文本存储格式，可以单独存放证书或密钥，也可以同时存放 *.key 单独存放的 pem 格式的密钥，一般保存为 *.key .cer .crt 两个指的都是证书，Linux 下叫 crt，Windows 下叫 cer；存储格式可以是 pem 也可以是 der *.pfx 微软 IIS 的实现 *.jks Java Keytool 实现的证书格式 排错SSH 一直登陆不上，又没显示错误信息在 ssh 命名最后添加 -v/-vv 输出连接信息。 参考 Secure Shell - 维基百科 SSH原理与运用（一）：远程登录 SSH CONFIG FILE - ssh.com SSL中，公钥、私钥、证书的后缀名都是些啥？ - 海棠依旧的回答 - 知乎","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://linlshare.github.io/tags/SSH/"}]},{"title":"关于字体的一些小知识","slug":"design/typeface/关于字体的一些小知识","date":"2018-09-25T03:04:00.000Z","updated":"2019-01-13T11:37:46.355Z","comments":true,"path":"2018/09/25/design/typeface/关于字体的一些小知识/","link":"","permalink":"https://linlshare.github.io/2018/09/25/design/typeface/关于字体的一些小知识/","excerpt":"","text":"AtyplATypI 或 Association Typographique Internationale （国际排印协会）是一家致力于排版和类型设计的国际非营利组织。该协会的主要活动是每年秋季会议，每年在不同的全球城市举行。第62届年会于2018年9月11至15日在比利时安特卫普举办，主题为 “Type Legacies”（字体遗产）。 字体类型（数字化字体，Digital Font） 点阵字体（Bitmap Font）通过点阵表现字形，其本质上只是一组图片。每一种字体变体都包括一组完整的字符，一个字符占一张图片。假设总字符数量为3，即包括三个字符，提供粗体和斜体的组合（即无、粗体、斜体、粗斜体四种变体），该字体总共有12张图片。 轮廓字体（outline font），又称描边字体。这类字体使用贝兹曲线描述轮廓，可以通过简单的数学变形放大或缩小。但是很小的字体经常需要额外的信息（hints）指导笔画取舍进行润算，不然容易漆黑一团。 PostScript，由Adobe公司为专业数字排版开发。它使用PostScript，字形以3次贝兹曲线描述。 OpentType，是一种最初由苹果计算机公司开发的字体技术。 TrueType，为了实现Windows和Macintosh系统兼容，而产生的一种新字体格式。 笔画字体（Stroke-based font），字形的轮廓由分离的笔画顶点和笔画外形（profile）定义。它优于轮廓字体之处在于：减少了定义字形的顶点数，允许同一组顶点生成不同的字体（不同的粗细，不同大小或不同衬线规则）所以节省大小。 METAFONT，美国计算机科学家高德纳（Donald Knuth）于1977年着手字体制作软件，并于1979年发布的第一个版本METAFONT。与TrueType类似，它是一种数学上的字体描述系统，只是描述字符使用圆点（circular pen）。这意味着由METAFONT产生的字形，没有锐利的点（sharp points），即笔尖大小是有限的。 带喇叭口的黑体 在设计横画起笔、收笔处向上下微微扩张，形成喇叭口的黑体。 –摘自 有喇叭口的黑一体蓬间雀新浪博客 这种装饰源于早些时候的铅字印刷的铅字，由于当时技术的限制，笔画的端口会收缩，为了解决这个问题，当时设计铅字的工作人员就把黑体设计成喇叭口的。 – 摘自 黑体 -百度百科 Variable Font2016 年 9 月在华沙召开的第 60 届 ATypI 年会上，Adobe, Apple, Google, Microsoft 4大巨头联合宣布了Variable Font 的字体规格- OpenType v1.8 。 字体分类（按 末端是否有修饰） 衬线字体（Serif），衬线指的是字形笔画末端的装饰细节部分。 无衬线字体（Sans-Serif），与衬线字体相反，完全抛弃装饰衬线，只剩下主干，造型简明有力，更具现代感，起源也很晚。适用于标题、广告，瞬间的识别性高。 字体分类（按字符宽度） 等宽字体（Monospaced Font），指字符宽度相同的计算机字体。 比例字体（Proportional Font），与等宽字体相反，字符宽度不尽相同的计算机字体。 参考 维基百科 参数化设计与字体战争：从 OpenType 1.8 说起 -Type is Beautiful 字谈字畅 082：安特卫普阿蒂皮","categories":[{"name":"design","slug":"design","permalink":"https://linlshare.github.io/categories/design/"},{"name":"typeface","slug":"design/typeface","permalink":"https://linlshare.github.io/categories/design/typeface/"}],"tags":[{"name":"字体设计","slug":"字体设计","permalink":"https://linlshare.github.io/tags/字体设计/"}]},{"title":"讀懂漢字偏旁部首","slug":"language/漢語言/字源/讀懂漢字偏旁部首","date":"2018-09-14T00:16:00.000Z","updated":"2019-01-13T11:37:46.600Z","comments":true,"path":"2018/09/14/language/漢語言/字源/讀懂漢字偏旁部首/","link":"","permalink":"https://linlshare.github.io/2018/09/14/language/漢語言/字源/讀懂漢字偏旁部首/","excerpt":"","text":"一劃 形 音 義 丨 gǔn 《說文》上下通也。 亅 jué 《說文》鉤逆者謂之亅。 丿 piě 《說文》右戾也。象左引之形。《註》戾，曲也。 乛 yǐ 同“乙”。 一 yī 《說文》惟初大始，道立於一。造分天地，化成萬物。《廣韻》數之始也，物之極也。 乙 yǐ 《說文》象春艸木冤曲而出，陰气尚彊，其出乙乙也。與丨同意。乙承甲，象人頸。 乚 háo 同“毫”。《說文》玄鳥也。齊魯謂之乚。取其鳴自呼。象形。凡乚之屬皆从乚。鳦，乙或从鳥。《註》鳦，燕子。 丶 zhǔ 《說文》有所絕止，丶而識之也。 二劃 形 音 義 八 bā 《說文》別也。象分別相背之形。 勹 bāo 《說文》裹也。象人曲形，有所包裹。 匕 bǐ 《說文》相與比敘也。从反人。匕，亦所以用比取飯，一名柶。《註》柶，古代舀取食物的礼器，像勺子，多用角做成。 冫 bīng 古同“冰”。 卜 bǔ 《說文》灼剝龜也。象炙龜之形。一曰象龜兆之縱橫也。一說是樹杈或神杖。 厂 hàn 《說文》山石之厓巖，人可居。 刀 dāo 《說文》兵也。 刂 dāo 同“刀”。 儿 ér 同“兒”。《說文》从儿，象小兒頭囟未合。 二 èr 《說文》地之數也。 匚 fāng 《說文》受物之器。 阝 fǔ 同“阜”，《說文》山無石者。《釋名》土山曰阜，言高厚也。 丷 bā 同“八” 几 jī 《說文》踞几也。《註》古人坐而凭几。 卩 jié 《說文》瑞信也。守國者用玉卪，守都鄙者用角卪… 冂 jiōng 《說文》邑外謂之郊，郊外謂之野，野外謂之林，林外謂之冂。象遠界也。 力 lì 《說文》筋也。象人筋之形。 冖 mì 《說文》覆也。从一下垂也。《註》今俗作冪。 凵 qiǎn 《說文》張口也。 人 rén 《說文》天地之性最貴者也。此籒文。象臂脛之形。 亻 rén 同“人” 入 rù 《說文》内也。象从上俱下也。《註》上下者、外中之象。 十 shí 《說文》數之具也。一爲東西，丨爲南北，則四方中央備矣。 厶 sī 《說文》姦衺也。韓非曰：“蒼頡作字，自營爲厶。”《象形字典—夜遊人》私：先有厶，也是私有的意思，这个字很直接形象，像人的臂弯，向自己怀中搂，那点像手里拿的东西，也就是把别人的东西拿到手并向自己的怀里搂据为已有。后来加“禾”，是将人们活命的稻谷搂在怀里据为已有。 亠 tóu 《字彙》徒鉤切，音頭。義闕。 匸 xì 《說文》衺徯，有所俠藏也。 讠 yán 同“言”。《說文》直言曰言，論難曰語。 廴 yǐn 《說文》長行也。 又 yòu 《說文註》手也。象形。此卽今之右字。","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"漢語言","slug":"language/漢語言","permalink":"https://linlshare.github.io/categories/language/漢語言/"},{"name":"字源","slug":"language/漢語言/字源","permalink":"https://linlshare.github.io/categories/language/漢語言/字源/"}],"tags":[{"name":"古漢語","slug":"古漢語","permalink":"https://linlshare.github.io/tags/古漢語/"}]},{"title":"Android 使用 DiffUtil 处理 RecyclerView 数据更新问题","slug":"it/android/Android 使用 DiffUtil 处理 RecyclerView 数据更新问题","date":"2018-09-13T09:33:00.000Z","updated":"2019-01-13T11:37:46.362Z","comments":true,"path":"2018/09/13/it/android/Android 使用 DiffUtil 处理 RecyclerView 数据更新问题/","link":"","permalink":"https://linlshare.github.io/2018/09/13/it/android/Android 使用 DiffUtil 处理 RecyclerView 数据更新问题/","excerpt":"","text":"背景 RecyclerView.Adapter#notifyDataSetChanged() 会每次刷新整个布局； 每次手动调用 RecyclerView.Adapter#notifyItemXx 系列方法很麻烦； 需要在新增的项目中跟旧的列表项重复时，只更新内容，而不是插入重复项。 DiffUtilDiffUtil 就是为了简化 RecyclerVeiw 更新数据操作而生。其关键类和方法如下： 类 方法 描述 DiffUtil public static DiffResult calculateDiff(Callback cb) 根据 Callback 提供的数据分析出新旧数据列表的差异，返回 DiffResult DiffUtil.Callback public abstract int getOldListSize() 返回旧数据的数量 public abstract int getNewListSize() 返回新数据的数量 public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition) 决定两个数据项是否是同一个 public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition) （当两个数据项是同一个时，）决定两个数据项的内容是否同样，或者说是否需要进行更新 DiffUtil.DiffResult public void dispatchUpdatesTo(final RecyclerView.Adapter adapter) 将差异信息更新到 RecyclerView.Adapter 中 步骤 创建一个类实现 DiffUtil.Callback ； 当新数据到来时，实例化自定义的 callback，传入新旧数据； 在子线程调用 DiffUtil#calculateDiff 计算差异； 将差异结果 DiffResult 更新到 RecyclerView.Adapter 中。 更多 使用 android.support.v7.recyclerview.extensions.ListAdapter 和 android.support.v7.recyclerview.extensions.AsyncListDiffer","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"《日語自遊行の最和味》第四課 名古屋相撲大會","slug":"language/日語/《日語自遊行の最和味》第四課 名古屋相撲大會","date":"2018-09-12T01:03:00.000Z","updated":"2019-01-13T11:37:46.591Z","comments":true,"path":"2018/09/12/language/日語/《日語自遊行の最和味》第四課 名古屋相撲大會/","link":"","permalink":"https://linlshare.github.io/2018/09/12/language/日語/《日語自遊行の最和味》第四課 名古屋相撲大會/","excerpt":"","text":"詞彙 詞 音 義 大 相撲 おお ずもう 日本相撲協會主辦的職業相撲比賽。分析：「おお」是對漢字「大」或「太」的訓讀，「すもう」是對漢字「相撲」或「角力」的訓讀。 場所 ばしょ （專指相撲的）會場；（專指相撲的）會期；地點。「ばしょ」是中文「場所」的音讀。 力士 りきし 相撲選手。「りきし」是對漢字「力士」的音讀。 体重 たいじゅう 體重。「たいじゅう」是對漢字「體重」的音讀。 大きい 高大；大氣的，大度的；誇大的；數量多的。 どのぐらい 大約多少。「どの」或「何の」，表示詢問大致的數量。「くらい」在這裡是副詞助詞，表示「大約」。","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日語自遊行の最和味","slug":"日語自遊行の最和味","permalink":"https://linlshare.github.io/tags/日語自遊行の最和味/"},{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"Axure","slug":"it/tool/Axure","date":"2018-09-11T09:07:00.000Z","updated":"2019-01-13T11:37:46.473Z","comments":true,"path":"2018/09/11/it/tool/Axure/","link":"","permalink":"https://linlshare.github.io/2018/09/11/it/tool/Axure/","excerpt":"","text":"使用第三方组件库（1）下载第三方组件库 Refs.cn 原型设计元件库，基于Axure RP 8，支持 Android、Apple、Windows、微信，移动、桌面平台的应用和网站原型设计。 http://refs.cn/rplibs （2）导入第三方组件库 打开 Axure，点击右侧的 Libraries 面板的菜单按钮，在弹框中选择 Load Library... 然后选择下载的 .rplib 格式的文件，确定即可。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Axure","slug":"Axure","permalink":"https://linlshare.github.io/tags/Axure/"},{"name":"原型设计","slug":"原型设计","permalink":"https://linlshare.github.io/tags/原型设计/"}]},{"title":"《日語自遊行の最和味》第三課 七夕","slug":"language/日語/《日語自遊行の最和味》第三課 七夕","date":"2018-09-10T15:05:00.000Z","updated":"2019-01-13T11:37:46.589Z","comments":true,"path":"2018/09/10/language/日語/《日語自遊行の最和味》第三課 七夕/","link":"","permalink":"https://linlshare.github.io/2018/09/10/language/日語/《日語自遊行の最和味》第三課 七夕/","excerpt":"","text":"對話 人 語 桜 健さん、香港 にも 七夕祭りがありますが。 健 牽牛 と織女 が 一年に一度 天の川 で デイトを する。 ごの話 は ありますが。 桜 子ども たち は 短冊に 願い事 を 書きます。 そして、笹の葉 に その短冊 を 飾ります。 健 いいですね。 私は 「日本語 が 上手に なります ように。」と書きたいです。 桜 私 は 「すてきな 出会い が ありますように。」と書きたいです。 12345桜：阿健，香港也有七夕節嗎？健：我們有牛郎和織女一年一度在銀河相會的傳說。桜：(在日本) 小孩子們把願望寫在小紙條上，然後裝飾在幼竹葉上。健：這個很不錯。我想寫「希望我的日文更加進步」。桜：我想寫「希望能遇到我的白馬王子」。 附錄 日語自遊行の最和味","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日語自遊行の最和味","slug":"日語自遊行の最和味","permalink":"https://linlshare.github.io/tags/日語自遊行の最和味/"},{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"閩南語俚語小記","slug":"language/閩南語/閩南語俚語小記","date":"2018-09-10T11:25:00.000Z","updated":"2019-01-13T11:37:46.602Z","comments":true,"path":"2018/09/10/language/閩南語/閩南語俚語小記/","link":"","permalink":"https://linlshare.github.io/2018/09/10/language/閩南語/閩南語俚語小記/","excerpt":"","text":"序號 俚語 拼音 含義 1 爱 媠 毋惊 流 鼻水 Ài-suí m̄ kiann lâu phīnn-tsuí. (女孩子)爱漂亮、就算天冷也不怕穿得少。 2 嚴官府出厚賊；嚴爸母出阿里不達 Giâm kuann-hú tshut kāu tsha̍t; giâm pē-bú tshut a-lí-put-ta̍t. 嚴格的官府反而出現很多小偷；父母太嚴格，小孩越是不成材。「阿里不達」源自被谭崔密教仿冒為男女雜交的普贤王如来（Adi-Buddha）。 3 一人煩惱一樣，無人煩惱親像 Tsi̍t lâng huân-ló tsi̍t iūnn, bô-lâng huân-ló tshin-tshiūnn. 意謂家家有本難唸的經。 4 一代親，二代表，三代毋捌了了 It tāi tshin, jī tāi piáu, sann tāi m̄ bat liáu-liáu. 姻親間的往來，一代比一代疏遠。 5 六月芥菜假有心 La̍k-gue̍h kuà-tshài ké ū sim. 形容人擅於表面功夫，裝出一副古熱心腸的樣子。 6 刣雞教猴 Thâi ke kà kâu. 罰小儆大。 7 會生得囝身，袂生得囝心 Ē senn tit kiánn sin, bē senn tit kiánn sim. 用來說明，雖然兒女是父母所生，但也有自己的意志，父母不能左右的。 8 翁親某親，老婆仔拋捙輪 Ang tshin bóo tshin, lāu-pô-á pha-tshia-lin. 夫妻二人置年邁雙親於不顧之意。 9 耳仔生兩葉，家己看袂著。 Hīnn-á senn nn̄g hio̍h, ka-kī khuànn bē tio̍h. 耳朵有兩片，自己看不見。比喻人看不到自己的缺點。 10 食雞，會起家；食鰇魚，生囡仔好育飼。 Tsia̍h ke, ē khí-ke; tsia̍h jiû-hî, senn gín-á hó io-tshī. 吃雞，會起家，吃魷魚，生孩子好養。借諧音的吉祥話，說出心中的願望。 11 飼鳥鼠，咬布袋。 Tshī niáu-tshí, kā pòo-tē. 養老鼠，咬布袋。比喻養虎為患。 12 豬頭皮炸無油。 Ti-thâu-phuê tsuànn bô iû. 揶揄人少吹牛了。 參考： 俗諺 -台灣閩南語常用詞辭典","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"閩南語","slug":"language/閩南語","permalink":"https://linlshare.github.io/categories/language/閩南語/"}],"tags":[{"name":"閩南語","slug":"閩南語","permalink":"https://linlshare.github.io/tags/閩南語/"}]},{"title":"MVP架构下解决 RxJava 自动解绑问题","slug":"it/android/MVP架构下解决 RxJava 自动解绑问题","date":"2018-09-10T09:25:00.000Z","updated":"2019-01-13T11:37:46.363Z","comments":true,"path":"2018/09/10/it/android/MVP架构下解决 RxJava 自动解绑问题/","link":"","permalink":"https://linlshare.github.io/2018/09/10/it/android/MVP架构下解决 RxJava 自动解绑问题/","excerpt":"","text":"背景MVP 模式下使用 RxJava 处理网络访问的回调，当数据返回时 Presenter 调用绑定的 View 的方法。 定义 BasePresenter 如下： 12345678910111213141516171819202122public class BasePresenter&lt;T extends MvpView&gt; implements Presenter&lt;T&gt; &#123; private T mMvpView; @Override public void attachView(T mvpView) &#123; mMvpView = mvpView; &#125; @Override public void detachView() &#123; mMvpView = null; &#125; public boolean isViewAttached() &#123; return mMvpView != null; &#125; public T getMvpView() &#123; return mMvpView; &#125;&#125; 定义 MvpView 如下： 12public interface MvpView &#123;&#125; 举一个具体的实现，有记录页为 RecordActivity，定义如下： 123456789101112131415161718192021222324252627public class RecordRecordActivity extends BaseActivity implements RecordMvpView &#123; @Inject RecordPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //... presenter.attachView(this); //... onRefresh(); &#125; public void onRefresh()&#123; presenter.queryReocrd(); &#125; @Override protected void onDestroy() &#123; presenter.detachView(); super.onDestroy(); &#125; @Override public void showRecord(List&lt;RecordResponse&gt; data) &#123; //... &#125;&#125; RecordMvpView 定义如下： 123public interface RecordMvpView extends MvpView &#123; void showRecord(List&lt;RecordResponse&gt; data);&#125; RecordPresenter 的定义如下： 12345678910111213141516171819202122232425262728293031323334public class RecordPresenter extends BasePresenter&lt;RecordMvpView&gt; &#123; private DataManager dataManager; private Disposable disposable; @Inject public RecordPresenter(DataManager dataManager) &#123; this.dataManager = dataManager; &#125; public void queryRecord(int page, int count) &#123; RxUtil.dispose(disposable); dataManager.queryRecord(page, count) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new SingleObserver&lt;List&lt;RecordResponse&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; disposable = d; &#125; @Override public void onSuccess(List&lt;RecordResponse&gt; resp) &#123; getMvpView().showRecord(resp); &#125; @Override public void onError(Throwable e) &#123; Timber.e(e); getMvpView().showRecord(null); &#125; &#125;); &#125;&#125; 以上实现具有一个重大问题，当 Activity 处于 destroy 状态时调用 onRefresh 方法去加载数据，会导致 Presenter 中处理数据返回后调用 getMvpView 方法返回 null，从而导致 NPE。抑或，在 create 状态请求的数据在未返回前 Activity 就进入了 destroy 状态从而导致 NPE。 解决方案（1）最简单的也是最复杂的解决方案在调用 getMvpView 前进行判空，即： 123if(isViewAttached())&#123; getMvpView().showRecord(resp);&#125; 是不是很简单？是的，看起来简单，其实是最复杂的，应该它需要在每个回调的地方小心翼翼地包上这层判断，工作量大还容易出错，代码也不好看。更关键的是，它到底是执行了，并没有在 View 销毁后立即停止订阅。 （2）使用第三方库 RxLifecycle 或 AutoDispose这两个都是较出名的用于解决 RxJava 与Android 生命周期问题的第三方库。可以自行 Github 一下。 RxLifecycle This library allows one to automatically complete sequences based on a second lifecycle stream. This capability is useful in Android, where incomplete subscriptions can cause memory leaks. 该库允许在接收到第二个生命周期流时自动结束订阅。 此种能力对于解决因未完成的订阅导致的Android 内存泄漏问题很有用。 RxLifecycle 的局限性： 需要继承自 RxActivity 或 RxFragment 等； 其核心步骤需要 RxActivity 或 RxFragment 的引用。 1.compose(this.&lt;T&gt;bindUntilEvent(ActivityEvent.PAUSE)) AutoDispose AutoDispose is an RxJava 2 tool for automatically binding the execution of RxJava 2 streams to a provided scope via disposal/cancellation. AutoDispose 是 RxJava2 中的一款工具，能通过解绑或取消操作，使得 RxJava2 流执行到在给定的域中为止。 其受 RxLifecycle 启发。 优势： 将生命周期相关的从 Activity 或 Fragment 中分离出来，独立成 LifecycleOwner，可扩展。 （3）结合项目情况自定义解决方案RxLifecycle 的原理是： BehaviorSubject 在订阅后会发送前一个数据值； ObservableTransformer、SingleTransformer 等等可以对整个流进行操作； takeUntil 操作符可以在第二个被观察者发送事件时自动停止订阅。 结合 MVP 架构和 RxLifecycle 的原理，我的解决方案是： 使用 BehaviorSubject 发送 View 的绑定情况； 在所有跟 View 相关的流中使用 compose 操作符，compose 一个自定义的 LifecycleTransformer 操作整个流，使用 takeUntil 操作符在观察到 BehaviorSubject 发送解绑消息后使用停止订阅。 具体代码实现如下： BasePresenter 修改为： 123456789101112131415161718192021222324252627282930313233343536373839404142public class BasePresenter&lt;T extends MvpView&gt; implements Presenter&lt;T&gt; &#123; private T mMvpView; private CompositeDisposable compositeDisposable = new CompositeDisposable(); private BehaviorSubject&lt;Boolean&gt; behaviorSubject = BehaviorSubject.createDefault(false); @Override public void attachView(T mvpView) &#123; mMvpView = mvpView; behaviorSubject.subscribe(); behaviorSubject.onNext(true); // TRUE 表示 View 绑定了 &#125; @Override public void detachView() &#123; mMvpView = null; behaviorSubject.onNext(false); // FALSE 表示 View 解绑了 compositeDisposable.clear(); &#125; public void addDisposable(Disposable... disposables) &#123; for (Disposable d : disposables) &#123; compositeDisposable.add(d); &#125; &#125; protected void deleteDispoable(Disposable disposable) &#123; compositeDisposable.delete(disposable); &#125; protected &lt;R&gt; LifecycleTransformer&lt;R&gt; bindLifeCycle() &#123; return new LifecycleTransformer&lt;&gt;(behaviorSubject, this); &#125; public boolean isViewAttached() &#123; return mMvpView != null; &#125; public T getMvpView() &#123; return mMvpView; &#125;&#125; 其中 LifecycleTransformer 定义为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public final class LifecycleTransformer&lt;T&gt; implements ObservableTransformer&lt;T, T&gt;, SingleTransformer&lt;T, T&gt;, MaybeTransformer&lt;T, T&gt;, CompletableTransformer &#123; private final Observable&lt;Boolean&gt; observable; private BasePresenter presenter; public LifecycleTransformer(Observable&lt;Boolean&gt; observable, BasePresenter presenter) &#123; this.observable = observable; this.presenter = presenter; &#125; @Override public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; upstream) &#123; return upstream.takeUntil(getFilterFalseObservable()) //当收到 View 解绑消息时自动解除订阅 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe(disposable -&gt; &#123; if (!presenter.isViewAttached()) &#123; // 当订阅时，若 View 解绑则自动解除订阅 Timber.v(\"dispose\"); disposable.dispose(); return; &#125; presenter.addDisposable(disposable); &#125;); &#125; @Override public SingleSource&lt;T&gt; apply(Single&lt;T&gt; upstream) &#123; return upstream.takeUntil(getFilterFalseObservable().firstOrError()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe(disposable -&gt; &#123; if (!presenter.isViewAttached()) &#123; Timber.v(\"dispose\"); disposable.dispose(); return; &#125; presenter.addDisposable(disposable); &#125;); &#125; @Override public CompletableSource apply(Completable upstream) &#123; return Completable.ambArray(upstream, getFilterFalseObservable().flatMapCompletable(CANCEL_COMPLETABLE)) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe(disposable -&gt; &#123; if (!presenter.isViewAttached()) &#123; Timber.v(\"dispose\"); disposable.dispose(); return; &#125; presenter.addDisposable(disposable); &#125;); &#125; @Override public MaybeSource&lt;T&gt; apply(Maybe&lt;T&gt; upstream) &#123; return upstream.takeUntil(getFilterFalseObservable().firstElement()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe(disposable -&gt; &#123; if (!presenter.isViewAttached()) &#123; Timber.v(\"dispose\"); disposable.dispose(); return; &#125; presenter.addDisposable(disposable); &#125;); &#125; private Observable&lt;Boolean&gt; getFilterFalseObservable() &#123; return observable.filter(aBoolean -&gt; !aBoolean); &#125; private static final Function&lt;Object, Completable&gt; CANCEL_COMPLETABLE = ignore -&gt; Completable.error(new CancellationException());&#125; 这样原先的 RecordPresenter 就可以修改为： 123456789101112131415161718192021222324252627public class RecordPresenter extends BasePresenter&lt;RecordMvpView&gt; &#123; private DataManager dataManager; @Inject public RecordPresenter(DataManager dataManager) &#123; this.dataManager = dataManager; &#125; public void queryRecord(int page, int count) &#123; dataManager.queryRecord(page, count) .compose(bindLifeCycle()) // 关键代码 .subscribe(new LifecycleSingleObserver&lt;List&lt;RecordResponse&gt;&gt;() &#123; @Override public void onSuccess(List&lt;RecordResponse&gt; resp) &#123; Timber.i(\"onSuccess --------------\"); getMvpView().showRecord(resp); &#125; @Override public void onError(Throwable e) &#123; Timber.i(e, \"onError --------------\"); getMvpView().showRecord(null); &#125; &#125;); &#125;&#125; 其中 LifecycleSingleObserver 是为了简化 SingleObserver 引入的，定义如下： 12345public abstract class LifecycleSingleObserver&lt;T&gt; implements SingleObserver&lt;T&gt; &#123; @Override public void onSubscribe(Disposable d) &#123; &#125;&#125; 至此，关于订阅的绑定及生命周期的问题已经在基类进行解决，具体使用时的代码大大简化（至少少了 5 行代码），只需加上一句 .compose(bindLifeCycle()) 即可。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"《日語自遊行の最和味》第二課 梅雨季節結束","slug":"language/日語/《日語自遊行の最和味》第二課 梅雨季節結束","date":"2018-09-10T01:00:00.000Z","updated":"2019-01-13T11:37:46.590Z","comments":true,"path":"2018/09/10/language/日語/《日語自遊行の最和味》第二課 梅雨季節結束/","link":"","permalink":"https://linlshare.github.io/2018/09/10/language/日語/《日語自遊行の最和味》第二課 梅雨季節結束/","excerpt":"","text":"對話 人 語 桜 今日 は いい お天気 ですね。 健 そろそろ 梅雨明け ですが。 桜 ええ、そろそろ ですね。 健 今、日本中、梅雨 です が。 桜 ええ、梅雨明けの時期は 違いますが。 健 そうですが。 ああ、北海道 へ 行きたい です。 123456桜：今天天氣不錯喲。健：梅雨季節該結束了吧？桜：嗯，差不多了吧。健：現在整個日本都是梅雨天氣嗎？桜：是的，而且梅雨季節結束的時間（各地）也不同，除了北海道是沒有梅雨季節的。健：這樣啊，好想去北海道。 附錄 日語自遊行の最和味 《日語自遊行の最和味》第二課 梅雨季節結束.pdf","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日語自遊行の最和味","slug":"日語自遊行の最和味","permalink":"https://linlshare.github.io/tags/日語自遊行の最和味/"},{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"閩南語拼音方案","slug":"language/閩南語/閩南語拼音方案","date":"2018-09-08T13:54:00.000Z","updated":"2019-01-13T11:37:46.602Z","comments":true,"path":"2018/09/08/language/閩南語/閩南語拼音方案/","link":"","permalink":"https://linlshare.github.io/2018/09/08/language/閩南語/閩南語拼音方案/","excerpt":"","text":"閩語拼音方案種種 名稱 簡稱 特征 發佈情況 白话字 POL 白话字是历史最为悠久的拉丁化方案，因此广泛流通于全球各地的闽南语流通地区。 17世紀文獻中，如英國人與鄭氏王朝通商的商館紀錄中，便存在以羅馬字母拼寫閩南語語音的「白話字」雛型。1850年，教會正式推行白話文。 臺灣語言音標方案 TLPA 內含臺灣閩南語音標系統、臺灣客家語音標系統、臺灣原住民語音標系統等三套系統。 台灣語文學會於1991年期間針對臺灣語言所制定的音標系統。 台灣闽南语罗马字拼音方案 TL 与白话字的相容性良好，可以视为白话字的增补或发展上的分支。在台湾，使用白话字的社群有较高的意愿使用台罗拼音，同时，在官方地位方面台罗拼音方案取代了TLPA。 2006年10月14日，台灣教育部正式發佈。 台語通用拼音方案 DT 與漢語拼音相容。目的在於統一華語、客語和閩語的拼音系統。 暫無相關資訊 闽南方言拼音方案 BP 與漢語拼音相容，并參考《汇集雅俗通十五音》，基於廈門口音。 另称“《普闽典》方案”来自于1982年10月厦门大学主编的《普通话闽南方言词典》一书。 臺羅系統和通用拼音之爭 臺羅系統和通用拼音最大的爭執在於國際上普遍使用的濁音符號 b, d , g 要標示濁音，還是不送氣清音的問題。這個爭執，如果要考慮音標符號的普遍性，就變成可以討論的問題。 世界上沒有濁音的語言不多，世界上沒有濁音卻有送氣音的語言很少，華語正好是這種罕見的語言。世界上大部分的語言都是清濁音二元對立，華語沒有濁音卻有送氣音，一樣是二元對立，因此漢語拼音就把濁音符號 b, d, g 用來標示不送氣清音，而把清音符號用來標示送氣清音，這在中國本位立場雖然可行，卻違背了世界通用拼音的習慣。在中國境內，不但是北京話，即連其他有濁音的漢語也都遵從這個系統而修補，但這種系統只能在中國通行，可以說是中國通用拼音系統(簡稱C系統)，和世界通用的拼音系統(簡稱W系統)是不相容的。這一點從下表即可了解。 — 引自《臺語拼音論戰簡史》 在台通拼音方案中，任一音节若用某个在台罗拼音已经采用的拼写法，则此音节在台通拼音中之拼写法亦相同、或有一等式符号与之对应。意即台通拼音与台罗拼音在拼音的结构上具有完全的相容性。 — 引自《臺語通用拼音-維基百科》 台灣闽南语罗马字拼音方案閩南語的音節結構閩南語是漢語的一種，因此音節結構也一樣可以區分為五個音位成分：聲母、韻頭（介音）、韻腹、韻尾、聲調。韻頭、韻腹、韻尾又合稱為韻母。閩南語有變調，而台羅方案和白話字一樣，都只標示本調，且採用變音符號來標示聲調，稱為調號或調符。 聲母台灣閩南語的聲母有十八個音位，其中「零聲母」並非沒有聲母，而是喉塞音，漢字是TLPA方案所建議的，除了「毛、耐、雅」之外，大多為傳統十五音。零聲母「英」不標。 台灣閩南語的塞音及塞擦音，分成了清送氣音、清不送氣音、鼻濁音三重對立。這也是通用拼音與臺羅拼音爭論的源頭。 韻母 聲調閩語有八音，普通腔沒有第六音（陽上音）。 傳統調類 陰平 陰上 陰去 陰入 陽平 陽上 陽去 陽入 台羅 a á à ah â ǎ ā a̍h 例字 東 黨 棟 督 同 動 洞 毒 IPA調符（以高雄腔為主） ˦˦ ˥˧ ˨˩ ˧˨ ˨˦ ˧˧（鹿港腔） ˧˧ ˦ 其脫胎自 IPA 中聲調，并合二調符為一符，基本符合聲調的走向。第四調和第八調另加 h 或 k 表示入音。 調號標識當一個音節有多個字母時，調號應該標示在響度（sonority）最大的字母上面（通常在韻腹）。由規則可以判定確切的字母： 響度優先順序： a &gt; oo &gt; e = o &gt; i = u〈低元音 &gt; 高元音 &gt; 無擦通音 &gt; 擦音 &gt; 塞音〉 iu 及 ui ，調號都標在後一個字母，因為前一個字母是介音。 m 作韻腹時標於 m 上。 雙字母 oo 及 ng，標於前一個字母。 三字母 ere，標於最後的 e。 參考 臺灣閩南語羅馬字拼音方案 –維基百科 台灣閩南語常用詞辭典","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"閩南語","slug":"language/閩南語","permalink":"https://linlshare.github.io/categories/language/閩南語/"}],"tags":[{"name":"閩南語","slug":"閩南語","permalink":"https://linlshare.github.io/tags/閩南語/"}]},{"title":"IDEA","slug":"it/tool/IDEA","date":"2018-09-07T09:38:00.000Z","updated":"2019-01-13T11:37:46.482Z","comments":true,"path":"2018/09/07/it/tool/IDEA/","link":"","permalink":"https://linlshare.github.io/2018/09/07/it/tool/IDEA/","excerpt":"","text":"查看某个类的 javadoc 的快捷键？在该类旁边敲击 ctrl + j 。 按日志级别显示不同颜色并可自定义过滤规则安装插件 grep console，并自定义颜色。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://linlshare.github.io/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://linlshare.github.io/tags/编辑器/"}]},{"title":"Vim","slug":"it/tool/Vim","date":"2018-09-05T11:42:00.000Z","updated":"2019-01-13T11:37:46.486Z","comments":true,"path":"2018/09/05/it/tool/Vim/","link":"","permalink":"https://linlshare.github.io/2018/09/05/it/tool/Vim/","excerpt":"","text":"Vim 剪贴板如何与系统剪贴板交互？“+y 把选中内容拷贝到”+号剪贴板，即系统剪贴板。 “+p 把系统剪贴板的内容粘贴到vim。 Vim 中的剪贴板历史可以使用 :reg 进行罗列，并配合以上操作进行粘贴。 如何连接两行文字？在 Vim 中你可以把两行连起来这意味着删除两行间的换行符。”J” 命令用于完成这个功能。以下面两行为例: 12A young intelligentturtle 把光标移到第一行，然后按 “J”: 1A young intelligent turtle 如何进行列块选择？使用 Ctrl + v 进入列块选择模式。 如何快速查找和替换？快速进行查找可以在命令模式下，使用 /{regex}，Vim 中的正则有点特殊（详细规则可以阅读文末附件，最明显的就是括号也需要转义），举个例子，有文字材料如下： 123java.lang.NullPointerException...java.lang.ClassNotFoundException 要求查找到所有 Exception，那么可以使用 1/\\.\\a*Exception 再配合 n 继续查找。 如何进行重做？使用 Ctrl + r 进行重做。 如何记录和回放我的可重复性操作？要点：使用 q{register} 和 @{register} “.” 命令重复前一个修改操作。但如果你需要作一些更复杂的操作它就不行了。这时，记录命令就变得很有效。这需要三个步骤: “q{register}” 命令启动一次击键记录，结果保存到 {register} 指定的寄存器中。寄存器名可以用 a 到 z 中任一个字母表示。 输入你的命令。 键入 q (后面不用跟任何字符) 命令结束记录。 现在，你可以用 “@{register}” 命令执行这个宏。现在看看你可以怎么用这些命令。假设你有如下文件名列表: 1234stdio.hfcntl.hunistd.hstdlib.h 而你想把它变成这样:1234include &quot;stdio.h&quot;include &quot;fcntl.h&quot;include &quot;unistd.h&quot;include &quot;stdlib.h&quot; 先移动到第一行，接着执行如下命令: 1234567qa 启动记录，并使用寄存器 a^ 移到行首i#include &quot; 在行首输入 #include &quot;$ 移到行末a&quot; 在行末加上双引号 (&quot;)j 移到下一行q 结束记录 现在，你已经完成一次复杂的修改了。你可以通过重复三次 “@a” 完成余下的修改。“@a” 命令可以通过计数前缀修饰，使操作重复指定的次数。在本例中，你可以输入: 13@a 如何进行查找替换？:s（substitute）命令用来查找和替换字符串。语法如下： 1:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125; 例如:%s/foo/bar/g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）。 Vim 中正则的 magic123456# 设置magic :set magic # 取消magic :set nomagic # 查看帮助:h magic 帮助文档如下： 123456789101112131415161718192021222324252627282930313233343536373. Magic */magic*Some characters in the pattern are taken literally. They match with the samecharacter in the text. When preceded with a backslash however, thesecharacters get a special meaning.Other characters have a special meaning without a backslash. They need to bepreceded with a backslash to match literally.If a character is taken literally or not depends on the &apos;magic&apos; option and theitems mentioned next. */\\m* */\\M*Use of &quot;\\m&quot; makes the pattern after it be interpreted as if &apos;magic&apos; is set,ignoring the actual value of the &apos;magic&apos; option.Use of &quot;\\M&quot; makes the pattern after it be interpreted as if &apos;nomagic&apos; is used. */\\v* */\\V*Use of &quot;\\v&quot; means that in the pattern after it all ASCII characters except&apos;0&apos;-&apos;9&apos;, &apos;a&apos;-&apos;z&apos;, &apos;A&apos;-&apos;Z&apos; and &apos;_&apos; have a special meaning. &quot;very magic&quot;Use of &quot;\\V&quot; means that in the pattern after it only the backslash and theterminating character (/ or ?) has a special meaning. &quot;very nomagic&quot;Examples:after: \\v \\m \\M \\V matches ~ &apos;magic&apos; &apos;nomagic&apos; $ $ $ \\$ matches end-of-line . . \\. \\. matches any character * * \\* \\* any number of the previous atom ~ ~ \\~ \\~ latest substitute string () \\(\\) \\(\\) \\(\\) grouping into an atom | \\| \\| \\| separating alternatives \\a \\a \\a \\a alphabetic character \\\\ \\\\ \\\\ \\\\ literal backslash \\. \\. . . literal dot \\&#123; &#123; &#123; &#123; literal &apos;&#123;&apos; a a a a literal &apos;a&apos;&#123;only Vim supports \\m, \\M, \\v and \\V&#125; 删除指定行12# 删除1到10行:1,10d 参考 Vim 用户使用手册 在 Vim 中优雅地查找和替换 - harttle.land","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"https://linlshare.github.io/tags/编辑器/"},{"name":"Vim","slug":"Vim","permalink":"https://linlshare.github.io/tags/Vim/"}]},{"title":"《日語自遊行の最和味》第一課 秋葉原","slug":"language/日語/《日語自遊行の最和味》第一課 秋葉原","date":"2018-09-05T00:59:00.000Z","updated":"2019-01-13T11:37:46.587Z","comments":true,"path":"2018/09/05/language/日語/《日語自遊行の最和味》第一課 秋葉原/","link":"","permalink":"https://linlshare.github.io/2018/09/05/language/日語/《日語自遊行の最和味》第一課 秋葉原/","excerpt":"","text":"對話桜：秋葉原 は 日本最大 の 電気街です。 でも、今 は 「オタク」で 有名です。 1秋葉原是日本最大的電器街。但是，現在卻以[御宅族]出名。 健：そです よね。 秋葉原 は 若い人 の 新しい 観光名所 です よね。 1說的正是啊。秋葉原是年輕人的新觀光勝地哦。 桜：香港 でわ 「電車男」で 有名 です。 1在香港，(御宅族)以[電車男]聞名。 健：若い 観光客 は お寺 や 神社 へ 行きません ね。 1年輕一輩的遊客是不會到寺廟呀、神社呀這些地方去的。 桜：アキバグッズ を 買い、 コスペレ を 見、 メイドカフェ へ 行く…。 1(他們)買秋葉原紀念品，看 cosplay，去俏女僕咖啡店。 健：本当 ですよね。 1你說的一點都沒錯啊。 附錄 日語自遊行の最和味 《日語自遊行の最和味》第一課 秋葉原.pdf","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日語自遊行の最和味","slug":"日語自遊行の最和味","permalink":"https://linlshare.github.io/tags/日語自遊行の最和味/"},{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"日語五十音考","slug":"language/日語/日語五十音考","date":"2018-09-04T15:33:00.000Z","updated":"2019-01-13T11:37:46.594Z","comments":true,"path":"2018/09/04/language/日語/日語五十音考/","link":"","permalink":"https://linlshare.github.io/2018/09/04/language/日語/日語五十音考/","excerpt":"","text":"歷史 公元 5 世紀，正值中國東晉時期（317~420），日本古墳時代（300~600），僧侶們東渡日本，漢字傳播到了日本。 公元 8 世紀，正值中國唐朝（618~907），《萬葉集》依據漢字草書，造出萬葉假名，表漢字之音，為女性所用。明治時代，日本政府根據萬葉假名確定出現今使用的平假名。 平安時代（794~1185）初，也就是公元 8 世紀末，為了訓讀漢字，發明了片假名。初始時，一音可以對應多個片假名。到明治時代，日本政府確定了一音一片的對應規則。 「訓讀」與「音讀」 「訓讀」：借用漢字的形意，而用日本原有語音。如：秋(あき) 「音讀」：模仿漢字之音。如：新年 (しんねん ) 結論： 當時傳入日本的是中古漢語（魏晋南北朝、隋、唐、宋），音韻體系跟如今的普通話、閩南語、吳語、粵語、客家話都有差別。中古漢語的音韻可以通過研究《切韻》和《廣韻》略知一二。 平假名先於片假名。平假名的研究重點在於表音；片假名的研究重點在於表意。 選用同一漢字作為參照的平假名和片假名 序號 平假名 片假名 漢字 1 う ウ 宇 2 お オ（疑是對平假名的簡化） 於 3 か カ 加 4 き キ 幾（一說為機） 5 く ク 久 6 こ コ 己 7 し シ 之 8 せ セ 世 9 そ ソ 曾（或其異體字「曽」） 10 つ ツ 川 11 て テ 天 12 と ト 止 13 な ナ 奈 14 に ニ 仁 15 ぬ ヌ 奴 16 ね ネ 祢（mí） 17 の ノ 乃 18 ひ ヒ 比 19 ふ フ 不 20 へ ヘ（就是平假名） 部 21 ほ ホ 保 22 ま マ 末 23 み ミ 美 24 め メ 女 25 も モ 毛 26 や ャ 也 27 ゆ ュ 由 28 よ ョ 與 29 ら ラ 良 30 り（疑是從片假名來） リ 利 31 れ レ 礼 32 ろ ロ 呂 33 わ ヮ（疑是對平假名的簡化） 和 結論： 現代日語有 45 音，其中 33 音的平假名和片假名來自同一漢字，佔比 73.33%。 七成以上片假名來自對原有平假名來源的漢字的楷書結構的抽取。 發音近似閩南語的平假名 序號 平假名 羅馬拼音 漢字 閩南語羅馬拼音 1 あ a 安 an 2 い i 以 í 3 う u 宇 ú 4 か ka 加 ka 5 き ki 幾 kí 6 く ku 久 kú 7 け ke 計 kè 8 せ se 世 sè 9 び bi 比 pí 10 ぼ bo 保 pó 11 み mi 美 bí 12 も mo 毛 moo 13 や ya 也 iā 14 ゆ yu 由 iû 15 り ri 利 lī 結論： 現代日語有 45 音，其中有 15 音近似閩南語發音，佔比 1/3。 傳入日本的漢語為中古漢語，而現代日語中仍保留了大量中古發音，且與現代閩南語有 1/3 近似的事實，說明了現代閩南語較好地保留了許多中古漢語的發音。 附錄 平假名-草書漢字對應表 片假名-楷書漢字對應表","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"Android 打包时 Keep 住某些方法或类","slug":"it/android/Android 打包时 Keep 住某些方法或类","date":"2018-09-04T09:07:00.000Z","updated":"2019-01-13T11:37:46.363Z","comments":true,"path":"2018/09/04/it/android/Android 打包时 Keep 住某些方法或类/","link":"","permalink":"https://linlshare.github.io/2018/09/04/it/android/Android 打包时 Keep 住某些方法或类/","excerpt":"","text":"1234567891011121314151617# $&#123;android_sdk&#125;/tools/proguard/proguard-android.txt# Understand the @Keep support annotation.-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; 12345678910111213141516171819// android/support/annotation/Keep.java/** * Denotes that the annotated element should not be removed when * the code is minified at build time. This is typically used * on methods and classes that are accessed only via reflection * so a compiler may think that the code is unused. * &lt;p&gt; * Example: * &lt;pre&gt;&lt;code&gt; * @Keep * public void foo() &#123; * ... * &#125; * &lt;/code&gt;&lt;/pre&gt; */@Retention(CLASS)@Target(&#123;PACKAGE,TYPE,ANNOTATION_TYPE,CONSTRUCTOR,METHOD,FIELD&#125;)public @interface Keep &#123;&#125; // https://www.guardsquare.com/en/products/proguard/manual/usage File filters Like general filters, a file filter is a comma-separated list of file names that can contain wildcards. Only files with matching file names are read (in the case of input jars), or written (in the case of output jars). The following wildcards are supported: ? matches any single character in a file name. * matches any part of a filename not containing the directory separator. \\ matches any part of a filename, possibly containing any number of directory separators. For example, “java/**.class,javax/**.class“ matches all class files in the java and javax. Furthermore, a file name can be preceded by an exclamation mark ‘!‘ to exclude the file name from further attempts to match with subsequent file names. For example, “!**.gif,images/**“ matches all files in the images directory, except gif files. Class specifications A class specification is a template of classes and class members (fields and methods). It is used in the various -keep options and in the -assumenosideeffects option. The corresponding option is only applied to classes and class members that match the template. The template was designed to look very Java-like, with some extensions for wildcards. To get a feel for the syntax, you should probably look at the examples, but this is an attempt at a complete formal definition: 123456789101112[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname][&#123; [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; | (fieldtype fieldname); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; | &lt;init&gt;(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ...&#125;] Square brackets “[ ]” mean that their contents are optional. Ellipsis dots “…” mean that any number of the preceding items may be specified. A vertical bar “|” delimits two alternatives. Non-bold parentheses “()” just group parts of the specification that belong together. The indentation tries to clarify the intended meaning, but white-space is irrelevant in actual configuration files. The class keyword refers to any interface or class. The interface keyword restricts matches to interface classes. The enum keyword restricts matches to enumeration classes. Preceding the interface or enum keywords by a ! restricts matches to classes that are not interfaces or enumerations, respectively. Every classname must be fully qualified, e.g. java.lang.String.Inner classes are separated by a dollar sign “\\$”, e.g. java.lang.Thread$State . Class names may be specified as regular expressions containing the following wildcards: | ? | matches any single character in a class name, but not the package separator. For example, “com.example.Test?“ matches “com.example.Test1“ and “com.example.Test2“, but not “com.example.Test12“. || ——- | ———————————————————— || * | matches any part of a class name not containing the package separator. For example, “com.example.*Test*“ matches “com.example.Test“ and “com.example.YourTestApplication“, but not “com.example.mysubpackage.MyTest“. Or, more generally, “com.example.*“ matches all classes in “com.example“, but not in its subpackages. || \\ | matches any part of a class name, possibly containing any number of package separators. For example, “**.Test“ matches all Test classes in all packages except the root package. Or, “com.example.**“ matches all classes in “com.example“ and in its subpackages. || | matches the n‘th matched wildcard in the same option. For example, “com.example.*Foo&lt;1&gt;“ matches “com.example.BarFooBar“. | For additional flexibility, class names can actually be comma-separated lists of class names, with optional ! negators, just like file name filters. This notation doesn’t look very Java-like, so it should be used with moderation. For convenience and for backward compatibility, the class name * refers to any class, irrespective of its package.","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"伊呂波歌","slug":"language/日語/伊呂波歌","date":"2018-09-03T15:00:00.000Z","updated":"2019-01-13T11:37:46.593Z","comments":true,"path":"2018/09/03/language/日語/伊呂波歌/","link":"","permalink":"https://linlshare.github.io/2018/09/03/language/日語/伊呂波歌/","excerpt":"","text":"いろは歌朗讀 📣 漢字與假名 發音 漢譯 色は匂へど Iro wa nioedo （花的）颜色与芳香 散りぬるを Chirinuru o （最终）会消散， 我が世誰ぞ Wa ga yo dare zo 我们这个世上谁 常ならん Tsune naran 都不能常驻不变； 有為の奥山 Ui no okuyama 有为的深山 今日越えて Kyō koete 在今天越过， 浅き夢見じ Asaki yume miji 不做肤浅的梦， 酔ひもせず Yoi mo sezu 也不再沉醉。 參考 伊呂波歌 【日语阅读】一緒に読みましょう！ 第14期 伊呂波歌","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"日語","slug":"language/日語","permalink":"https://linlshare.github.io/categories/language/日語/"}],"tags":[{"name":"日语","slug":"日语","permalink":"https://linlshare.github.io/tags/日语/"}]},{"title":"使用 RxJava 进行嵌套串行网络请求的一种方法","slug":"it/android/使用 RxJava 进行嵌套串行网络请求的一种方法","date":"2018-09-03T12:15:00.000Z","updated":"2019-01-13T11:37:46.364Z","comments":true,"path":"2018/09/03/it/android/使用 RxJava 进行嵌套串行网络请求的一种方法/","link":"","permalink":"https://linlshare.github.io/2018/09/03/it/android/使用 RxJava 进行嵌套串行网络请求的一种方法/","excerpt":"","text":"需求有这样一个列表数据，它包含了商店+订单的信息，获取订单列表时，订单实体中会包含商店的 ID，而列表显示时需要商店的名称和 logo，这时候就需要进行嵌套串行网络请求了。 关键词flatMap 、缓存 、Retrofit、RxJava 动手（1）使用 Retrofit 定义网络接口1234567// RemoteService.java// 请求订单信息@POST(\"/order/v1/order_history\")Single&lt;List&lt;OrderResponse&gt;&gt; queryOrderList(@Body FetchOrderHistoryRequest request);// 请求商店信息@POST(\"/store/v1/store_query\")Single&lt;StoreResponse&gt; queryStore(@Body StoreQueryRequest request); （2）使用 DataManager 管理数据12345678910111213141516171819202122232425262728// DataManager.java// 请求订单信息public Single&lt;List&lt;OrderResponse&gt;&gt; queryOrderList(String status) &#123; FetchOrderHistoryRequest request = new FetchOrderHistoryRequest(); request.setStatus(status); return mRemoteService.queryOrderList(request);&#125;// 请求商店信息，并缓存 5min，如果不作缓存可能导致多次重复请求同一数据public static final int DEFAULT_CACHE_TIME_MILLIS = 5 * 60 * 1000; // 5minpublic Single&lt;StoreResponse&gt; queryStore(String storeId) &#123; String storeKey = PrefConstant.getStoreKey(storeId); String storeJson = mMemberPref.getString(storeKey, null); Single&lt;StoreResponse&gt; storeSingle; if (!TextUtils.isEmpty(storeJson)) &#123; storeSingle = Single.just(Json.fromJson(storeJson, StoreResponse.class)); &#125; else &#123; StoreQueryRequest request = new StoreQueryRequest(); request.setId(storeId); storeSingle = mRemoteService.queryStore(request) .doOnSuccess(storeResponse -&gt; mMemberPref.put(storeKey, Json.toJson( storeResponse), DEFAULT_CACHE_TIME_MILLIS)); &#125; return storeSingle;&#125; 注： mMemberPref 是我写的一个使用 SharedPreferences 进行数据缓存的类，详情查看 Pref.java （3）多次FlatMap123456789101112131415161718192021222324252627282930313233343536dataManager.queryOrderList(status) .flatMapObservable((Function&lt;List&lt;OrderResponse&gt;, ObservableSource&lt;OrderResponse&gt;&gt;) Observable::fromIterable) .flatMap((Function&lt;OrderResponse, ObservableSource&lt;OrderHolder&gt;&gt;) orderResponse -&gt; &#123; OrderHolder orderHolder = new OrderHolder(); orderHolder.setOrder(orderResponse); return dataManager.queryStore(orderResponse.getStoreId()) .flatMapObservable((Function&lt;StoreResponse, ObservableSource&lt;OrderHolder&gt;&gt;) storeResponse -&gt; &#123; orderHolder.setStore(storeResponse); return Observable.just(orderHolder); &#125;); &#125;) .toList() .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .subscribe(new SingleObserver&lt;List&lt;OrderHolder&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; disposable = d; &#125; @Override public void onSuccess(List&lt;OrderHolder&gt; orderHolders) &#123; if (orderHolders != null &amp;&amp; !orderHolders.isEmpty()) &#123; getMvpView().showOrderList(orderHolders); &#125; else &#123; getMvpView().showEmpty(); &#125; &#125; @Override public void onError(Throwable e) &#123; Timber.e(e); getMvpView().showError(); &#125; &#125;); &#125; 说明： 第一次 flatMapObservable ，将 List&lt;OrderResponse&gt; 转为 ObservableSource&lt;OrderResponse&gt;； 第二次 flatMap，将 OrderResponse 转为 ObservableSource&lt;OrderHolder&gt;； 第三次 flatMapObservable ，将 StoreResponse 合并到 OrderHolder，再转为ObservableSource&lt;OrderHolder&gt;。","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"《古代漢語》上一·常用字","slug":"language/漢語言/古代漢語/《古代漢語》上一·文選","date":"2018-08-30T15:31:00.000Z","updated":"2019-01-13T11:37:46.599Z","comments":true,"path":"2018/08/30/language/漢語言/古代漢語/《古代漢語》上一·文選/","link":"","permalink":"https://linlshare.github.io/2018/08/30/language/漢語言/古代漢語/《古代漢語》上一·文選/","excerpt":"","text":"本文選自《左傳》，《左傳》是一部編年體+經傳體，以魯國歷代君王為時間線，記錄當時的人和事。有觀點認為《左傳》是以《春秋》為藍本的，也有人不以為然。 一、鄭伯克段于鄢概述鄭伯莊公和共叔段，一兄一弟，其母姜氏偏愛共叔段。及莊公立，莊公放任姜氏和共叔段在京這個地方高筑墻并侵吞邊境地區，等到預謀與姜氏裡應外合襲擊鄭時才發兵攻打共叔段，將其趕出了京、鄢地區，將姜氏軟禁于穎，發誓永不相見。後後悔，經潁考叔出謀，闕地及泉，使母子如初。 原文初，鄭武公娶于申，曰武姜，生莊公及共叔段。莊公寤生，驚姜氏，故名曰「寤生」，遂惡之。愛共叔段，欲立之。亟請于武公，公弗許。及莊公即位，為之請制。公曰：「制，巖邑也，虢叔死焉，佗邑唯命。」請京，使居之，謂之京城大叔。祭仲曰：「都城過百雉，國之害也。先王之制，大都不過參國之一，中五之一，小九之一。今京不度，非制也，君將不堪。」公曰：「姜氏欲之，焉辟害？」對曰：「姜氏何厭之有？不如早為之所，無使滋蔓！蔓，難圖也。蔓草猶不可除，況君之寵弟乎？」公曰：「多行不義，必自斃，子姑待之。」 12345678寤--&gt; 《註》遌生也。遌，逆也。杜預曰：寤寐而莊公生。《風俗通》凡兒墮地，能開目視者，謂之寤生。亟 --&gt;jí《說文》从人从口从又从二。二，天地也。《徐鍇曰》承天之時，因地之利，口謀之，手執之，時不可失，疾之意也。--&gt;qì 屡次。雉--&gt; 《註》方丈曰堵，三堵曰雉。一雉之牆，長三丈，高一丈。--&gt; 《維基百科》周 1丈=10尺, 1尺=10寸, 1寸=10分（前期：1尺=19.7厘米；後期：1尺=24.63厘米） 既而大叔命西鄙、北鄙貳於己。公子呂曰：「國不堪貳，君將若之何？欲與大叔，臣請事之；若弗與，則請除之。無生民心。」公曰：「無庸，將自及。」大叔又收貳以為己邑，至于廩延。子封曰：「可矣，厚將得眾。」公曰：「不義不暱，厚將崩。」大叔完聚，繕甲兵，具卒乘，將襲鄭，夫人將啟之。公聞其期，曰：「可矣！」命子封帥車二百乘以伐京。京叛大叔段，段入于鄢，公伐諸鄢。五月辛丑，大叔出奔共。 123456鄙--&gt; bǐ《註》鄙，鄭邊邑。貳--&gt; 《註》貳，兩屬也。暱--&gt; nì《說文》日近也。《類篇》親也。《傳》暱，近也。 書曰：「鄭伯克段于鄢。」段不弟，故不言弟；如二君，故曰克；稱鄭伯，譏失教也：謂之鄭志。不言出奔，難之也。 遂寘姜氏于城穎，而誓之曰：「不及黃泉，無相見也。」既而悔之。 12寘--&gt; zhì《說文》置也。 潁考叔為潁谷封人，聞之，有獻於公，公賜之食，食舍肉。公問之，對曰：「小人有母，皆嘗小人之食矣，未嘗君之羹，請以遺之。」公曰：「爾有母遺，繄我獨無！」潁考叔曰：「敢問何謂也？」公語之故，且告之悔。對曰：「君何患焉？若闕地及泉，隧而相見，其誰曰不然？」公從之。公入而賦：「大隧之中，其樂也融融！」姜出而賦：「大隧之外，其樂也洩洩！」遂為母子如初。 1234567遺--&gt; wèi《康熙字典》投贈也，餽也。繄--&gt; yī《註》繄，語助辭。闕--&gt; jué《註》闕，穿也。--&gt; què《說文》門觀也。《廣韻》闕在門兩旁，中央闕然爲道也。《正韻》宮門雙闕也。《韻會》爲二臺于門外，作樓觀於上，上員下方，以其縣法謂之象魏。象，治象也。魏者，言其狀魏魏然高大也，使民觀之，因爲之觀，兩觀雙植，中不爲門。又宮門、寢門、冢門皆曰闕。《古今注》闕，觀也。古每門樹兩觀於其前，所以標表宮門也。其上可居，登之則可遠觀，故謂之觀。人臣將至此，則思其所闕，故謂之闕。 君子曰：「潁考叔，純孝也，愛其母，施及莊公。《詩》曰『孝子不匱，永錫爾類。』其是之謂乎！」 12施--&gt; yì《箋》施，猶易也，延也。 二、齊桓公伐楚概述四年春，王正月。公會齊侯、宋公、陳侯、衛侯、鄭伯、許男、曹伯侵蔡。蔡潰，遂伐楚，次于陘。 夏。許男新臣卒。楚屈完來盟于師，盟于召陵。齊人執陳轅濤塗。 原文四年春。齊侯以諸侯之師侵蔡。蔡潰，遂伐楚。楚子使與師言曰：「君處北海，寡人處南海，唯是風馬牛不相及也。不虞君之涉吾地也，何故？」管仲對曰：「昔召康公命我先君大公曰：『五侯九伯，女實征之，以夾輔周室。』賜我先君履，東至于海，西至於河，南至於穆陵，北至於無棣。爾貢包茅不入，王祭不共，無以縮酒，寡人是徵。昭王南征而不復，寡人是問。」對曰：「貢之不入，寡君之罪也，敢不共給。昭王之不復，君其問諸水濱。」師進，次於陘。 123456789101112風--&gt; 賈逵云：風，放也。牝牡相誘謂之風。然則馬牛風佚，因牝牡相逐而遂至放佚遠去也。虞--&gt; yú 度也。履--&gt; 《註》謂所踐履之界也。共--&gt; 《說文》周禮、尚書供給供奉字皆借共字爲之。包茅--&gt; 成束捆綁的菁茅草。古代祭祀時，用來濾酒去滓，為春秋時楚國的貢物。徵--&gt; 問也。 夏。楚子使屈完如師。師退，次於召陵。齊侯陳諸侯之師，與屈完乘而觀之。齊侯曰：「豈不穀是為？先君之好是繼，與不穀同好如何？」對曰：「君惠徼福於敝邑之社稷，辱收寡君，寡君之願也。」齊侯曰：「以此眾戰，誰能禦之？以此攻城，何城不克？」對曰：「君若以德綏諸侯，誰敢不服？君若以力，楚國方城以為城，漢水以為池。雖眾，無所用之。」屈完及諸侯盟。 12345678不穀--&gt;《爾雅·釋詁》穀，善也。《禮·曲禮》自稱曰不穀。《註》謙稱。徼--&gt; jiǎo《玉篇》要也，求也。社稷--&gt; 本指土神和穀神。後指國家。綏--&gt; suí《說文》車中把也。《註》徐鍇曰：禮升車必正立執綏，所以安也。 三、宮之奇諫假道概述晉侯想要再次借道虞國攻打虢國，宮之奇上諫奏明虞虢脣齒相依的利害關係，虞公不聽，答應了晉國的要求，宮之奇帶領族人遠走他鄉。後，晉滅虢并襲擊了虞國。 原文晉侯復假道於虞以伐虢，宮之奇諫曰：「虢，虞之表也。虢亡，虞必從之。晉不可啟，寇不可翫。一之謂甚，其可再乎？諺所謂『輔車相依，脣亡齒寒』者，其虞虢之謂也！」公曰：「晉，吾宗也。豈害我哉？」對曰：「大伯、虞仲，大王之昭也。大伯不從，是以不嗣。虢仲、虢叔，王季之穆也，為文王卿士，勳在王室，藏於盟府。將虢是滅，何愛於虞？且虞能親於桓莊乎？其愛之也，桓莊之族何罪，而以為戮，不唯偪乎？親以寵偪，猶尚害之，況以國乎？」公曰：「吾享祀豐絜，神必據我。」對曰：「臣聞之，鬼神非人實親，惟德是依。故《周書》曰：『皇天無親，惟德是輔。』又曰：『黍稷非馨，明德惟馨。』又曰：『民不易物，惟德緊物。』如是，則非德，民不和，神不享矣。神所馮依，將在德矣。若晉取虞，而明德以薦馨香，神其吐之乎？」弗聽，許晉使。宮之奇以其族行，曰：「虞不臘矣，在此行也，晉不更舉矣。」 12345678910111213141516171819202122表--&gt; 外也。啟--&gt; 《說文》開也。翫--&gt; wán 轻慢；轻视。昭穆--&gt; 宗廟的輩次排列。古代宗廟制度，天子七廟，諸侯五廟，大夫三廟。以天子而言，太祖廟居中；二、四、六世居左，稱為「昭」；三、五、七世居右，稱為「穆」。桓莊--&gt; 桓叔與莊伯,這裡指桓莊之族。莊伯是桓叔之子,桓叔是獻公的曾祖,莊伯是獻公的祖父。晉獻公曾盡殺桓叔、莊伯的後代。偪--&gt;《集韻》與逼同。 絜--&gt; 同潔，乾淨。薦--&gt; jiàn《韻會》進也。《穀梁傳註》無牲而祭曰薦。臘--&gt; 《註》此周禮所謂蜡祭也。更--&gt; gèng 《增韻》再也。舉--&gt; 起也。 冬，十二月，丙子朔。晉滅虢，虢公醜奔京師。師還，館于虞，遂襲虞，滅之。 1234京師--&gt; 國都。館--&gt; 《說文》客舍也。這裏用如動詞，等於說住賓館。 四、燭之武退秦師概述晉秦大軍壓境，出兵的理由是：當時晉文公重耳流亡的時候鄭國對他無禮。鄭伯派出燭之武去函陵說服秦伯退兵，理由是：這是一場長途戰，對於秦國沒有任何好處，反而會擴張晉國的版圖，威脅秦國的安全；而且晉侯是一個不守信譽且貪得無厭的人，不能與謀。秦伯聽完大悅，與鄭國結盟，并退兵。晉侯聽聞秦國退兵后也退了。 原文晉侯、秦伯圍鄭，以其無禮於晉，且貳於楚也。晉軍函陵，秦軍汜南。佚之狐言於鄭伯曰：「國危矣！若使燭之武見秦君，師必退。」公從之。辭曰：「臣之壯也，猶不如人。今老矣，無能為也已！」公曰：「吾不能早用子，今急而求子，是寡人之過也。然鄭亡，子亦有不利焉。」許之。夜縋而出，見秦伯，曰：「秦、晉圍鄭，鄭既知亡矣。若亡鄭而有益於君，敢以煩執事。越國以鄙遠，君知其難也，焉用亡鄭以倍鄰？鄰之厚，君之薄也。若舍鄭以為東道主，行李之往來，共其乏困，君亦無所害。且君嘗為晉君賜矣，許君焦、瑕，朝濟而夕設版焉，君之所知也。夫晉，何厭之有？既東封鄭，又欲肆其西封，若不闕秦，將焉取之？闕秦以利晉，唯君圖之。」秦伯說，與鄭人盟。使杞子、逢孫、楊孫戍之，乃還。子犯謂擊之，公曰：「不可。微夫人力不及此。因人之力而敝之，不仁。失其所與，不知。以亂易整，不武。吾其還也。」亦去之。 123456789101112軍--&gt; 用如動詞，屯兵。汜--&gt; fán，水名，指東氾，今已湮，故道在今河南中牟縣南。縋--&gt; 《說文》以繩有所懸也。《註》縋，縣城而下。舍--&gt; 捨棄，不取(不滅掉)東道主--&gt; 東路上的主人，因鄭國在秦國東面，所以稱為「東道主」，後借以泛稱接待或宴請賓客的主人。肆--&gt; 伸展。 五、蹇叔哭師概述僖公三十二年東，晉文公重耳去世。掌管卜筮的卜偃聽聞秦國密謀，借文公之口，散佈消息說：秦軍將要過境去攻打鄭國，攻打他必勝。同時，在燭之武退秦后戍守鄭國邊境的杞子托使者告訴秦伯：派兵過來，唾手可得。秦穆公問了下蹇叔的意見，蹇叔不同意興師動眾攻打大老遠的鄭國。秦穆公不樂意，執意出師。蹇叔哭送軍中的兒子，并預言晉軍會在殽進行防禦，讓兒子一定要死在北陵，好收骨頭。 原文冬，晉文公卒。庚辰，將殯于曲沃，出絳，柩有聲如牛，卜偃使大夫拜曰，君命大事，將有西師過軼我，擊之必大捷焉。 123456殯--&gt; 停柩待葬。絳--&gt; 晉國國都，在今山西翼城縣東南。軼--&gt; 後車超過前車。 杞子自鄭使告于秦曰，鄭人使我掌其北門之管，若潛師以來，國可得也，穆公訪諸蹇叔。蹇叔曰，勞師以襲遠，非所聞也。師勞力竭，遠主備之，無乃不可乎，師之所為，鄭必知之，勤而無所，必有悖心，且行千里，其誰不知，公辭焉，召孟明，西乞，白乙，使出師於東門之外，蹇叔哭之曰，孟子，吾見師之出，而不見其入也，公使謂之曰，爾何知，中壽，爾墓之木拱矣。蹇叔之子與師。哭而送之曰，晉人禦師必於殽，殽有二陵焉，其南陵，夏后皋之墓也，其北陵，文王之所辟風雨也，必死是間，余收爾骨焉，秦師遂東。 12345678910111213潛--&gt; 隱藏在水面下，指偷偷行動。中壽--&gt; 約指活到六七十歲。拱--&gt; 兩手合抱。殽--&gt; 通崤，山名，在今河南洛寧縣西北，地勢極險。陵--&gt; 大山。淆有二山，稱為東陵西陵，相距三十五里。下文南陵即西陵，北陵即東陵。東--&gt; 用如動詞（名詞活用為動詞），向東進發。 六、晉靈公不君概述晉靈公不行君道，收老百姓大批賦稅大興土木，商議國事時卻在臺上玩彈弓，彈人。有一次宰夫熊掌沒烹熟，被靈公下令宰殺了，還讓一婦人載著他經過朝廷。趙盾和士季看到這種情況，先後多次進諫。晉靈公不但不知悔改，還想殺掉進諫的大臣。派殺手一大早地去刺殺趙盾，然殺手感于趙盾的恭敬，撞槐樹自殺了。晉靈公又在酒宴上想把趙盾灌醉，然後趁機消滅他，提彌明挺身而出，為趙盾犧牲了，趙盾逃了。不久，趙穿在桃園刺殺了靈公。 原文晉靈公不君，厚斂以彫牆，從臺上彈人，而觀其辟丸也，宰夫胹熊蹯不熟，殺之，寘諸畚，使婦人載以過朝，趙盾，士季，見其手，問其故，而患之，將諫，士季曰，諫而不入，則莫之繼也，會請先，不入，則子繼之，三進及溜，而後視之，曰，吾知所過矣，將改之。稽首而對曰，人誰無過，過而能改，善莫大焉。《詩》曰：『靡不有初，鮮克有終』，夫如是，則能補過者鮮矣。君能有終，則社稷之固也，豈惟群臣賴之，又曰，袞職有闕，惟仲山甫補之，能補過也。君能補過，袞不廢矣。 123456789101112彫--&gt; diāo 画也。——《广雅》辟--&gt; 躲避。胹--&gt; ér 疏：“过熟曰胹。”蹯--&gt; fán《說文》作番，獸足也。溜--&gt; liù《正義》溜，謂簷下水滴之處。袞--&gt; gǔn 天子服也。 猶不改，宣子驟諫，公患之，使鉏麑賊之，晨往，寢門闢矣，盛服將朝，尚早，坐而假寐，麑退，歎而言曰，不忘恭敬，民之主也，賊民之主，不忠，棄君之命，不信，有一於此，不如死也，觸槐而死。 1234賊--&gt; 《註》賊，傷害也。《傳》殺人曰賊。闢--&gt; 《說文》闢，開也。 秋，九月，晉侯飲趙盾酒，伏甲將攻之，其右提彌明知之，趨登曰，臣侍君宴，過三爵，非禮也，遂扶以下，公嗾夫獒焉，明搏而殺之，盾曰，棄人用犬，雖猛何為，鬥且出，提彌明死之。 1234飲--&gt; yìn 使...喝。嗾--&gt; sǒu，喚狗的聲音，用如動詞，嗾使。 初，宣子田於首山，舍于翳桑，見靈輒餓，問其病，曰，不食三日矣，食之，舍其半，問之。曰：宦三年矣，未知母之存否。今近焉，請以遺之，使盡之，而為之簞食與肉，寘諸橐以與之，既而與為公介，倒戟以禦公徒，而免之，問何故，對曰，翳桑之餓人也。問其名居，不告而退，遂自亡也。 12345678910田--&gt; 同“畋”，打獵。遺--&gt; wèi 給。簞--&gt; dān 盛飯用的竹筐。食--&gt; sì 飯。橐--&gt; tuó 口袋。 乙丑，趙穿攻靈公於桃園。宣子未出山而復。大史書曰：趙盾弒其君，以示於朝。宣子曰：不然。對曰，子為正卿。亡不越竟，反不討賊，非子而誰。宣子曰：嗚呼，我之懷矣，自詒伊慼，其我之謂矣。 孔子曰：董狐，古之良史也。書法不隱，趙宣子，古之良大夫也，為法受惡，惜也，越竟乃免。 七、齊晉鞌之戰背景戰事因齊國而起，齊國首先侵略魯國的北部邊境，圍困了龍地，而寵臣盧蒲就魁攻城不入被龍地人俘虜，齊頃公提出條件跟魯國結盟并再不入侵，魯國不接受并殺了盧蒲就魁。齊頃公憤而親自擊鼓，三天內攻破了龍地，并繼續南侵到巢丘。這時衛國也派兵出征齊國，在新築潰敗，於是去晉國請救兵，然後就有下面的齊晉鞌之戰了。 原文癸酉，師陳于鞌，邴夏御齊侯，逢丑父為右，晉解張御郤克，鄭丘緩為右，齊侯曰，余姑翦滅此而朝食，不介馬而馳之。郤克傷於矢。流血及屨，未絕鼓音。曰：余病矣。張侯曰：自始合，而矢貫余手及肘，余折以御，左輪朱殷，豈敢言病，吾子忍之。緩曰，自始合，苟有險，余必下推車，子豈識之，然子病矣，張侯曰，師之耳目，在吾旗鼓，進退從之，此車，一人殿之，可以集事，若之何其以病，敗君之大事也，擐甲執兵，固即死也，病未及死，吾子勉之，左并轡，右援桴而鼓，馬逸不能止，師從之。齊師敗績，逐之，三周華不注。 123456789101112131415161718陳--&gt; 擺開陣勢。御--&gt; 《說文》御，使馬也。翦滅--&gt; 剪除消滅。介--&gt; 象形。甲骨文字形，象人身上穿着铠甲形。中间是人，两边的四点象联在一起的铠甲片。本义：铠甲。這裡是用如動詞，表示給馬上甲。病--&gt;《說文》疾加也。《玉篇》疾甚也。殿--&gt; 《广雅》殿，后也。這裡用如動詞，表示殿后。擐--&gt; huàn 穿桴 --&gt; fú 鼓槌。華不注--&gt; 華不注，山名，在今濟南東北。 韓厥夢子輿謂己曰，旦辟左右，故中御而從齊侯，邴夏曰，射其御者，君子也，公曰，謂之君子而射之，非禮也，射其左，越于車下，射其右，斃于車中，綦毋張喪車，從韓厥曰，請寓乘，從左右，皆肘之，使立於後，韓厥俛定其右。 123456子輿--&gt; 韓厥之父。從--&gt; 追趕。俛--&gt; 《註》師古曰：俛卽俯。 逢丑父與公易位，將及華泉，驂絓於木而止。丑父寢於轏中，蛇出於其下，以肱擊之，傷而匿之，故不能推車而及。韓厥執縶馬前，再拜稽首，奉觴加璧以進，曰，寡君使群臣為魯衛請，曰，無令輿師，陷入君地，下臣不幸，屬當戎行，無所逃隱，且懼奔辟，而忝兩君，臣辱戎士，敢告不敏，攝官承乏，丑父使公下如華泉取飲，鄭周父御佐車，宛茷為右，載齊侯以免，韓厥獻丑父，郤獻子將戮之，呼曰，自今無有代其君任患者，有一於此，將為戮乎，郤子曰，人不難以死免其君，我戮之不祥，赦之以勸事君者，乃免之。 12345678910驂--&gt; cān 《说文》骖，驾三马也。絓--&gt; guà 同“掛”。《广雅》絓，悬也。轏--&gt; zhàn 古代用竹木条做成的车。縶--&gt; zhí 本義為系绊马足。這裡指拴住马足的绳索。輿--&gt; 《广雅》舆，多也。這裡用如動詞，表示增加。 八、楚歸晉知罃背景宣公十二年(公元前 597 年)晉楚邲(地名，在今河南鄭州市東)之戰時，晉知罃被俘，晉卻擒獲了穀臣，射死了襄老，把屍首運回晉國。現在晉要用穀臣和襄老的屍體換回知罃。 概述楚共王送歸知罃路上，詢問了知罃是埋怨他還是感激他。而知罃答之：我被抓是因為自己無才，王不把我在祭祀中作為犧牲已經待我很好了，我不埋怨；然而我也不感激您，因為這是國與國之間的交換，與我個人沒太大關係。如果一定要我報答的話，我會竭力致死盡忠于吾國來報答。楚共王意思到晉國人的忠，不可與爭，厚待并釋放了知罃。 原文晉人歸楚公子穀臣，與連尹襄老之尸于楚，以求知罃，於是荀首佐中軍矣，故楚人許之，王送知罃，曰，子其怨我乎，對曰，二國治戎，臣不才，不勝其任，以為俘馘，執事不以釁鼓，使歸即戮，君之惠也，臣實不才，又誰敢怨，王曰，然則德我乎，對曰，二國圖其社稷，而求紓其民，各懲其忿，以相宥也，兩釋纍囚，以成其好，二國有好，臣不與及，其誰敢德，王曰，子歸何以報我，對曰，臣不任受怨，君亦不任受德，無怨無德，不知所報，王曰，雖然，必告不穀，對曰，以君之靈，纍臣得歸骨於晉，寡君之以為戮，死且不朽，若從君之惠而免之，以賜君之外臣首，首其請於寡君，而以戮於宗，亦死且不朽，若不獲命，而使嗣宗職，次及於事，而帥偏師以脩封疆，雖遇執事，其弗敢違，其竭力致死，無有二心，以盡臣禮，所以報也，王曰，晉未可與爭，重為之禮而歸之。 12345678910111213141516171819佐--&gt; 輔佐。--&gt; 本字為“左”，為方位詞，後金文在此基础上再加“工”（巧具、事工）另造“佐”，表示呼求神赐巧具，助事成功。(來自：象形字典)馘--&gt; guó《註》軍法，獲而不服，則殺而獻其左耳。釁--&gt; xìn 《說文》血祭也。象祭竈也。《廣韻》牲血塗器祭也。《禮·月令》孟冬之月，命大史釁龜筴。《疏》謂殺牲以血塗釁其龜及筴。懲--&gt; 克制；制止。宥--&gt; yòu《說文》寬也。纍--&gt; léi《說文》一曰大索也。《廣韻》係也。亦作縲。《左傳·僖三十三年》不以纍臣釁鼓。《註》纍，囚繫也。嗣--&gt; 《玉篇》嗣，續也，繼也。偏師--&gt; 副帥副將所屬的軍隊，這裏是客氣的說法。封--&gt; 《說文》爵諸侯之土也。从之从土从寸。《徐曰》各之其土也，寸守其法度也。本作封，隸作封，从圭所執也。 九、祁奚薦賢概述祁奚是晉國的中軍尉，向晉悼公告老還鄉。晉侯問繼承者，祁奚舉薦了他的死對頭解狐。不料解狐死了，就舉薦了自己的兒子祁午。這時候副中軍尉羊舌職死了，晉侯問繼承者，祁奚舉薦了羊舌職的兒子赤（字伯華）。祁奚同學無偏無黨的精神值得我們好好學習。 原文祁奚請老，晉侯問嗣焉，稱解狐，其讎也，將立之而卒，又問焉。對曰，午也可。於是羊舌職死矣，晉侯曰，孰可以代之。對曰，赤也可，於是使祁午為中軍尉，羊舌赤佐之，君子謂祁奚於是能舉善矣。稱其讎，不為諂，立其子，不為比，舉其偏，不為黨。商書曰，無偏無黨，王道蕩蕩，其祁奚之謂矣，解狐得舉，祁午得位，伯華得官，建一官而三物成，能舉善也，夫唯善，故能舉其類，詩云，惟其有之，是以似之，祁奚有焉。 123456讎--&gt; chóu《玉篇》對也。又《韻會》仇也。於是--&gt; 當這時候。比--&gt; bì《康熙字典》又偏也，黨也。《論語》君子周而不比。 十、子產不毀鄉校概述鄭國的兩個大夫在鄉校遊覽，談論政事。然明建議把鄉校都拆了，子產不同意，說：老百姓在這談論政事，好的政策我就施行，不好的及時改正，就好比我的老師。況且我們應該行忠善來化解民怨，而不是作威作福來防止民怨。就像治水一樣，你一昧地堵，總有一天會潰堤釀成大災，還不如開個小口，疏導民怨。這就叫「防民之口，甚于防川」。 原文鄭人游于鄉校，以論執政，然明謂子產曰，毀鄉校何如，子產曰，何為，夫人朝夕退而游焉，以議執政之善否，其所善者，吾則行之，其所惡者，吾則改之，是吾師也，若之何毀之，我聞忠善以損怨，不聞作威以防怨，豈不遽止，然猶防川，大決所犯，傷人必多，吾不克救也，不如小決，使道不如，吾聞而藥之也，然明曰，蔑也今而後知吾子之信可事也，小人實不才，若果行此，其鄭國實賴之，豈唯二三臣，仲尼聞是語也，曰，以是觀之，人謂子產不仁，吾不信也。 123456789101112子產--&gt; 鄭大夫，名公孫僑(子產是字)，春秋時有名的政治家。執政二十餘年，使處在晉楚雙重壓迫 之下的弱小鄭國獲得安定，並受到各國尊重。鄉校--&gt; 鄉間的公共場所。既是學校，又是鄉人聚會議事的地方。執政--&gt; 指掌握政權的人。然明--&gt; 鄭大夫，姓鬷(zōng)，名蔑，字然明。遽--&gt; jù 《玉篇》急也，疾也，卒也。決--&gt; 《康熙字典》又行流也。又開也。","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"漢語言","slug":"language/漢語言","permalink":"https://linlshare.github.io/categories/language/漢語言/"},{"name":"古代漢語","slug":"language/漢語言/古代漢語","permalink":"https://linlshare.github.io/categories/language/漢語言/古代漢語/"}],"tags":[{"name":"古漢語","slug":"古漢語","permalink":"https://linlshare.github.io/tags/古漢語/"}]},{"title":"代码质量控制","slug":"it/code/代码质量控制","date":"2018-08-22T06:14:00.000Z","updated":"2019-01-13T11:37:46.370Z","comments":true,"path":"2018/08/22/it/code/代码质量控制/","link":"","permalink":"https://linlshare.github.io/2018/08/22/it/code/代码质量控制/","excerpt":"","text":"安装插件 CheckStyle - IDEA 进入 Perferences/Settings --&gt; Plugins 搜索安装 CheckStyle - IDEA 插件。 Java 代码规范，你应该知道的一些工具和用法 https://juejin.im/entry/595c6fb2f265da6c375a8ea3 基于 Gitlab 实现 CI/CDhttps://zhuanlan.zhihu.com/p/37411745","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"code","slug":"it/code","permalink":"https://linlshare.github.io/categories/it/code/"}],"tags":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"https://linlshare.github.io/tags/CodeStyle/"}]},{"title":"Mac","slug":"it/tool/Mac","date":"2018-08-21T14:53:00.000Z","updated":"2019-01-13T11:37:46.484Z","comments":true,"path":"2018/08/21/it/tool/Mac/","link":"","permalink":"https://linlshare.github.io/2018/08/21/it/tool/Mac/","excerpt":"","text":"本帖记录个人在使用 Mac 操作系统上的一些骚操作，不断更新，以飨读者。 1. 快速移动网页到顶部或底部用双指上下划触摸板吗？NO，我们有更骚的操作： command + ↑ 回到顶部 command + ↓ 滚到底部 另外， fn + ↑ 上滚一页 fn + ↓ 下滚一页 fn + ← Home，回到顶部 fn + → End，滚到底部 2. Dock 中只显示打开的应用Mac 用着用着 Dock 上显示了一堆的图标，看着无法集中注意力，这时候可以打开 Terminal 输入： 1defaults write com.apple.dock static-only -boolean true; killall Dock 回车就可以让 Dock 只显示打开的应用了，世界一下子清爽了。 PS，如果想恢复原样，可以执行： 1defaults delete com.apple.dock static-only; killall Dock 3. 粘贴文字时不要带样式有时候从网上看到不错的文字想要粘贴到 Word、Evernote 或者文字编辑应用上，但使用 command + v 会连文字样式都带过来，这时候就要使用骚一点的操作了，那就是： 1command + shift + v 4. 输入英文时首字母不要自动大写当你在文字编辑软件上写英文时，Mac 会很贴心地识别首字母并自动大写。但常常让我觉得画蛇添足，明明我不想大写，特别是在博客中或写或改一些代码或脚本时更觉得是捣乱。这时候，我找到了一个禁止自动首字母自动大写的方法： 1系统偏好设置 —&gt; 键盘 —&gt; 文本 —&gt; 去除勾选【自动大写字词的首字母】 5. 我要剪切或移动文件Mac 中，复制的快捷键是 command + c，粘贴的快捷键是 command + v ，但是剪切的快捷键可不是 command + x ，如果要移动文件，你是不是还在进行 粘贴完再删除 的复杂操作？ NO，其实移动文件可以复制后使用快捷键 command + option + v 实现，快去试试吧。 6. 快速转换中文简繁体确保简繁体转换服务已经开启，路径如下： 1系统偏好设置 —&gt; 键盘 —&gt; 快捷键 —&gt; 服务 —&gt; 将文字转换为繁体中文 / 将文字转换为简体中文 选中需要进行简繁对换的文字，按： control + shift + command + c 将文字转为繁体中文 control + option + shift + command + c 将文字转为简体中文","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://linlshare.github.io/tags/Mac/"},{"name":"OS","slug":"OS","permalink":"https://linlshare.github.io/tags/OS/"}]},{"title":"解决 Android 中出现依赖多个版本支持库的问题","slug":"it/android/解决 Android 中出现依赖多个版本支持库的问题","date":"2018-08-21T07:08:00.000Z","updated":"2019-01-13T11:37:46.364Z","comments":true,"path":"2018/08/21/it/android/解决 Android 中出现依赖多个版本支持库的问题/","link":"","permalink":"https://linlshare.github.io/2018/08/21/it/android/解决 Android 中出现依赖多个版本支持库的问题/","excerpt":"","text":"在 app 的 build.gradle 中引入依赖时发现如下错误： 12All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 27.1.1, 26.1.0. Examples include com.android.support:animated-vector-drawable:27.1.1 and com.android.support:support-media-compat:26.1.0 less... (⌘F1) There are some combinations of libraries, or tools and libraries, that are incompatible, or can lead to bugs. One such incompatibility is compiling with a version of the Android support libraries that is not the latest version (or in particular, a version lower than your targetSdkVersion). 简单的说就是引入了两种版本的 Android Support Library，这种情形该如何处理呢？ 统一管理支持包的版本号； 剔除第三方库中包含的支持包，并引入版本一致的支持包。 具体如下： 12345678910111213141516171819ext.versions = [ play_services: '15.0.1', // 统一管理支持包的版本号 suport_library: '27.1.1',]dependencies &#123; implementation(\"com.google.android.gms:play-services-gcm:$&#123;versions.play_services&#125;\") &#123; // 剔除 play service 中包含的 v4 支持包 exclude group: 'com.android.support', module: 'support-v4' &#125; // 引入版本一致的 v4 支持包 implementation \"com.android.support:support-v4:$&#123;versions.suport_library&#125;\" implementation \"com.android.support:appcompat-v7:$&#123;versions.suport_library&#125;\" implementation \"com.android.support:recyclerview-v7:$&#123;versions.suport_library&#125;\" implementation \"com.android.support:cardview-v7:$&#123;versions.suport_library&#125;\" implementation \"com.android.support:support-annotations:$&#123;versions.suport_library&#125;\"&#125; 通常在我们引入了众多依赖的情况下，我们并不知道引入哪个依赖重复引入了支持库，有没有工具可以帮我们分析呢？ 答案是肯定的，gradle 命令中有一条可以做到这点，那就是 gradle dependencies ，它可以将依赖和依赖的依赖罗列出来。也可以通过 Android Studio 右侧工具栏的 Gradle --&gt; help--&gt; dependencies 启动依赖分析。以上面的依赖为例，执行结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657+--- com.google.android.gms:play-services-gcm:15.0.1| +--- com.google.android.gms:play-services-base:[15.0.1,16.0.0) -&gt; 15.0.1| | +--- com.google.android.gms:play-services-basement:[15.0.1] -&gt; 15.0.1| | | \\--- com.android.support:support-v4:26.1.0 -&gt; 27.1.1| | | +--- com.android.support:support-compat:27.1.1| | | | +--- com.android.support:support-annotations:27.1.1| | | | \\--- android.arch.lifecycle:runtime:1.1.0| | | | +--- android.arch.lifecycle:common:1.1.0| | | | \\--- android.arch.core:common:1.1.0| | | +--- com.android.support:support-media-compat:27.1.1| | | | +--- com.android.support:support-annotations:27.1.1| | | | \\--- com.android.support:support-compat:27.1.1 (*)| | | +--- com.android.support:support-core-utils:27.1.1| | | | +--- com.android.support:support-annotations:27.1.1| | | | \\--- com.android.support:support-compat:27.1.1 (*)| | | +--- com.android.support:support-core-ui:27.1.1| | | | +--- com.android.support:support-annotations:27.1.1| | | | +--- com.android.support:support-compat:27.1.1 (*)| | | | \\--- com.android.support:support-core-utils:27.1.1 (*)| | | \\--- com.android.support:support-fragment:27.1.1| | | +--- com.android.support:support-compat:27.1.1 (*)| | | +--- com.android.support:support-core-ui:27.1.1 (*)| | | +--- com.android.support:support-core-utils:27.1.1 (*)| | | +--- com.android.support:support-annotations:27.1.1| | | +--- android.arch.lifecycle:livedata-core:1.1.0| | | | +--- android.arch.lifecycle:common:1.1.0| | | | +--- android.arch.core:common:1.1.0| | | | \\--- android.arch.core:runtime:1.1.0| | | | \\--- android.arch.core:common:1.1.0| | | \\--- android.arch.lifecycle:viewmodel:1.1.0| | \\--- com.google.android.gms:play-services-tasks:[15.0.1] -&gt; 15.0.1| | \\--- com.google.android.gms:play-services-basement:[15.0.1] -&gt; 15.0.1 (*)| +--- com.google.android.gms:play-services-basement:[15.0.1,16.0.0) -&gt; 15.0.1 (*)| +--- com.google.android.gms:play-services-iid:[15.0.1] -&gt; 15.0.1| | +--- com.google.android.gms:play-services-base:[15.0.1,16.0.0) -&gt; 15.0.1 (*)| | +--- com.google.android.gms:play-services-basement:[15.0.1,16.0.0) -&gt; 15.0.1 (*)| | +--- com.google.android.gms:play-services-stats:[15.0.1,16.0.0) -&gt; 15.0.1| | | \\--- com.google.android.gms:play-services-basement:[15.0.1] -&gt; 15.0.1 (*)| | \\--- com.google.android.gms:play-services-tasks:[15.0.1,16.0.0) -&gt; 15.0.1 (*)| \\--- com.google.android.gms:play-services-stats:[15.0.1,16.0.0) -&gt; 15.0.1 (*)+--- com.android.support:support-v4:27.1.1 (*)+--- com.android.support:appcompat-v7:27.1.1| +--- com.android.support:support-annotations:27.1.1| +--- com.android.support:support-core-utils:27.1.1 (*)| +--- com.android.support:support-fragment:27.1.1 (*)| +--- com.android.support:support-vector-drawable:27.1.1| | +--- com.android.support:support-annotations:27.1.1| | \\--- com.android.support:support-compat:27.1.1 (*)| \\--- com.android.support:animated-vector-drawable:27.1.1| +--- com.android.support:support-vector-drawable:27.1.1 (*)| \\--- com.android.support:support-core-ui:27.1.1 (*)+--- com.android.support:recyclerview-v7:27.1.1| +--- com.android.support:support-annotations:27.1.1| +--- com.android.support:support-compat:27.1.1 (*)| \\--- com.android.support:support-core-ui:27.1.1 (*)+--- com.android.support:cardview-v7:27.1.1| \\--- com.android.support:support-annotations:27","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"《古代漢語》上一·文選","slug":"language/漢語言/古代漢語/《古代漢語》上一·常用字","date":"2018-08-20T15:09:00.000Z","updated":"2019-01-13T11:37:46.598Z","comments":true,"path":"2018/08/20/language/漢語言/古代漢語/《古代漢語》上一·常用字/","link":"","permalink":"https://linlshare.github.io/2018/08/20/language/漢語言/古代漢語/《古代漢語》上一·常用字/","excerpt":"","text":"言 甲骨文 金文 篆書 1言，甲骨文是指事字，字形在舌的舌尖位置加一短横指事符号，表示舌头发出的动作。造字本义：动词，鼓舌说话。 --《象形字典》有刪減 頭腦風暴：言的甲骨文好似一把小刀刺進胸膛，然後噴濺出血液來，所以可以解釋成直話直說就像一針見血，常常令人不舒服。 《說文》直言曰言，論難曰語。 又辭章也。《書·洪範》五事，一曰貌，二曰言。 又一句爲一言。《論語》一言以蔽之。 又一字爲一言。《戰國策》臣請三言而已矣，曰海大魚。 又猶議也。《屈原·離騷》初旣與余成言兮，後悔遁而有他。 又號令也。《周語》有不祀則修言。 又助語辭。《易·師卦》田有禽利執言。《註》語辭也。 又《爾雅·釋詁》言，我也。《詩·周南》言告師氏。《傳》言，我也。師，女師也。 又《博雅》問也。《周禮·春官》冢人：及葬，言鸞車象人。《註》言問其不如法度者。 語 甲骨文 金文 篆書 – – 1五，既是声旁也是形旁，表示数量多。语，金文（言，说）（两个“五”，数量极多），表示说很多话。造字本义：演说，谈论，议论。篆文加“口”。 --《象形字典》有刪減 頭腦風暴：語的金文左言右兩五，表示說了很多話或者很多人在說話，說了很多話就叫「敘」，很多人在說話就是「論」。 上聲 (yǔ) 《說文》論也。 《疏》直言曰言，謂一人自言。答難曰語，謂二人相對。 《釋名》敘也。敘己所欲說也。《易·頤卦》君子以愼言語，節飮食。 去聲 (yù) 《廣韻》告也。《增韻》以言告人也。《左傳·隱元年》公語之故。 謂「謂」字由左「言」右「胃」構成，「言」字上面說了，下面研究下「胃」的字形演變，如下： 甲骨文 金文 篆書 – %E6%98%A5%E7%A7%8B%E6%99%9A%E6%9C%9F.png?raw=true) – .png) 1金文是会义字，上面（像“米袋”）下面（月，即“肉”），强调“米袋”为身体的器官。 --《象形字典》有刪減 《說文》胃，榖府也。也就是消化穀物的器官。 「謂」字的字形演變如下： 甲骨文 金文 篆書 – %E6%98%A5%E7%A7%8B%E6%99%9A%E6%9C%9F.png?raw=true) 頭腦風暴：這應該是一個指事詞，告訴族人肚子餓了，引為「訴說」之意。溫飽問題是大問題，所以「有所謂」，不值得一提的問題那就是「無所謂」了。 《說文》謂，報也。 《廣韻》告也，言也。 又《韻會》事有可稱曰有謂，失於事宜不可名言曰無謂。《莊子·齊物論》今我則有謂矣，而未知吾所謂之，其果有謂乎，其果無謂乎。 又《正韻》非與之言而稱其人亦曰謂，《論語》子謂子賤，子謂子產，是也。 又《爾雅·釋詁》勤也。《詩·小雅》心乎愛矣，遐不謂矣。（謂在這裡應為告也。） 訪先看看「方」，其字形演變如下： 甲骨文 金文 篆書 .png?raw=true) %20%E5%95%86%E4%BB%A3%E6%99%9A%E6%9C%9F.png?raw=true) %20%E8%A5%BF%E5%91%A8%E6%99%9A%E6%9C%9F.png?raw=true) 1“方”是“放”、“旁”的本字。方，甲骨文（剔发刺字的犯人）（锁颈的枷械），表示被披枷流放的罪人。造字本义：动词，将罪犯剔发刺字，流放边疆。当“方”的“流放犯人”本义消失后，篆文再加“凡”（方形木枷）另造“旁”代替；或加“攴”（打击）另造“放”代替，表示刑罚驱逐。 --《象形字典》有刪減 頭腦風暴：「方」所帶的枷為矩形，所以「方」有了矩形之引申；「方」是被發配到邊疆，所以「方」有了地方、邊邑之引申。 甲骨文 金文 篆書 – .png?raw=true) 1方，既是声旁也是形旁，表示边邑。访，篆文（言，问候、交流）（方，边邑、异域），造字本义：中央派人到异域他邦问候、交流方略。 --《象形字典》 頭腦風暴：金文「訪」很像一個人低頭伸手謙虛地詢問，而篆書「訪」很像一個人抬頭招手向人打招呼。「訪」的本義應該就是去問，後面才引申出拜訪之意。 《說文》汎謀曰訪。《註》汎，泛也。 《傳》謂就而問之也。 又議也。《楚語》敎之令，使訪物官。 又《增韻》及也，見也。 又方也。《前漢·高五王傳》訪以呂氏，故幾亂天下。《註》訪，猶方也。《字彙補》與昉義同。 請先來看「青」字的演變，如下： 甲骨文 金文 篆書 – %20%E8%A5%BF%E5%91%A8%E4%B8%AD%E6%9C%9F.png?raw=true) 1井，既是声旁也是形旁，表示矿坑。青，甲骨文（屮，生，出现、出产）（井，矿坑），表示某种产自矿井的东西。古人将这种矿石研磨成粉末，作为重要颜料。 造字本义：名词，从矿井采掘的苔色矿石。 --《象形字典》有刪減 《說文》：“青，東方色也。木生火，从生丹，丹青之信言象然。𡗡，古文青。《註》大為成年人，屮為成長，成長為成年人的階段就是青年人。 《釋名》靑，生也。象物之生時色也。 又《韻會》竹皮曰靑。《後漢·吳祐傳》殺靑簡以寫經書。《註》以火炙簡令汗取其靑，易書復不蠹，謂之殺靑。 甲骨文 金文 篆書 – .png?raw=true) 1青，既是声旁也是形旁，是“倩”的省略，表示漂亮、美丽。请，金文（言，说）（倩，漂亮），造字本义：说漂亮话赞美对方，以期对方接受邀聘。 --《象形字典》有刪減 頭腦風暴：「青」在此處應該麗人的意思，「言」「青」表示向麗人說話。見麗人會說什麼話呢？豈非美言？ 《說文》謁也。 《玉篇》乞也，問也。《前漢·張湯傳》造請諸公，不避寒暑。 又《正韻》漢制，春曰朝，秋曰請，如古諸侯聘禮也。《史記·吳王濞傳》使人爲秋請。《前漢·宣帝紀》時會朝請。 召（𥃝）字形演變如下： 甲骨文 金文 篆書 .png?raw=true) %20%E5%95%86%E4%BB%A3%E6%99%9A%E6%9C%9F.png?raw=true) .png?raw=true) %20%E8%A5%BF%E5%91%A8%E6%99%9A%E6%9C%9F.png?raw=true) .png?raw=true) 1“召”是“招”的本字。刀，既是声旁也是形旁，疑是“匕”即“匙”的误写。召，甲骨文（双手）（匕，酒匙）（酉，酒坛），表示主人手持酒匕为客人打酒。有的甲骨文用“口”（盛器）代替“酉”；再加，像主宾双方相对坐在席子上。简体甲骨文省去双手和主客对坐的形象，并将酒匙“匕”写成“刀”。造字本义：打酒添食，招待客人。 --《象形字典》有刪減 頭腦風暴：客人來訪，雙手搬出酒肉相待。從上至下依次為「人」、「雙手」、「酒缸」、「藏酒缸之處」。 《王逸》曰以手曰招，以言曰召。 又姓。《廣韻》召公之後。《前漢·循吏傳》召信臣，九江壽春人。《氏族博考》春秋召與邵一氏，後分爲二，汝南安陽之族皆从邵。 報異體字：𡙈 「報」字形演變如下： 甲骨文 金文 篆書 – %20%E8%A5%BF%E5%91%A8%E6%97%A9%E6%9C%9F.png?raw=true) .png?raw=true) 1“𠬝fú”是“报”的本字。甲骨文中间为（人，嫌犯）右边为（又，抓、押送），表示带押嫌犯。金文、篆文加“幸”，强调“报”的刑事特征。造字本义：古代法官升堂传令，带押罪犯受审。 --《象形字典》有刪減 頭腦風暴：金文右邊活像一個人成跪狀被人用手押解著，左邊本不應該是「幸」，而應該是「㚔niè」。這不是法官審判，這已經是在處以刑罰了。 《說文》當辠人也。《註》辠，犯法也。从辛从自，言辠人蹙鼻苦辛之憂。秦以辠似皇字，改爲罪。 「㚔」字形演變如下： 甲骨文 金文 篆書 .png?raw=true) %20%E6%88%B0%E5%9C%8B%E6%99%9A%E6%9C%9F.png?raw=true) .png?raw=true) 董作賓《殷曆譜》：“㚔，象手械之形，蓋加於俘虜之刑具也。” 「𠬝」字形演變如下： 甲骨文 金文 篆文 .png?raw=true) %20%E8%A5%BF%E5%91%A8%E6%99%9A%E6%9C%9F.png?raw=true) .png?raw=true) 頭腦風暴：甲骨文顯示的是一個人成跪狀，一隻手拍打其背部或臉部；金文成半蹲狀，一隻手好似預備打屁股；篆文成鞠躬狀，一隻手拍打其大腿。甲骨文看起來怵目驚心，這並不是所謂的「心悅誠服」，而是在暴力之下屈服。 商承祚《福氏所藏甲骨文字考釋》：“𠬝即服之本字……𠬝為順从，故从手而撫其背，所謂中心悅而誠服也。” 告向首領報告","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"漢語言","slug":"language/漢語言","permalink":"https://linlshare.github.io/categories/language/漢語言/"},{"name":"古代漢語","slug":"language/漢語言/古代漢語","permalink":"https://linlshare.github.io/categories/language/漢語言/古代漢語/"}],"tags":[{"name":"古漢語","slug":"古漢語","permalink":"https://linlshare.github.io/tags/古漢語/"}]},{"title":"S3 Select for Java 使用记录","slug":"it/java/aws/S3 Select for Java 使用记录","date":"2018-08-19T11:33:00.000Z","updated":"2019-01-13T11:37:46.382Z","comments":true,"path":"2018/08/19/it/java/aws/S3 Select for Java 使用记录/","link":"","permalink":"https://linlshare.github.io/2018/08/19/it/java/aws/S3 Select for Java 使用记录/","excerpt":"","text":"背景后台基本使用 Amazon 的全家桶（EC2、DynamoDB、S3、Step Fuction 等等）构建。现在需要根据访问者的 IP 确定访问者的国家或地区。 已知： 访问者 IP 一个 ipdata.csv 文件，已放置在 S3 的桶 ow-public-us 中，格式如下 | ip_from | ip_to | country_code | country_name || ——– | ——– | ———— | ———— || 0 | 16777215 | - | - || 16777216 | 16777471 | AU | Australia || 16777472 | 16778239 | CN | China | 流程1. 引入 S3 Select1compile \"com.amazonaws:aws-java-sdk-s3:1.11.379\" 2. 构建 AmazonS3 对象123456789101112131415public AmazonS3 createAmazonS3()&#123; final AwsSupport awsSupport = new AwsSupport(); ClientConfiguration clientConfiguration = new ClientConfiguration(); clientConfiguration.setSocketTimeout((int) TimeUnit.SECONDS.toMillis(70)); AmazonS3ClientBuilder builder = AmazonS3ClientBuilder.standard() .withCredentials(awsSupport.getCredentials()) .withClientConfiguration( clientConfiguration); // ). region final Region region = awsSupport.getCurrentRegion(); if (region != null) &#123; builder.withRegion(region.getName()); &#125; return builder.build();&#125; 3. 构建 SelectObjectContentRequest 对象本文中输入的为 CSV 无压缩数据，输出为 Json 类型数据。 12345678910111213141516171819public static SelectObjectContentRequest createBaseCSVRequest(String bucket, String key, String query) &#123; SelectObjectContentRequest request = new SelectObjectContentRequest(); request.setBucketName(bucket); request.setKey(key); request.setExpression(query); request.setExpressionType(ExpressionType.SQL); InputSerialization inputSerialization = new InputSerialization(); inputSerialization.setCsv(new CSVInput()); inputSerialization.setCompressionType(CompressionType.NONE); request.setInputSerialization(inputSerialization); OutputSerialization outputSerialization = new OutputSerialization(); outputSerialization.setJson(new JSONOutput()); request.setOutputSerialization(outputSerialization); return request;&#125; 4. 转化 IP 为 IP LONG将 IP 字符串 转为 long 型数值，方便进行 IP 国家地区定位。 123456789101112131415161718public static long ip2Long(String ipAddress) &#123; if (Strings.isNullOrEmpty(ipAddress)) &#123; return 0L; &#125; long result = 0; String[] ipAddressInArray = ipAddress.split(\"\\\\.\"); for (int i = 3; i &gt;= 0; i--) &#123; long ip = Long.parseLong(ipAddressInArray[3 - i]); // left shifting 24,16,8,0 and bitwise OR // 1. 192 &lt;&lt; 24 // 1. 168 &lt;&lt; 16 // 1. 1 &lt;&lt; 8 // 1. 2 &lt;&lt; 0 result |= ip &lt;&lt; (i * 8); &#125; return result;&#125; 5. 请求并获取国家地区信息1234567891011121314151617181920212223242526// _1 代表第一列 ip_from// _2 代表第二列 ip_to// _3 代表第三列 country_code// 注意： SQL 中的变量需要用单引号括起来SelectObjectContentResult selectObjectContentResult = createAmazonS3().selectObjectContent(createBaseCSVRequest(\"ow-public-us\", \"ipdata.csv\", \"SELECT s.\\'country_code\\' FROM S3Object s WHERE s._1&lt;=\\'\" + ipLong + \"\\' AND s._2&gt;=\\'\" + ipLong + \"\\' LIMIT 1\"));selectObjectContentResult.getPayload() .getRecordsInputStream(new SelectObjectContentEventVisitor() &#123; @Override public void visit(SelectObjectContentEvent.RecordsEvent event) &#123; try &#123; String content = new String(event.getPayload().array(), \"utf-8\"); LOGGER.debug(\"Country is --&gt; &#123;&#125;\", content); JsonObject object = Json.fromJson(content, JsonObject.class); String country = object.get(\"_3\").getAsString(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 预警在编辑 S3 Select 的 SQL 语句时，使用下列形式是不支持的： 12345678// 出错：AmazonS3Exception: The column index at line 1, column 8 is invalid. Please check the service documentation and try again. (Service: Amazon S3; Status Code: 400; Error Code: InvalidColumnIndex;String sql = \"SELECT s.\\\"country_code\\\" FROM S3Object s WHERE s._1&lt;=\\'\" + ipLong +\"\\' AND s._2&gt;=\\'\" + ipLong + \"\\' LIMIT 1\";// 出错：AmazonS3Exception: Invalid Path component, expecting either an IDENTIFIER or STAR, got: LITERAL,at line 1, column 10. (Service: Amazon S3; Status Code: 400; Error Code: ParseInvalidPathComponent;String sql = \"SELECT s.\\'country_code\\' FROM S3Object s WHERE s._1&lt;=\\'\" + ipLong +\"\\' AND s._2&gt;=\\'\" + ipLong + \"\\' LIMIT 1\";// 出错：AmazonS3Exception: The column index at line 1, column 8 is invalid. Please check the service documentation and try again. (Service: Amazon S3; Status Code: 400; Error Code: InvalidColumnIndex;String sql = \"SELECT s.country_code FROM S3Object s WHERE s._1&lt;=\\'\" + ipLong +\"\\' AND s._2&gt;=\\'\" + ipLong + \"\\' LIMIT 1\"; 但是第一种写法在 Python 库 boto3 中是支持的，可以参见 参考2。 参考 使用 适用于 Java 的开发工具包 从对象中选择内容 - Amazon S3 Select — new revolution “at rest” - Medium","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"aws","slug":"it/java/aws","permalink":"https://linlshare.github.io/categories/it/java/aws/"}],"tags":[{"name":"aws","slug":"aws","permalink":"https://linlshare.github.io/tags/aws/"},{"name":"s3","slug":"s3","permalink":"https://linlshare.github.io/tags/s3/"}]},{"title":"海街日记","slug":"movie/海街日记","date":"2018-08-19T04:04:00.000Z","updated":"2019-01-13T11:37:46.622Z","comments":true,"path":"2018/08/19/movie/海街日记/","link":"","permalink":"https://linlshare.github.io/2018/08/19/movie/海街日记/","excerpt":"","text":"1234567891011导演: 是枝裕和编剧: 是枝裕和 / 吉田秋生主演: 绫濑遥 / 长泽雅美 / 夏帆 / 广濑铃 / 大竹忍 / 更多...类型: 剧情 / 家庭官方网站: umimachi.gaga.ne.jp制片国家/地区: 日本语言: 日语上映日期: 2015-05-14(戛纳电影节) / 2015-06-13(日本)片长: 127分钟又名: 海街女孩日记(港) / Kamakura Diary / Umimachi Diary / Our Little SisterIMDb链接: tt3756788 观后感大家都懂得宽恕了，怨恨终究没有湮灭亲情。 古都镰仓，有一家，唤香田氏。父亲与情人奔走，母亲亦离去，留下三女，幸、加乃、千佳，与外婆看管。外婆去逝后，三女相依为命，共同居住在父母留下的老宅中。老宅有庭院，有花草，还有 55 年历史的梅树，虽然没有父母，也自有一片温馨。 一日，传来父亲逝世的噩耗。姐妹们几分犹豫，但还是决定去参加父亲的葬礼。一下电车，就听到一个女中学生在挥手打招呼，询问后才知道是同父异母的妹妹浅野玲。玲不爱说话，似乎内心承担着许许多多她这个年纪不该承担的东西。是的，这些年是她在一直照顾着父亲，而生母已逝，继母无爱。三个姐姐临走时，玲赶了上来，拿出了父亲放在桌上一个信封，拆开看原是三个姐姐小时候的照片，小时候的一切历历在目。上电车时，幸姐看着孤独无依的玲说：来老家吧，我们一起生活。 随后，玲怀着对未来生活的憧憬，进入了这 “女生宿舍” 开始了四姐妹的生活。她们一起聊天，一起做饭，一起制作梅酒，一起去沙滩，一起去海猫食堂，一起穿和服放烟花。玲还加入了学校的足球队，成为了队中的宠儿，并认识了好朋友风太，跟他一起骑自行车穿越樱花隧道。 在与玲的相处过程中，姐妹们与父亲和解了，一致觉得父亲还是温柔的，至少还给她们留下这么个可爱的妹妹。 而与母亲的和解是在参加外婆的七回忌（死亡六周年追悼会）后，母女争吵的第二天，母亲送来了原本应该是前一天给与三个女儿还有玲的礼物，并打算去看看外婆的墓地后离去。幸顿了下，立即醒过神来，跟母亲一起去拜祭外婆，在回来路上母亲谈及女儿们还在酿梅酒，幸跑回家取出外婆酿的和四姐妹新酿的梅酒各一瓶，赶在母亲走之前作为礼物。此间的浓浓亲情，化解了漫漫怨恨。","categories":[{"name":"movie","slug":"movie","permalink":"https://linlshare.github.io/categories/movie/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://linlshare.github.io/tags/电影/"}]},{"title":"日本喪葬法事","slug":"culture/日本文化/日本喪葬法事","date":"2018-08-19T03:50:00.000Z","updated":"2019-01-13T11:37:46.354Z","comments":true,"path":"2018/08/19/culture/日本文化/日本喪葬法事/","link":"","permalink":"https://linlshare.github.io/2018/08/19/culture/日本文化/日本喪葬法事/","excerpt":"","text":"日本的喪葬法事真正體現了吾國以前對待逝者「慎終追遠」的思想。日本的法事莊重、肅穆、感恩、哀有度，對逝者有充分的尊重，對與會者是一場心靈的洗禮。以下內容翻譯自 法要に関する基礎知識 ，如有不當，懇請指正。 法事種類 逝後時期 補充 付け七日（つけなのか） 第 1 天 是喪葬儀式當日合起還骨修行進行頭七。 初七日（しょなのか） 第 7 天 しょしちなのか・初願忌（しょがんき）。多數情況下在還骨修行法事和遺體告別儀式中合併舉行。 二七日（ふたなのか） 第 14 天 にしちにち・以芳忌（いほうき）。 三七日（みなのか） 第 21 天 さんしちにち・洒水忌（しゃすいき）。 四七日（よなのか） 第 28 天 ししちにち・阿経忌（あぎょうき）。 初月忌（しょがっき） 月命日 死後第一個月的忌辰法事。 五七日（いつなのか） 第 35 天 ごしちにち・三十五日（ごしちにち）・小練忌（しょうれんき）。大部分情況下被省略了。有的地方進行除服儀式。 六七日（むなのか） 第 42 天 ろくしちにち・檀弘忌（だんこうき）。 七七日（なななのか） 第 49 天 しちしちにち・四十九日（しじゅうくにち）・忌明け・満中陰・尽七日・大練忌（だいれんき）。這是在到一周年忌辰为止的法事中最重要的。叫齊朋友，親属，讓僧侣增誦佛經\b，供養之后聚餐。常常也舉行納骨法事，除服送奠仪回禮。 百か日（ひゃっかにち）百ヶ日 第 100 天 出苦忌（しゅっくき），也叫卒哭忌(そつこくき)。故人成為新亡靈的法事。 一周忌 満 1 年 一般来说，它被称为「喪中」。打电话给朋友、亲戚、僧侣們，供養后聚餐。 三回忌 満 2 年 同上 七回忌 第 6 年 逝者的家庭、親戚來完成。七回忌 後規模逐漸縮小。 十三回忌 第 12 年 通常只由逝者的家庭来完成。 十七回忌 第 16 年 同上 二十三回忌 第 22 年 同上 二十七回忌 第 26 年 同上 三十三回忌 第 32 年 同上 五十回忌 第 49 年 同上。之後每 50 年可以有百回遠忌（第 99 年）、百五十回遠忌（第 149 年），但通常到此為止了。","categories":[{"name":"culture","slug":"culture","permalink":"https://linlshare.github.io/categories/culture/"},{"name":"日本文化","slug":"culture/日本文化","permalink":"https://linlshare.github.io/categories/culture/日本文化/"}],"tags":[{"name":"日本文化","slug":"日本文化","permalink":"https://linlshare.github.io/tags/日本文化/"}]},{"title":"开发一个第三方库的一般性和团队特定规则","slug":"it/code/开发一个第三方库的一般性和团队特定规则","date":"2018-08-13T02:19:00.000Z","updated":"2019-01-13T11:37:46.370Z","comments":true,"path":"2018/08/13/it/code/开发一个第三方库的一般性和团队特定规则/","link":"","permalink":"https://linlshare.github.io/2018/08/13/it/code/开发一个第三方库的一般性和团队特定规则/","excerpt":"","text":"目的在于将可以重复使用的轮子共用，避免重复造轮子，从而提高生产力。 一般性规则 避免重复造轮子 如果已有思路类似的轮子，请完善之而不是另起炉灶，除非对方的代码已经不堪维护。 谨慎设计 API 规范化类和方法的命名，注意多参函数参数的位置，过时的 API 使用 @Deprecated 注解。 避免引入其他库 当需要依赖第三方库时使用 compileOnly 而不是 implementation ，以避免将第三方库（特别是 support 包）打入其中，将其他第三方库的选择权交给集成者。 尽量用注解代替枚举 注解 @IntDef 、@StringDef 、 @Interface 和 @Retention 了解一下。 资源文件加上特殊前缀 第三方库的资源文件会跟集成者的相合并，因此需要在命名上独一无二。假定该库为 xxx-yyy ，那么所有资源文件建议加上前缀 xxx_yyy_ 。 提供可插拔依赖的方案 假定该库依赖于一个图片加载库，但不知集成者使用 Picasso 还是 Glide 或者其它图片加载库，这时可以使用 compileOnly 把它们都依赖进来（但不会打进最终的 aar 包），然后在代码中使用 Class.forName() (要捕获异常) 依次检测是否有对应的依赖，有则用之。 将Manifest中的参数变量化，并由 gradle.properties 控制 12345678910// build.gradledefaultConfig&#123; manifestPlaceholders = [ XXX_APP_KEY: &quot;$&#123;XXX_APP_KEY&#125;&quot;, ]&#125;// gradle.properties#XXXXXX_APP_KEY=82d79e3cec5013 有多个相关依赖，做聚合依赖 目的在于将依赖分组，这样可以当需时整组引入，当不需要时可以整组删除，不会留尾巴。下面以 retrofit2 依赖为例，进行依赖分组： 12345678910ext.versions=[ retrofit:'2.3.0',]dependencies &#123; implementation([ \"com.squareup.retrofit2:retrofit:$&#123;versions.retrofit&#125;\", \"com.squareup.retrofit2:converter-gson:$&#123;versions.retrofit&#125;\", \"com.squareup.retrofit2:adapter-rxjava2:$&#123;versions.retrofit&#125;\" ])&#125; 当依赖中有两个以上需要使用相同的版本号时，请抽取到ext.versions 中，如上例的 retrofit 依赖，以便于版本维护。 根据需求考虑是否提供no-op 如果开发的库只在 debug 模式中被使用，比如说 leakcanary 只在测试时进行内存泄漏检测，并不需要包含进生产包，那么可以提供生产的方法壳，里面为空实现。 仅仅在 debug 模式中引入代码 对应仅仅在 debug 模式中被使用的库，请使用 debugImplementation 注解。 使用 JitPack 做库的托管仓库 简单，快速 严格限制库的大小和方法数 README 要讲清楚用途和用法 12345要回答这几个问题：1. 有什么用？2. 怎样引入？3. 基本用法是什么？4. 支不支持自定义? 快速解决issue，多和提问者沟通 不断完善，坚持更新 特定于我们团队 使用 S3 Maven 发布第三库。 发布制品的规范。 groupId 统一为 com.mbs.android，artifactId 统一使用前缀 mbs- 布局只用 XML 写，相关的字符串、颜色值期望可被自定义的统统抽取出来。 资源 ID 统一使用 artifactId 的 - 替为_ 作为前缀。 整个库项目要包含两个模块：一是名为 app 的示例模块；二是名为 lib 的库依赖模块。 app 的示例模块使用包名 com.sample.&lt;库名&gt;，lib 模块使用包名com.mbs.&lt;库名&gt;。 打包脚本统一放置在lib/script 中，并统一为： 123456789101112131415161718#!/bin/bashSCRIPT_DIR=\"$(dirname \"$&#123;BASH_SOURCE:-$0&#125;\")\"# ROOT_DIR=`readlink \"$SCRIPT_DIR/../..\"`ROOT_DIR=`python -c 'import os,sys;print os.path.realpath(sys.argv[1])' \"$SCRIPT_DIR/../..\"`cd $ROOT_DIR# detect gradle commandGRADLE=`which gradle`GRADLE=\"$&#123;GRADLE:-$ROOT_DIR/gradlew&#125;\"\"$GRADLE\" clean \\ :lib:assembleRelease sleep 2s # wait the file being generated \"$GRADLE\" :lib:publish 每发布一次后请在代码中打上相应的 tag。 假如发布了版本 1.0.1，那么请执行： 12git tag v1.0.1git push origin v1.0.1 参考 开发第三方库最佳实践 - 掘金 mbs-stateview - gitlab","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"code","slug":"it/code","permalink":"https://linlshare.github.io/categories/it/code/"}],"tags":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"https://linlshare.github.io/tags/CodeStyle/"}]},{"title":"从序列化到 Gson 排错记录","slug":"it/java/exception/从序列化到 GSON 排错记录","date":"2018-08-10T15:15:00.000Z","updated":"2019-01-13T11:37:46.452Z","comments":true,"path":"2018/08/10/it/java/exception/从序列化到 GSON 排错记录/","link":"","permalink":"https://linlshare.github.io/2018/08/10/it/java/exception/从序列化到 GSON 排错记录/","excerpt":"","text":"写在前面序列化、反序列化和持久化序列化的目的在于对象中携带的数据之传输（进程间通信、客户端 - 服务器通信等），反序列化的目的在于将传输过来的数据重组成对象进行调用，持久化的目的在于将对象中携带的数据持久化保存在文件或数据库中，序列化和持久化的区别就在于此。 序列化的媒介有：对象输入输出流、JSON 字符串，以及 Android 独有的 Parcel。下面简述这几种方式。 第一种：对象输入输出流1234567891011121314151617// Dogpublic class Dog implements java.io.Serializable&#123; public String name;&#125;// 序列化FileOutputStream fos = new FileOutputStream(\"adog.tmp\");ObjectOutputStream oos = new ObjectOutputStream(fos);Dog dog = new Dog();dog.name = \"aDog\";oos.writeObject(dog);oos.close();// 反序列化FileInputStream fis = new FileInputStream(\"adog.tmp\");ObjectInputStream ois = new ObjectInputStream(fis);Dog dog = (Dog) ois.readObject();ois.close(); 第二种：JSON 字符串以广为使用的 GSON 库为例，GSON 是一个很常用的序列化和反序列化对象的 JSON 库。其最简单的使用方式是： 1234567891011121314// Catpublic class Cat &#123; public String name;&#125;Gson gson = new Gson();// 序列化对象Cat cat = new Cat();cat.name = \"aCat\";String catStr = gson.toJson(cat);// 反序列化对象Cat cat = gson.fromJson(catStr, Cat.Class); 第三种：ParcelAndroid 中的 Parcel，官方的文档中表明是为了提高 IPC 效率而生的，不建议进行持久化，因为一旦类的成员变量发生改变，旧的数据将不再可读。Parcel 对象存在于一段多进程共享的内存中，没有进行文件的读写操作，高效是显而易见的。 1234567891011121314151617181920212223242526272829303132333435// Hawkimport android.os.Parcel;import android.os.Parcelable;public class Hawk implements Parcelable &#123; public String name; protected Hawk(Parcel in) &#123; // 反序列化 name = in.readString(); &#125; public static final Creator&lt;Hawk&gt; CREATOR = new Creator&lt;Hawk&gt;() &#123; @Override public Hawk createFromParcel(Parcel in) &#123; return new Hawk(in); &#125; @Override public Hawk[] newArray(int size) &#123; return new Hawk[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // 序列化 dest.writeString(name); &#125;&#125; Github 上提供了一种方式将 Parcelable 对象字节化和反字节化，以便进行持久化，摘取如下： 123456789101112131415161718192021public class ParcelableUtil &#123; public static byte[] marshall(Parcelable parceable) &#123; Parcel parcel = Parcel.obtain(); parceable.writeToParcel(parcel, 0); byte[] bytes = parcel.marshall(); parcel.recycle(); // not sure if needed or a good idea return bytes; &#125; public static &lt;T extends Parcelable&gt; T unmarshall(byte[] bytes, Parcelable.Creator&lt;T&gt; creator) &#123; Parcel parcel = unmarshall(bytes); return creator.createFromParcel(parcel); &#125; public static Parcel unmarshall(byte[] bytes) &#123; Parcel parcel = Parcel.obtain(); parcel.unmarshall(bytes, 0, bytes.length); parcel.setDataPosition(0); // this is extremely important! return parcel; &#125;&#125; 对象是千奇百怪的，导致我们序列化和反序列化的时候可能会出现一些不可思议的错误信息。下面就我遇到的一些情况为例，书写排错的血泪史。 1. AssertionError：Impossible背景在对某广告 SDK 的 Ad 对象进行序列化时出现该错误，瞬间惊呆了，序列化一个实现了简单的对象怎么不可能了？","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"exception","slug":"it/java/exception","permalink":"https://linlshare.github.io/categories/it/java/exception/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Gson","slug":"Gson","permalink":"https://linlshare.github.io/tags/Gson/"}]},{"title":"Genesis 1 @Old Testament","slug":"language/English/Bible/Genesis 1 @Old Testament","date":"2018-08-09T15:29:00.000Z","updated":"2019-01-13T11:37:46.587Z","comments":true,"path":"2018/08/09/language/English/Bible/Genesis 1 @Old Testament/","link":"","permalink":"https://linlshare.github.io/2018/08/09/language/English/Bible/Genesis 1 @Old Testament/","excerpt":"","text":"In the beginning God created the heaven and the earth. 起 初 神 創 造 天 地 。 And the earth was without form, and void; and darkness was upon the face of the deep. And the Spirit of God moved upon the face of the waters. 地 是 空 虛 混 沌 ． 淵 面 黑 暗 ． 神 的 靈 運 行 在 水 面 上 。 12void-&gt; a large empty space And God said, Let there be light: and there was light. 神 說 、 要 有 光 、 就 有 了 光 。 And God saw the light, that it was good: and God divided the light from the darkness. 神 看 光 是 好 的 、 就 把 光 暗 分 開 了 。 And God called the light Day, and the darkness he called Night. And the evening and the morning were the first day. 神 稱 光 為 晝 、 稱 暗 為 夜 ． 有 晚 上 、 有 早 晨 、 這 是 頭 一 日 。 And God said, Let there be a firmament in the midst of the waters, and let it divide the waters from the waters. 神 說 、 諸 水 之 間 要 有 空 氣 、 將 水 分 為 上 下 。 1234firmament-&gt; the sky or heavenmidst-&gt; middle And God made the firmament, and divided the waters which were under the firmament from the waters which were above the firmament: and it was so. 神 就 造 出 空 氣 、 將 空 氣 以 下 的 水 、 空 氣 以 上 的 水 分 開 了 ． 事 就 這 樣 成 了 。 And God called the firmament Heaven. And the evening and the morning were the second day. 神 稱 空 氣 為 天 ． 有 晚 上 、 有 早 晨 、 是 第 二 日 。 And God said, Let the waters under the heaven be gathered together unto one place, and let the dry land appear: and it was so. 神 說 、 天 下 的 水 要 聚 在 一 處 、 使 旱 地 露 出 來 ． 事 就 這 樣 成 了 。 And God called the dry land Earth; and the gathering together of the waters called he Seas: and God saw that it was good. 神 稱 旱 地 為 地 、 稱 水 的 聚 處 為 海 ． 神 看 著 是 好 的 。 And God said, Let the earth bring forth grass, the herb yielding seed, and the fruit tree yielding fruit after his kind, whose seed is in itself, upon the earth: and it was so. 神 說 、 地 要 發 生 青 草 、 和 結 種 子 的 菜 蔬 、 並 結 果 子 的 樹 木 、 各 從 其 類 、 果 子 都 包 著 核 ． 事 就 這 樣 成 了 。 1234567forth-&gt; [only after verb]formal going out from a place or point, and moving forwards or outwards.herb-&gt; a small plant that is used to improve the taste of food, or to make medicine.yield-&gt; [transitive] to produce crops, profits etc.-&gt; [transitive] to produce a result, answer, or piece of information. And the earth brought forth grass, and herb yielding seed after his kind, and the tree yielding fruit, whose seed was in itself, after his kind: and God saw that it was good. 於 是 地 發 生 了 青 草 、 和 結 種 子 的 菜 蔬 、 各 從 其 類 、 並 結 果 子 的 樹 木 、 各 從 其 類 、 果 子 都 包 著 核 。 神 看 著 是 好 的 ． And the evening and the morning were the third day. 有 晚 上 、 有 早 晨 、 是 第 三 日 。 And God said, Let there be lights in the firmament of the heaven to divide the day from the night; and let them be for signs, and for seasons, and for days, and years: 神 說 、 天 上 要 有 光 體 、 可 以 分 晝 夜 、 作 記 號 、 定 節 令 、 日 子 、 年 歲 ． 12sign-&gt; [countable] (also star sign) a group of stars, representing one of 12 parts of the year, that some people believe influences your behaviour and your life And let them be for lights in the firmament of the heaven to give light upon the earth: and it was so. 並 要 發 光 在 天 空 、 普 照 在 地 上 ． 事 就 這 樣 成 了 。 And God made two great lights; the greater light to rule the day, and the lesser light to rule the night: he made the stars also. 於 是 神 造 了 兩 個 大 光 、 大 的 管 晝 、 小 的 管 夜 ． 又 造 眾 星 。 12lesser--&gt; [formal] not as large, as important, or as much as something else And God set them in the firmament of the heaven to give light upon the earth, 就 把 這 些 光 擺 列 在 天 空 、 普 照 在 地 上 、 And to rule over the day and over the night, and to divide the light from the darkness: and God saw that it was good. 管 理 晝 夜 、 分 別 明 暗 ． 神 看 著 是 好 的 ． And the evening and the morning were the fourth day. 有 晚 上 、 有 早 晨 、 是 第 四 日 。 And God said, Let the waters bring forth abundantly the moving creature that hath life, and fowl that may fly above the earth in the open firmament of heaven. 神 說 、 水 要 多 多 滋 生 有 生 命 的 物 ． 要 有 雀 鳥 飛 在 地 面 以 上 、 天 空 之 中 。 123456abundantly-&gt; in large quantities.hath-&gt; hasfowl-&gt; any bird And God created great whales, and every living creature that moveth, which the waters brought forth abundantly, after their kind, and every winged fowl after his kind: and God saw that it was good. 神 就 造 出 大 魚 、 和 水 中 所 滋 生 各 樣 有 生 命 的 動 物 、 各 從 其 類 ． 又 造 出 各 樣 飛 鳥 、 各 從 其 類 ． 神 看 著 是 好 的 。 123456whale-&gt; a very large animal that lives in the sea and looks like a fish, but is actually a mammal.moveth-&gt; moving creature.wingled-&gt; having wings. And God blessed them, saying, Be fruitful, and multiply, and fill the waters in the seas, and let fowl multiply in the earth. 神 就 賜 福 給 這 一 切 、 說 、 滋 生 繁 多 、 充 滿 海 中 的 水 ． 雀 鳥 也 要 多 生 在 地 上 。 1234fruitful-&gt; producing good results.multiply-&gt; [intransitive and transitive] to increase by a large. And the evening and the morning were the fifth day. 有 晚 上 、 有 早 晨 、 是 第 五 日 。 And God said, Let the earth bring forth the living creature after his kind, cattle, and creeping thing, and beast of the earth after his kind: and it was so. 神 說 、 地 要 生 出 活 物 來 、 各 從 其 類 ． 牲 畜 、 昆 蟲 、 野 獸 、 各 從 其 類 ． 事 就 這 樣 成 了 。 1234cattle-&gt; cows and bulls kept on a farm for their meat or milk.creep-&gt; if something such as an insect, small animal, or car creeps, it moves slowly and quietly. And God made the beast of the earth after his kind, and cattle after their kind, and every thing that creepeth upon the earth after his kind: and God saw that it was good. 於 是 神 造 出 野 獸 、 各 從 其 類 ． 牲 畜 、 各 從 其 類 ． 地 上 一 切 昆 蟲 、 各 從 其 類 ． 神 看 著 是 好 的 。 And God said, Let us make man in our image, after our likeness: and let them have dominion over the fish of the sea, and over the fowl of the air, and over the cattle, and over all the earth, and over every creeping thing that creepeth upon the earth. 神 說 、 我 們 要 照 著 我 們 的 形 像 、 按 著 我 們 的 樣 式 造 人 、 使 他 們 管 理 海 裡 的 魚 、 空 中 的 鳥 、 地 上 的 牲 畜 、 和 全 地 、 並 地 上 所 爬 的 一 切 昆 蟲 。 12dominion-&gt; the power or right to rule people or control something. So God created man in his own image, in the image of God created he him; male and female created he them. 神 就 照 著 自 己 的 形 像 造 人 、 乃 是 照 著 他 的 形 像 造 男 造 女 。 And God blessed them, and God said unto them, Be fruitful, and multiply, and replenish the earth, and subdue it: and have dominion over the fish of the sea, and over the fowl of the air, and over every living thing that moveth upon the earth. 神 就 賜 福 給 他 們 、 又 對 他 們 說 、 要 生 養 眾 多 、 遍 滿 地 面 、 治 理 這 地 ． 也 要 管 理 海 裡 的 魚 、 空 中 的 鳥 ． 和 地 上 各 樣 行 動 的 活 物 。 1234replenish-&gt; to put new supplies into something, or to fill something again.subdue-&gt; to defeat or control a person or group, especially using force. And God said, Behold, I have given you every herb bearing seed, which is upon the face of all the earth, and every tree, in the which is the fruit of a tree yielding seed; to you it shall be for meat. 神 說 、 看 哪 、 我 將 遍 地 上 一 切 結 種 子 的 菜 蔬 、 和 一 切 樹 上 所 結 有 核 的 果 子 、 全 賜 給 你 們 作 食 物 。 And to every beast of the earth, and to every fowl of the air, and to every thing that creepeth upon the earth, wherein there is life, I have given every green herb for meat: and it was so. 至 於 地 上 的 走 獸 、 和 空 中 的 飛 鳥 、 並 各 樣 爬 在 地 上 有 生 命 的 物 、 我 將 青 草 賜 給 他 們 作 食 物 ． 事 就 這 樣 成 了 。 12wherein-&gt; in which place or part. And God saw every thing that he had made, and, behold, it was very good. And the evening and the morning were the sixth day. 神 看 著 一 切 所 造 的 都 甚 好 ． 有 晚 上 、 有 早 晨 、 是 第 六 日 。 12behold-&gt; to see or to look at something – sometimes used humorously. ​","categories":[{"name":"language","slug":"language","permalink":"https://linlshare.github.io/categories/language/"},{"name":"English","slug":"language/English","permalink":"https://linlshare.github.io/categories/language/English/"},{"name":"Bible","slug":"language/English/Bible","permalink":"https://linlshare.github.io/categories/language/English/Bible/"}],"tags":[{"name":"Bible","slug":"Bible","permalink":"https://linlshare.github.io/tags/Bible/"},{"name":"English","slug":"English","permalink":"https://linlshare.github.io/tags/English/"}]},{"title":"Linux Shell","slug":"it/tool/Linux Shell","date":"2018-08-06T12:25:00.000Z","updated":"2019-01-13T11:37:46.483Z","comments":true,"path":"2018/08/06/it/tool/Linux Shell/","link":"","permalink":"https://linlshare.github.io/2018/08/06/it/tool/Linux Shell/","excerpt":"","text":"SET 命令用途： 可以设置 shell 的执行方式，不带参数时输出环境变量。 1&gt; set [+-abCdefhHklmnpPtuvx] 注： 1. [-] 表示设置参数 2. [+] 表示取消设置参数 示例： 1234567&gt; tmp=\"nice day\"&gt; $tmpnice day&gt; set | grep tmptmp=\"nice day\"&gt; unset tmp&gt; $tmp SSH 命令用途： 连接远程计算机。 1&gt; ssh -p &lt;port&gt; &lt;user&gt;@&lt;hostname&gt; &lt;remote cmd&gt; 注： [-p] 指定端口号，默认为 22 [remote cmd] 远程执行命令并显示到本地继续工作 配置 [.ssh] 在 [~/.ssh/config] 中， 1234Host &lt;myhost&gt;User &lt;username&gt;HostName &lt;ip&gt;IdentityFile ~/env/&lt;username&gt;.id_rsa 可快速进行ssh连接，ssh myhost 。 进程管理命令前后台切换命令 bg、fg12&gt; fg &lt;task id&gt;&gt; bg &lt;task id&gt; 注： 当使用这两个任务时，如果提示 no job control in this shell ，可以使用 set -m 命令开启。 当一个任务进程在执行过程中想要暂时挂起，可以使用 ctrl + Z ，若要终止，进入 suspended状态，使用 ctrl + C ，进入terminated 状态。 挂起的任务可以通过 fg 重新调到前台运行，或者通过 bg 调到后台运行。 若要终止挂起的任务，可以使用 kill &lt;pid&gt; 。 &amp; 字符的作用用途： 放在启动参数后面表示设置此进程为后台进程，这是称之为 job。通过 jobs 命令可以查看当前有多少后台运行的命令。 示例： 12&gt; ./run.sh &amp;&gt; jobs -l 注： [-l] 显示pid。 nohup 保住进程当用户关闭窗口时，终端会受到HUP（hungup）信号，从而关闭其所有子进程。 若要让命令不被终止，有两种处理方式： 让进程忽略HUP信号， nohup 之所为 让进程运行在新的会话中，setsid 、(&lt;cmd&gt; &amp;)之所为 示例： 1234&gt; nohup ping www.ibm.com &amp;&gt; setsid ping www.ibm.com&gt; (ping www.ibm.com &amp;)&gt; ps -ef | grep www.ibm.com 如果事前没有使用前面的方式保住进程，那么可以使用如下流程进行补救： 先 ctrl+Z 挂起进程，使用 jobs -l 获取进程号； 使用 bg &lt;pid&gt; 将其放入后台运行； 再使用 disown &lt;pid&gt; ，可以避免 HUP 信号的影响。 使用 nohup 命令时默认会将输出保存到文件 nohup.ou ，可以通过以下方式修改保存文件 12&gt; nohup $&#123;my_app&#125; &gt; common.out 2&gt; error.out&gt; nohup $&#123;my_app&#125; &gt; all_in.out &amp; ps 进程快照process status, 列出当前运行的进程的快照。命令参数： [-A] 显示所有进程； [-e] 显示环境变量； [-f] 显示程序间的关系； [-aux] 显示所有包含其他使用者的进程。 查找特定的名称的进程时通常与 grep 命令连用，以查找 Wechat 相关进程为例： 12# 将所有进程中的包含 Wechat 的连同表头一起输出&gt; ps -ef | grep -Ei 'PID|Wechat' 在我的电脑上输出结果是： 12UID PID PPID C STIME TTY TIME CMD501 1079 1 0 Thu10AM ?? 3:23.55 /Applications/WeChat.app/Contents/MacOS/WeChat kill 终止进程终止进程的命令，参数有： [-9] 强制删除； 文件管理命令tail 查看文件末尾1&gt; tail [-n &lt;line numbers&gt;] [-f] &lt;file&gt; 注： [-n] 可以指定显示的日志行数，不指定默认为 10 行 [-f] 可以监视文件的增长，简缩的命令为 tailf 与之相对应的显示前面几条日志的命令为 head cat 一次显示文件内容1&gt; cat [-ns] &lt;file&gt;... 注： [-n] 可以显示行号 [-s] 可以合并连续的空行为一 与之相对的命令为 tac 可以从尾到头显示文件内容（Mac 好像不支持） 示例： 123456# 一次显示整个文件cat &lt;file1&gt; &lt;file2&gt;# 创建新文件cat &gt; &lt;file&gt;# 将多个文件合并为一个文件cat &lt;file1&gt; &lt;file2&gt; &gt; &lt;file&gt; more 逐页显示文件内容1&gt; more [-s] [-&lt;line numbers&gt;] [+&lt;line numbers&gt;] &lt;file&gt; 注： [-s] 可以合并连续的空行为一 [-n] 可以定义每次上滚 n 行 [+n] 可以指定从第 n 行开始显示 ctrl +F 向上滚动一屏，空格键 向下滚动一屏 = 显示当前显示的行数范围及文件名称 示例： 12# 从第 100 行开始显示 debug.log， 每次滚动 10 行，合并空行为一&gt; more -s -10 +100 debug.log less 分页显示文件内容比 more 强大的真正意义上的分页查看文件命令，more 一次会加载整个文件，而 less 是逐页加载。less 还支持向上翻页和搜索。 1&gt; less [-gimNsS] [-x &lt;numbers&gt;] &lt;file&gt; 注： [-g] 高亮先前的搜索结果 [-i] 搜索时忽略大小写 [-m] 显示已显示内容的百分比 [-N] 显示行号 [-s] 合并显示连续的空行为一 [-S] 行过长时舍弃超出部分 [-x 4] 设置tab 为规定的数量的空格 / 向上查找 ? 向下查找 n 正向重复查找 N 反向重复查找 b 向后翻一页 d 向后翻半页 y 向前翻一页 u 向前翻半页 q 退出 示例： 12345# 查找历史命令中包含run的命令&gt; history | less/run# 假设找到要运行的命令序号为 100，按 q 退出，再按如下重新执行&gt; !100 grep 查找文件内容grep (global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来) 1&gt; grep &lt;option&gt; &lt;file&gt;... [-A num] 显示匹配行后面 num 行 [-B num] 显示匹配行前面 num 行 [-C num] 显示匹配行前后各 num 行 [–color=auto] 匹配结果自动配色 [-m num] 当匹配了 num 行后不再继续查找 [-n] 显示匹配行所在行号 [-v] –invert-match 输出不匹配的行 [-i] 不区分大小写 [-E] –extended-regexp 支持扩展的正则表达式 示例： 12345# 查询日志文件中包含 keyword 但不含 keywords 的行，最多输出 10 行匹配，且显示匹配行前后 2 行&gt; grep -C 2 -n -m 10 keyword *.log | grep -v keywords# 同时查找多个关键字&gt; grep -E 'a_key|b_key' a.file tar 解压缩文件tar 最初的设计目的是将文件备份到磁带上（tape archie），故名 tar。 tar 代表未压缩的 tar 文件，已经压缩的 tar 文件会附加压缩文件的扩展名，如 .tar.gz 表示经过 gzip 压缩。 命令参数： [-x] –extract 解开 tar 文件 [-z] –gzip,–gunzip,–unzip 调用 gzip 执行压缩或解压缩 [-f] –file 指定要处理的文件名 [-t] –list 列出 tar 文件中包含的文件的信息 123456# 解压 .tar.gz 文件到当前文件夹&gt; tar -zxf a_file.tar.gz# 解压 .tar 文件到 tmp 文件夹&gt; tar -xf b_file.tar tmp/# gzip 压缩文件 c_file 和目录 d_dir 到 out.tar.gz&gt; tar -czvf out.tar.gz c_file d_dir awk 文本分析文本处理语言和工具，用于在文件中查找与模式匹配的行并在这些行上执行指定的操作，名称取自三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。可参见 AWK程序设计语言 、 awk命令 - IBM 以及 Linux awk 命令 - runoob.com 进行完整的学习。下面简单介绍下语法： 1&gt; awk '&#123;[pattern] action&#125;' &#123;filenames&#125; # 行匹配语句 awk '' 只能用单引号 Pattern 支持： 正则表达式，eg. awk &#39;/smith?/&#39; a_file 关系表达式，eg. awk &#39;$1 &gt; $3&#39; b_file 模式的组合，以上模式的组合 与或非 || &amp;&amp; !，值为真则匹配 圆括号 () ，组合匹配 逗号 , ，匹配前一个的匹配 BEGIN 和 END 模式 BEGIN 模式在读取输入前执行 END 模式在读取输入后执行 示例： 1234567891011# 指定分隔符(默认是空格或 TAB)，有两种写法## 用逗号分割&gt; awk -F, '&#123;print $3&#125;' a_file&gt; awk 'BEGIN&#123;FS=\",\"&#125; &#123;print $3&#125;' a_file## 先用空格分割再用逗号分割&gt; awk -F '[ ,]' '&#123;print $3&#125;' a_file&gt; awk 'BEGIN&#123;FS=\"[ ,]\"&#125; &#123;print $3&#125;' a_file# 忽略匹配文本的大小写&gt; awk 'BEGIN&#123;IGNORECASE=1&#125; /a_key/' a_file# 获取 Kafka 进程的 ID&gt; ps aux | grep server.properties | grep -v grep | awk '&#123;print $2&#125;' alias 添加别名树状查看文件： 123# 注意：这种方式会列出所有文件，建议使用 brew instal tree. 因为可以使用 `tree -L [depth]`自定义深度&gt; alias tree=\"find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'\"&gt; source ~/.zshrc 取消别名： 1&gt; unalias tree ctrl 移动光标 Windows 快捷键 Mac 快捷键 功能 ctrl + 左右键 option + 左右键 在单词之间跳转 ctrl + a 同左 跳到本行的行首 ctrl + e 同左 跳到页尾 ctrl + u 同左 删除当前光标前面的文字 ctrl + k 同左 删除当前光标后面的文字 ctrl + w、ctrl + d 同左 对于当前的单词进行删除操作，w删除光标前面的单词的字符，d则删除后面的字符 ctrl + y 同左 恢复删除的文字 ctrl + l 同左 清屏 同步一台服务器中的文件到另一台基本思路：拷贝文件到本地，然后覆盖另一台上的同名文件。命令如下，其中 server-a 以及 server-b 是定义在文件 ~/.ssh/config 中的 HOST 。 1ssh server-a \"cat ~/test.txt\" &gt; ~/Desktop/test.txt;scp ~/Desktop/run.sh server-b:~/test.txt Tree 命令中文乱码1tree -N folder 更改文件访问权限 以下摘引自 鸟哥的 Linux 私房菜 第六章，略有删减。 （1）数字类型改变文件权限 Linux文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限，文件的权限字符为：-rwxrwxrwx， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4w:2x:1 每种身份( owner/group/others )各自的三个权限( r/w/x )分数是需要累加的，例如当权限为：[-rwxrwx---] 分数则是 owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0 变更权限的指令chmod的语法是这样的： 1chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更。 （2）符号类型改变文件权限 还有一个改变权限的方法呦！从之前的介绍中我们可以发现，基本上就九个权限分别是 (1)user (2)group (3)others三种身份啦！那么我们就可以藉由 u, g, o来代表三种身份的权限！此外， a则代表 all 亦即全部的身份！那么读写的权限就可以写成 r, w, x！也就是可以使用底下的方式来看： 格式 chmod u g o a +(加入) -(除去) =(设定) r w x 文件或目录 例子 chmod a = r .bashrc 来实作一下吧！假如我们要设定一个文件的权限成为-rwxr-xr-x时，基本上就是： user (u)：具有可读、可写、可执行的权限； group 与 others (g/o)：具有可读与执行的权限。 1234chmod u=rwx,go=rx .bashrc# 注意喔！那个 u=rwx,go=rx 是连在一起的，中间并没有任何空格！chmod a+w .bashrc# 增加.bashrc这个文件的每个人均可写入的权限 正则方式删除文件（Delete files with regular expression）偶然间，使用 ll 命令发现桌面上有许多 ~$ 开头的文件，是用微软三件套打开后暂存文件，原文件已经删除了，可这暂存文件还隐存在桌面上，于是想要批量删除它们。 12# 在当前目录找到以 “~$” 开头的文件，然后执行删除操作find . -name \"~\\$*\" -delete wget 下载文件1wget \"http://mirrors.hust.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz\" 查看系统信息1234567891011121314151617181920212223242526# 查看内核/操作系统/CPU信息uname -a # 查看操作系统版本head -n 1 /etc/issue # 查看CPU信息cat /proc/cpuinfo # 查看计算机名hostname # 查看环境变量env # 查看内存使用量和交换区使用量free -m # 查看各分区使用情况df -h # 查看指定目录的大小du -sh &lt;目录名&gt; # 查看内存总量grep MemTotal /proc/meminfo # 查看空闲内存量grep MemFree /proc/meminfo # 查看系统运行时间、用户数、负载uptime # 查看系统负载cat /proc/loadavg # 查看所有磁盘分区fdisk -l","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://linlshare.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://linlshare.github.io/tags/Shell/"}]},{"title":"陆奇的故事","slug":"person/陆奇的故事","date":"2018-05-29T13:54:00.000Z","updated":"2019-01-13T11:37:46.630Z","comments":true,"path":"2018/05/29/person/陆奇的故事/","link":"","permalink":"https://linlshare.github.io/2018/05/29/person/陆奇的故事/","excerpt":"","text":"陆奇简历 1987年，毕业毕业于复旦大学，获计算机科学学士、硕士学位。 1992年，就读于卡耐基梅隆大学，获计算机科学博士学位。 1998年8月，陆奇加入雅虎公司，2007年晋升为雅虎执行副总裁。 2008年8月，陆奇离开雅虎，并于次年1月正式加盟微软任网络服务集团总裁，2013年出任微软集团全球执行副总裁，2016年9月宣布从微软离职。 2017年1月17日加入百度，担任百度集团总裁兼首席运营官、百度董事及董事会副主席 ，主要负责百度的产品、技术、销售及市场运营，兼任百度智能驾驶事业群组总经理。 2018年5月17日，百度发布内部全员邮件，宣布集团总裁兼首席运营官陆奇由于个人和家庭原因，无法继续全职在北京工作，将从7月起不再担任上述职务，但仍将继续担任集团公司副董事长。 陆奇选择百度的标准 能够承载陆奇的只有巨头或拥有巨头前景的公司，而且要有全球化雄心； 陆奇需要一个COO/总裁级别的职位来匹配他的地位和抱负，并且足够放权让他施展； 最好还是一家技术驱动，工程师驱动的公司。 陆奇出入，百度股价情况自陆奇进入百度工作至今，百度股价累计涨幅接近60%。百度2018年第一季度财报显示，本季度百度营收为209亿元人民币（约合33.3亿美元），同比增长31%，其中移动营收占比78%；净利润为人民币67亿元（约合11亿美元），与上年同期相比增长277%。 本周三（5月16日）时，百度股价还大涨了4.47%，创下历史新高，市值达985亿美元，眼见即将破千亿美元大关。 然而随着陆奇突然离职，百度下重注的All-in AI战略顿时蒙上了许多阴影。受此消息影响，百度股价暴跌9.54%，收报253.01美元，市值882亿美元，一夜蒸发94亿美元。 5月19日，同期腾讯市值为4917.99亿美元，阿里市值为5010.48亿美元。 引用 但可能在今年年内某一天，这个“副董事长”的title就会宣布卸去。而陆奇肯定也不好因此归隐退休，他才57岁，而且依然为高强度工作而4点起床锻炼身体，更主要的是他满怀一腔雄心和抱负，看好中国科技的高速发展进程，也对带领中国公司成为国际化巨头深怀期待。 — 量子位 我的感悟陆奇先生是一个有大抱负的人，而且又很坚毅，这是他有而我没有的可贵品质，也是我一直很想成功但没有成功的最大原因，我做事嫌累，容易放弃，所以才落到如此境界。 参考 陆奇失陆，造化由李 - 量子位","categories":[{"name":"person","slug":"person","permalink":"https://linlshare.github.io/categories/person/"}],"tags":[{"name":"故事","slug":"故事","permalink":"https://linlshare.github.io/tags/故事/"},{"name":"人物","slug":"人物","permalink":"https://linlshare.github.io/tags/人物/"}]},{"title":"APP启动优化","slug":"it/android/APP启动优化","date":"2018-01-20T07:28:00.000Z","updated":"2019-01-13T11:37:46.361Z","comments":true,"path":"2018/01/20/it/android/APP启动优化/","link":"","permalink":"https://linlshare.github.io/2018/01/20/it/android/APP启动优化/","excerpt":"","text":"1. 去除启动黑屏1.1 在style.xml中定义两种主题： 12345678&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight.NoActionBar\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt;&lt;/style&gt;&lt;style name=\"AppTheme.Splash\"&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;false&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/bg_splash&lt;/item&gt;&lt;/style&gt; 1.2 在AndroidManifest.xml中设置MainActivity的主题为AppTheme.Splash 123456789&lt;activity android:name=\"xxx.MainActivity\" android:icon=\"@mipmap/ic_launcher\" android:theme=\"@style/AppTheme.Splash\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 1.3 在MainActivity的onCreate调用super的方法之前设置回原先的主题 12345@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; setTheme(R.style.AppTheme); super.onCreate(savedInstanceState);&#125; 2. 分析启动卡顿","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"android","slug":"it/android","permalink":"https://linlshare.github.io/categories/it/android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://linlshare.github.io/tags/Android/"}]},{"title":"Spring Boot","slug":"it/java/base/Spring Boot","date":"2018-01-07T04:03:00.000Z","updated":"2019-01-13T11:37:46.446Z","comments":true,"path":"2018/01/07/it/java/base/Spring Boot/","link":"","permalink":"https://linlshare.github.io/2018/01/07/it/java/base/Spring Boot/","excerpt":"","text":"简述 推出时间：从Maven仓库的时间看是2016.7.28 目的：摆脱大量的XML配置文件以及复杂的Bean依赖关系，快速、敏捷地开发新一代基于Spring框架的应用程序 思想：约定优于配置（convention over configuration） 框架功能：集成大量常用第三库配置（Jackson、JDBC、Mongo、Redis、Mail等） 入门创建定时任务 在Spring Boot 的主类加入 @EnableScheduling 注解，启用定时任务的配置； 1234567@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 使用 @Scheduled(fixedRate = 1000) 注解实现类需要定时执行的方法。 12345678910@Componentpublic class ScheduledTasks implements Runnable&#123; private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\"); @Override @Scheduled(fixedRate = 1000) public void run() &#123; System.out.println(\"Current: \" + dateFormat.format(new Date())); &#125;&#125;","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://linlshare.github.io/tags/SpringBoot/"}]},{"title":"MySql","slug":"it/java/persistence/MySql","date":"2018-01-06T04:02:00.000Z","updated":"2019-01-13T11:37:46.456Z","comments":true,"path":"2018/01/06/it/java/persistence/MySql/","link":"","permalink":"https://linlshare.github.io/2018/01/06/it/java/persistence/MySql/","excerpt":"","text":"Mysql安装mac下安装mysql 1brew install mysql 启动和停止12345# 启动mysql.server start# 停止mysql.server stop 修改密码1mysqladmin -uroot password \"new_password\" 登录1mysql -uroot -p 备注 默认的端口号为 3306 Mac下简单易用的MySql管理工具：Sequel Pro","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"persistence","slug":"it/java/persistence","permalink":"https://linlshare.github.io/categories/it/java/persistence/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"MySql","slug":"MySql","permalink":"https://linlshare.github.io/tags/MySql/"}]},{"title":"Spring MVC","slug":"it/java/base/Spring MVC","date":"2018-01-05T03:10:00.000Z","updated":"2019-01-13T11:37:46.446Z","comments":true,"path":"2018/01/05/it/java/base/Spring MVC/","link":"","permalink":"https://linlshare.github.io/2018/01/05/it/java/base/Spring MVC/","excerpt":"","text":"Spring MVC","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://linlshare.github.io/tags/SpringMVC/"}]},{"title":"Spring","slug":"it/java/base/Spring","date":"2018-01-05T03:10:00.000Z","updated":"2019-01-13T11:37:46.447Z","comments":true,"path":"2018/01/05/it/java/base/Spring/","link":"","permalink":"https://linlshare.github.io/2018/01/05/it/java/base/Spring/","excerpt":"","text":"概述轻量级控制反转和面向切面的容器框架。 功能： 使用基本的JavaBean代替EJB（Enterprise JavaBean） 优点： 低侵入性 高服用性 DI有效降低耦合度 AOP提供了通用任务的集中管理 ORM（对象实体映射）和DAO简化对数据库的访问 高开放性，并不强制 核心： IoCInversion of Control，控制反转，其另一个名字是依赖注入（Dependency Injection），就是有Ioc容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，DI和IoC是从不同角度描述的同一件事情，就是指通过引入IoC容器，利用依赖关系注入的方式，实现对象的解耦。 粘合剂，将对象之间的耦合交给IoC容器进行，从而达到解耦的目的。 AOP面向切面编程，从动态角度研究。 功能：将系统级别处理（日志管理、调试管理、事务管理、缓存等等）分离出来，模块化，而不影响业务逻辑。 专门用于处理系统中分布于各个模块中的交叉关注点的问题。AOP 代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。 AOP使用： 定义普通业务组件 定义切入点 定义增强处理 代理对象的方法 = 被代理对象的方法 + 增强处理 AOP关键概念： 横切性关注点（Cross Cut Concern）：一个独立的服务，不与其他业务逻辑耦合。可能遍布在系统的各个角落，也可能遍布在系统的处理流程之中。 切面（Aspect）：一个关注点的模块化，生成对应的类，这个类就叫切面。切面可能会横切多个对象。 通知（Advice）：对横切性关注点的具体实现。通知类型有：before、throw和after等。多数使用拦截器作为通知模型 连接点（Joi Point）：程序执行中的某个特定点，比如某方法调用或处理异常时，也就是Advice在应用程序上执行的点或时机。 切入点（Point Cut）：可以设定具体的方法上是否需要横切性关注点的实现。 织入（Weave）：把切面连接到其他的应用程序类型或者对象上。 目标对象（Target Object）：被一个或多个切面所通知的对象。 AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约。 引入（Introduction）：也被称为内容类型声明。声明额外的方法或者某个类型的字段。 开发环境搭建直接通过IDEA新建一个Spring项目。 Ioc注入 Spring通过&lt;null/&gt;注入null值 通过ref=&quot;xxBean&quot; 进行bean注入，通过value=&quot;xxValue&quot; 进行值注入 通过&lt;constructor-arg&gt; 注入构造参数值 通过&lt;property&gt; 注入属性值 通过&lt;list&gt;注入list数据，通过&lt;array&gt; 注入array数据，通过&lt;map&gt; 注入map数据，通过&lt;set&gt; 注入set数据 设置lazy-init=&quot;true&quot; 进行延迟初始化 bean的作用域有两种，分别是 singleton 和 prototype。singleton是默认的scope，其实现方式是通过注册表方式注册道单例缓存池。设置为prototype则每次向Spring容器请求获取Bean都返回一个全新的Bean。 基于注解的配置开启方式：在spring的config文件的&lt;beans&gt; 下增加 123&lt;context:annotation-config/&gt; &lt;!--设置对指定的包名下的Spring注解生效--&gt;&lt;context:component-scan base-package=”com.demo”&gt; 使用： 注解 描述 应用域 @Required 进行依赖检查，只判断字段是否使用了setter注入，若无则抛出异常 bean属性的setter方法 @Autowired 自动装配，默认按类型装配 bean属性的setter方法、非setter方法、构造函数、属性 @Qualifier 实现类的类名 作为@Autowired的补充，当对应的属性有多个实现时，声明@Qualifier帮助其自动装配 @Resource 默认按名称装配，当找不到与名称匹配的bean才会按类型装配 属性（属于JSR-250的注解） @Component、@Service、@Controller、@Repository @Component用于说明一个类是Spring容器管理的类，@Service、@Controller、@Repository是@Component的细化，分别代表服务层、控制层和持久层 类 Q&amp;A如何将配置 SpringApplication 的配置分离到单独的配置类一般情况下，我们使用如下方式启动一个 Spring。 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 但是，如果要把配置分离呢？ （1）编写 Spring 配置类，注意要指定组件扫描位置，因为通常配置类的位置跟 Application 类的位置不一致，而默认情况下Spring 只扫描配置类所在包及其子包的组件。 1234@SpringBootApplication@ComponentScan(basePackages = &#123;\"com.example\"&#125;)public class SpringConfig &#123;&#125; （2）修改之前的 Application，移除注解，传入 SpringConfig。 12345public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringConfig.class); &#125;&#125; 分离后的好处是，可以将配置统一管理，以及更灵活地在启动 Spring，特别是有必须在 Spring 启动前 Ready 的依赖组件。 参考 springboot快速入门及@SpringBootApplication注解分析","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://linlshare.github.io/tags/Spring/"}]},{"title":"Maven","slug":"it/java/base/Maven","date":"2017-12-29T11:34:00.000Z","updated":"2019-01-13T11:37:46.437Z","comments":true,"path":"2017/12/29/it/java/base/Maven/","link":"","permalink":"https://linlshare.github.io/2017/12/29/it/java/base/Maven/","excerpt":"","text":"Maven项目管理工具 构建项目（Builds） 依赖管理（Dependencies） 配置管理（SCMs） 发布管理（Release） 文档编制（Documentation） 报告（Reporting） 特点： 微内核（只解析XML，其他由Maven插件处理） 约定优于配置 定义项目模型 安装： 12brew install mavenmvn -version 创建Maven项目 12mvn archetype:generate -DgroupId=org.flyne.demo -DartifactId=maven-demo -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false# 这是一个goal 项目结构 123456789101112131415maven-demo|– pom.xml`– src|– main| `– java| `– org| `– flyne| `– demo| `– App.java`– test`– java`– org`– flyne`– demo`– AppTest.java POM文件，项目对象模型（Project Object Model） 项目的核心配置文件 123456789101112131415161718&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tiantian.mavenTest&lt;/groupId&gt; &lt;artifactId&gt;projectB&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 构建项目 12345678910mvn package# 这是一个phasemvn compile# 这也是一个phase，包含如下的阶段：# 1. validate# 2. generate-sources# 3. process-sources# 4. generate-resources# 5. process-resources# 6. compile Maven常用阶段（phase） validate：验证项目是否正确，所有必须的信息是否可用 compile：编译项目的源码 test：使用单元测试框架对编译后的源代码逆行测试 package：接受编译好的代码，打包成可发布的格式，如jar verify：运行任何检查，验证包是否有效且达到质量标准 install：将包安装到Maven本地仓库，供本地其他Maven项目使用 deploy：将最终的包复制到远程仓库，供其他开发人员和Maven项目使用 clean：清理上一次构建生成的文件 site：生成项目站点文档","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://linlshare.github.io/tags/Maven/"}]},{"title":"JSP","slug":"it/java/base/JSP","date":"2017-12-29T10:56:00.000Z","updated":"2019-01-13T11:37:46.434Z","comments":true,"path":"2017/12/29/it/java/base/JSP/","link":"","permalink":"https://linlshare.github.io/2017/12/29/it/java/base/JSP/","excerpt":"","text":"JSPJavaServer Pages，是一门脚本语言，用于动态生成HTML、XML等。可以混合Java进行编程。 运行于JSP容器中，流行的有Tomcat、Jetty。 JSP的解析过程：JSP —&gt;Servlet SUN公司的历史全称：Stanford University Network year event 1982 创立 1986 纳斯达克上市 1995 开发了Java技术，由JCP维护 2009 被Oracle收购 JSP 规范 规范 发布时间 JSP 1.2 JSR-53 2001 JSP 2.0 JSR-152 2003 JSP 2.3 JSR-245 2006 JSP处理JSP 引擎从磁盘加载 JSP 页面并将其转换为一个 servlet 的内容。这种转换是非常简单的，所有模板文本转换为 println()语句，所有 JSP 元素转换为 Java 代码实现页面的相应的动态行为。 JSP 引擎编译 servlet 到一个可执行的类中，并将原始请求转发给一个 servlet 引擎。 JSP基本语法JSP程序，由&lt;% 开始，%&gt;结束。 输出方式： 使用内置的java对象 123&lt;% out.println(\"xxx\");%&gt; 使用JSP表达式 1&lt;%=\"xxx\"%&gt; ​","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://linlshare.github.io/tags/JSP/"}]},{"title":"Servlet","slug":"it/java/base/Servlet","date":"2017-12-29T06:55:00.000Z","updated":"2019-01-13T11:37:46.445Z","comments":true,"path":"2017/12/29/it/java/base/Servlet/","link":"","permalink":"https://linlshare.github.io/2017/12/29/it/java/base/Servlet/","excerpt":"","text":"ServletServer + Applet，服务端小程序 编写流程 写一个类，继承自HttpServlet，重写init和destroy方法和service方法 在web.xml中写入&lt;servlet&gt; 节点，并完成&lt;servlet-name&gt;和&lt;servlet-class&gt;子节点 在web.xml中写入&lt;servlet-mapping&gt;节点，并完成&lt;servlet-name&gt;和&lt;url-pattern&gt;子节点 url-pattern 规则Servlet处理流程init() -&gt; service() -&gt; destroy() Servlet 包结构 pkg class desc javax.servlet Servlet ServletRequest ServletResponse ServletConfig ServletContext GenericServlet ServletInputStream ServletOutputStream javax.servlet.http HttpServletRequest HttpServletResponse HttpSession HttpServlet Cookie javax.servlet.annotation javax.servlet.descriptor","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"https://linlshare.github.io/tags/Servlet/"}]},{"title":"Tomcat","slug":"it/java/base/Tomcat","date":"2017-12-28T16:56:00.000Z","updated":"2019-01-13T11:37:46.447Z","comments":true,"path":"2017/12/29/it/java/base/Tomcat/","link":"","permalink":"https://linlshare.github.io/2017/12/29/it/java/base/Tomcat/","excerpt":"","text":"Tomcat安装 从官网下载压缩包，放入程序安装的路径，需要的话设置下环境变量和Catalina_home， mac下可以通过homebrew安装，命令为： 1brew install tomcat 安装完成后，提示信息为： 1234567==&gt; CaveatsTo have launchd start tomcat now and restart at login: brew services start tomcatOr, if you don't want/need a background service you can just run: catalina run==&gt; Summary🍺 /usr/local/Cellar/tomcat/8.5.24: 632 files, 12.8MB, built in 51 seconds Catalina是一个servlet容器，用于处理servlet。Tomcat的核心由三部分组成： Web容器 处理静态页面 Servlet容器 处理Servlet文件 JSP容器 将JSP翻译为Servlet 目录结构 bin 执行文件目录，包含启动和关闭tomcat的脚本 conf web.xml webapp的默认配置 server.xml 服务器默认配置文件 Catalina localhost 配置WEB站点的根目录和虚拟子目录 lib 存放公用的jar包，包含jsp等支持 webapps 默认的WEB站点根目录 logs 存放日志 work jsp的工作目录 配置WEB站点的根目录和虚拟子目录WEB站点的根目录：webapps物理上存储的位置，默认为tomcat的webapps目录，可以通过以下方式自定义： 修改conf/server.xml文件的Host节点的appBase值，该值可以是绝对路径和相对路径： 12&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 在&lt;catalina_home&gt;/conf/Catalina/localhost下增加ROOT.xml 文件，内容为： 1&lt;Context docBase=\"&lt;站点根目录&gt;\" path=\"\" reloadable=\"true\" /&gt; docBase 表示对应path的文档根路径。 path 为空表示更改根目录的上下文环境。 reloadable` 属性标示tomcat是否要在运行时监视class文件是否有改动，若有改动则自动重新加载webapps。 在conf/server.xml文件中配置Context节点，修改docBase属性 虚拟子目录：通过浏览器访问的路径，其修改方式如下： 在&lt;catalina_home&gt;/conf/Catalina/localhost下增加XML文件，内容为： 1&lt;Context docBase=\"&lt;站点物理位置&gt;\" reloadable=\"true\" /&gt; 此时，XML文件名就是虚拟子目录的名称，而path属性弃用。 在conf/server.xml文件中配置Context节点，修改path属性 部署描述符web.xml即是web应用的部署描述符 目录的默认页面通过修改根目录下web.xml中的&lt;welcom-file-list&gt;节点进行全局配置，通过修改单个webapp下的WEB-INFx下的web.xml文件中的&lt;welcom-file-list&gt;节点","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://linlshare.github.io/tags/Tomcat/"}]},{"title":"Nginx","slug":"it/java/base/Nginx","date":"2017-12-28T03:56:00.000Z","updated":"2019-01-13T11:37:46.444Z","comments":true,"path":"2017/12/28/it/java/base/Nginx/","link":"","permalink":"https://linlshare.github.io/2017/12/28/it/java/base/Nginx/","excerpt":"","text":"Nginx是一个Web服务器，也可以用作反向代理，负载平衡器和HTTP缓存。 安装 编译安装 linux下安装方式： 12345yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel //下载依赖库configure --prefix=/opt/nginx/ //进行环境配置,设置安装位置maks &amp;&amp; make install // 编译安装 mac下安装方式： 1brew install nginx // 会自动安装需要的依赖 提示信息： 123456789The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.To have launchd start nginx now and restart at login: brew services start nginxOr, if you don't want/need a background service you can just run: nginx HomeBrew 是一款自由即开放源代码的软件包管理系统，用于Mac OS X系统上的软件安装过程。 依赖列表： gcc 编译程序 pcre pcre-devel configure过程需要的正则表达式 zlib zlib-devel 传输内容压缩 openssl openssl-devel 开启https支持需要 注意：devel包含普通包，且多了头文件，编译时需要。 补充：Https、SSL与OpenSSL三者关系 HTTPS Hyper Text Transfer Protocol over Secure Socket Layer HTTP的加密版本，底层使用SSL作为加密协议 SSL Secure Socket Layer（安全套接字层） 在客户端和服务器之间建立一条SSL安全通道的加密协议 OpenSSL – TLS/SSL协议的开源实现，提供开放库和命令行程序 TLS Transport Layer Security（传输层安全协议） 用于两个应用程序之间提供保密性和数据完整性 启动与关闭进入nginx安装目录的sbin文件夹 执行nginx，将启动两个nginx进程，分别是： master 进程：守护进程 work进程 ：用于响应请求。 执行nginx -s stop 关闭进程 执行nginx -s reload重启进程 自启动：编辑系统启动自动执行的脚本文件，在centos下是/etc/rc.d/rc.local ，增加nginx启动命令即可。 配置编辑 nginx.conf 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# 顶层配置信息，管理服务器级别行为worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;# event指令与事件模型有关，配置处理连接有关信息events &#123; worker_connections 1024;&#125;# http指令处理http请求http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改 成off。 sendfile on; #防止网络阻塞 #tcp_nopush on; #长连接超时时间，单位是秒 #keepalive_timeout 0; keepalive_timeout 65; #开启gzip压缩输出 #gzip on; #虚拟主机的配置，根据server_name进行匹配，当匹配不到时将请求发给第一个server server &#123; #监听端口 listen 8080; #域名可以有多个，用空格隔开 server_name localhost; #默认编码 charset utf-8; #定义本虚拟主机的访问日志 #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; allow 192.168.10.100; allow 172.29.73.0/24; deny all; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; location 表达式 syntax：location [=|~|~*|^~|@] /uri/ {…} 分为两种匹配模式 ： 普通字符串匹配：无开头引导字符或以=开头表示普通字符串的匹配 正则匹配：以~或~*开头表示正则匹配~*表示不区分大小写 多个location时匹配规则：先普通后正则，只识别URI部分。例如请求为 /test/1/abc.do?arg=xxx： 先查找是否有=开头的精确匹配，即location = /test/1/abc.do {...} 再查找普通匹配，以 最大前缀 为规则，如有以下两个location 12location /test/ &#123;...&#125;location /test/1 &#123;...&#125; 则匹配后一项 匹配到一个普通格式后，搜索并未结束，而是暂存当前结果，并继续搜索正则模式 在所有正则模式location中找到第一个匹配项后，以此匹配项为最终结果。所有正则匹配项匹配规则受定义前后顺序影响，但普通匹配不会 如果未找到正则匹配项，则以3中缓存的结果为最终结果 如果一个匹配都没有，返回404 location =/ {…} 与 location / {...} 的差别： 前一个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它 而后一个正相反，所有请求必然以/开头，所以没有其他匹配结果时一定会执行到它。 location ^~ / {...} ^~表示非正则，表示匹配到此模式后不再继续正则搜索。因为一个请求在普通匹配规则下没得到其它普通匹配结果时，最终会匹配到这里，而这里又不允许正则，相当于匹配到此为止。 /test/abc.jsp deny all; 拒绝请求，返回403 allow 192.168.10.0/24; 允许指定IP段通过proxy_pass http://192.168.1.61:8080; 将匹配的请求代理到另一地址进行处理 @类似于变量定义，比如： 1234error_page 403 @page403;locaion @page403 &#123; proxy_pass http://www.xxx.com&#125;","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"java","slug":"it/java","permalink":"https://linlshare.github.io/categories/it/java/"},{"name":"base","slug":"it/java/base","permalink":"https://linlshare.github.io/categories/it/java/base/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://linlshare.github.io/tags/Java/"},{"name":"Nginx","slug":"Nginx","permalink":"https://linlshare.github.io/tags/Nginx/"}]},{"title":"Kotlin的特性","slug":"it/kotlin/Kotlin的特性","date":"2017-12-17T12:07:00.000Z","updated":"2019-01-13T11:37:46.462Z","comments":true,"path":"2017/12/17/it/kotlin/Kotlin的特性/","link":"","permalink":"https://linlshare.github.io/2017/12/17/it/kotlin/Kotlin的特性/","excerpt":"","text":"time streams try-with-resources 函数扩展，给types、classes或者interfaces新增方法 null safe 不需要new，后缀声明类型 自动转换有getters和setters综合属性的类型，例如自动替换getDay()为day，看起来像个field，但实际上是property-getter和setter的概念的融合 函数表达式lambdas，it：单个参数的隐式名称 Higher-order函数，一个参数式函数或者返回时函数的函数 扩展函数表达式 = 扩展函数 + 函数表达式 + 高阶函数 12345678910111213fun SQLiteDatabase.inTransaction(func: (SQLiteDatabase) -&gt; Unit) &#123; beginTransaction() try &#123; func(this) setTransactionSuccessful() &#125; finally &#123; endTransaction() &#125;&#125;db.inTransaction &#123; it.db.delete(\"users\", \"first_name = ?\", arrayOf(\"Jake\"))&#125; in-line函数 Anko 定义UI","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"kotlin","slug":"it/kotlin","permalink":"https://linlshare.github.io/categories/it/kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linlshare.github.io/tags/Kotlin/"}]},{"title":"Kotlin 函数","slug":"it/kotlin/Kotlin函数","date":"2017-12-16T12:07:00.000Z","updated":"2019-01-13T11:37:46.461Z","comments":true,"path":"2017/12/16/it/kotlin/Kotlin函数/","link":"","permalink":"https://linlshare.github.io/2017/12/16/it/kotlin/Kotlin函数/","excerpt":"","text":"函数声明123fun double(x: Int): Int&#123; return 2 * x&#125; 描述：以fun为关键字，后接函数名，函数名后使用括号包裹函数参数，最后使用“:”+ 数据类型说明返回类型。 这里的返回类型采用后缀方式表示，意味着有时会被省略，通常是在能通过上下文推断的时候。 函数用法顶层函数直接调用 1val result = double(2) 成员函数要先拿到对象实例才能调用 1Sample().foo() 函数参数采用Pascal表示法定义，即 name: type ，参数采用逗号分隔，每个参数都须有显式类型： 123fun powerOf(number: Int, exponent: Int)&#123; ......&#125; 默认参数参数可以设置默认值，当省略时使用默认值。 解决的问题： 减少方法重载 123456789101112131415161718192021//1fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size)&#123; ......&#125;//2open class A &#123; open fun foo(i: Int = 10)&#123;......&#125;&#125;class B: A()&#123; override fun foo(i: Int)&#123;......&#125;&#125;//3fun foo(bar: Int = 0, baz: Int)&#123;......&#125;foo(baz = 1) // bar使用默认值0//4fun foo(bar: Int = 0, baz: Int = 1, qux:()-&gt;Unit)&#123;......&#125;foo(1)&#123; println(\"hello\") &#125; // baz使用默认值1foo()&#123; println(\"hello\") &#125; // bar使用默认值0，baz使用默认值1 默认值通过在类型后面的 = 及给出的值来定义； 覆盖方法总是使用与基类型方法相同的默认参数值，当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值； 若一个默认参数在一个无默认值的参数之前，那么该默认值只能通过命名参数调用来使用； 若最后一个lambda表达式参数从括号外传给函数调用，那么允许默认参数不传值。 且慢，从括号外传递函数作为函数参数？ 减少嵌套。 命名参数调用函数时使用命名的函数参数。 解决的问题： 【可读性】当一个函数有大量参数时，看代码时很难直接看出值当意义所在； 【明确值的传递】当默认参数在前面定义时，后面的值只能通过命名参数传递，否则会混乱，不清楚是赋给默认参数的还是无默认参数的值。 返回Unit的函数如果一个函数不返回任何有用的值，则其返回类型是Unit，不需要显式定义和返回。 1234fun printlnHello(name: String?):Unit&#123; if (name == null) println(\"Hello $&#123;name&#125;\") else println(\"Hi there!\") return Unit&#125; 相当于Java中的void。 单表达式函数表达式与语句的区别： 表达式（Expression），能被计算出结果的短语，包括带运算符的表达式、直接量表达式、对象和数组初始化表达式、函数定义表达式、属性访问表达式、函数调用表达式、创建对象表达式。 语句（Statement）：表达式用于产生值，而语句用于make something happen。有些语句是由具有副作用（side-effect）的表达式构成，比如赋值和函数调用表达式、声明新的变量和定义函数时。 单表达式即是一个表达式。 12fun double(x: Int): Int = x * 2 // 带运算符的表达式fun double(x: Int) = x * 2 //当返回类型可推断时省略返回类型 显式返回类型具有块代码体的函数必须始终显式指定返回类型，除非返回类型是Unit。Kotlin不会推断具有块代码体的函数的返回类型。 可变数量的参数（Varargs）这跟java的可变形参类似，但kotlin使用varargs修饰，而java使用... 123456789101112fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt;&#123; val result = ArrayList&lt;T&gt;() for(t in ts) result.add(t) return result&#125;val list = asList(1,2,3)//3val a = arrayOf(0,9,8)val ll = asList(1,2,*a,3) 注意： 多个形参时，只有一个参数可以使用vararg； 若vararg参数不是最后一个时，可以通过命名参数传值； 若有一数组，希望将其内容传入该函数时，使用伸展操作符（*）拉平传入。 中缀表示法解决的问题： 定义新的运算规则 条件： 成员函数或者扩展函数； 只有一个参数； 使用infix修饰fun。 123infix fun Int.x(other: Int): Int = this * otherval result = 1 x 2 函数作用域 顶层函数：直接值文件顶层声明的函数； 局部函数：声明在函数里面的函数； 成员函数：在类或对象内部定义的函数； 扩展函数：扩展一个类的新功能而无需继承该类或使用装饰者这样的任何设计模式。 泛型函数具备泛型参数的函数 123fun &lt;T&gt; singletonList(item: T): List&lt;T&gt;&#123; //......&#125; 尾递归函数12tailrec fun findFixPoint(x: Double = 1.0): Double = if(x == Math.cos(x)) x else findFixPoint(Math.cos(x)) 将循环算法改为递归函数形式来写，而无堆栈溢出风险，编译器会对该递归进行优化。 使用限制：函数必须将自身调用作为它执行的最后一个操作。目前只在JVM后端支持。 Lambda表达式函数引用12345fun isOdd(x: Int) = x % 2 !=0fun isOdd(s: String) = s == \"brilling\" || s == \"slithy\" || s == \"tove\"val numbers = listOf(1,2,3)println(numbers.filter(::isOdd)) //可以重载 ::isOdd 是函数类型(Int) -&gt; Boolean 的一个值，::用于将函数作为值进行传递。 使用成员函数或扩展函数进行引用： String.() -&gt; CharArray 这样就限定了传入的函数必须为String 的扩展函数。 高阶函数将函数用作参数或返回值的函数。 Lock 函数示例： 1234567891011121314151617181920fun &lt;T&gt; lock(lock: Lock, body: ()-&gt;T):T&#123; lock.lock() try&#123; return body() &#125;finally&#123; lock.unlock() &#125;&#125;// 调用方式1fun toBeSynchronized() = sharedresource.operation()val result = lock(lock, ::toBeSynchronized)// 调用方式2val result = lock(lock, &#123;sharedResource.operation()&#125;)// 调用方式3val result = lock(lock)&#123; sharedResource.operation()&#125; Map函数示例 123456789101112fun &lt;T,R&gt; List&lt;T&gt;.map)(transform: (T) -&gt; R): List&lt;R&gt;&#123; val result = arrayListOf&lt;R&gt;() for(item in this) result.add(transform(item)) return result&#125;// 调用1val doubled = ints.map&#123; value -&gt; value * 2 &#125;// 调用2val doubled = ints.map&#123; it * 2 &#125; Lambda表达式规则： 总是被大括号包围着； 参数在-&gt;之前声明（参数类型可以省略）； 函数体在-&gt;后面； 如果函数的最后一个参数是一个函数，并且传递的是一个lambda表达式，则可以在圆括号之外指定它，以减少嵌套； 如果lambda是调用的唯一参数，则调用中的圆括号可以完全省略； 如果函数的字面值只有一个参数，那么可以它的声明可以省略（连同-&gt;），其名称为it； 如果lambda表达式的参数未使用，那么可以使用下划线取代其名称（1.1 起）； 1map.forEach&#123; _, value -&gt; prinln(\"$value!\") &#125; 内联函数解决的问题：高阶函数带来的运行时效率损失，因为每一个函数都是一个对象，并且会捕获一个闭包，即那些在函数题内会访问到的变量。 使用inline修饰符修饰函数，使得编译器不为每个函数创建一个对象，而是进行内联，以lock函数为例，就是生成如下代码： 12345678lock(l)&#123; foo() &#125;l.lock()try&#123; foo()&#125;finally&#123; l.unlock()&#125; 当然也可以禁用内联，使用noinline修饰符 123inline fun foo(inlined: ()-&gt; Unit, noinline notInlined: ()-&gt; Unit)&#123; // .....&#125; 非局部返回（位于lambda表达式中，但退出包含它的函数）在Kotlin中我们可以只使用一个正常的、非限定的return来退出一个命名或匿名的函数。这意味着要退出一个lambda表达式，我们必须使用一个标签🏷️，并且在lambda表达式内部🈲️止使用裸return，因为lambda表达式不能使包含它的函数返回： 1234567891011fun foo()&#123; ordinaryFunction&#123; return // Error，不能使foo在此处返回 &#125;&#125;fun foo()&#123; inlineFunction&#123; return // Ok, 内联的可以做到 &#125;&#125;","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"kotlin","slug":"it/kotlin","permalink":"https://linlshare.github.io/categories/it/kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://linlshare.github.io/tags/Kotlin/"}]},{"title":"Github","slug":"it/tool/Github","date":"2017-12-02T11:35:00.000Z","updated":"2019-01-13T11:37:46.477Z","comments":true,"path":"2017/12/02/it/tool/Github/","link":"","permalink":"https://linlshare.github.io/2017/12/02/it/tool/Github/","excerpt":"","text":"配置Github环境安装Git参见 Git 官网 配置ssh-key 检查ssh-key的设置 12# 第一次安装时没有该目录$ cd ~/.ssh 生成新ssh-key 12# rsa算法，C后面接邮箱账号；表示根据邮箱生成key$ ssh-keygen -t rsa -C &quot;example@example.com&quot; 添加ssh-key到Github 登陆Github–&gt;Account Settings—&gt;SSH Public keys —&gt; add another public keys 测试 1$ ssh -T git@github.com 设置用户信息 123## 当电脑只需用到一个Github账号时，可以使用全局的用户信息$ git config --global user.name &quot;name&quot;//用户名$ git config --global user.email &quot;example@example.com&quot;//邮箱 当电脑需要多个Github账号切换时 配置第二个账号的ssh-key 12$ssh-keygen -t rsa -C &quot;example@example.com&quot;$ssh-add ~/.ssh/id_rsa_second 配置ssh-key到github 修改~/.ssh/config文件 12345678#默认的githubHost github.com HostName github.com IdentityFile ~/.ssh/id_rsa#第二个githubHost github_second HostName github.com IdentityFile ~/.ssh/id_rsa_second 使用别名pull/push代码 1git clone git@github_second:username/reponame 取消global用户信息 12git config --global --unset user.namegit config --global --unset user.email 每次commit前都要执行下面代码 12git config user.email &quot;example@example.com&quot;git config user.name &quot;name&quot; 生成&lt;github_name&gt;.github.io博客 登录github，创建一个repository，命名为&lt;github_name&gt;.github.io 进入项目，点击Settings，在Github Pages部分点击Launch automatic page generator，下一步，下一步就可以了。 通过http://&lt;github_name&gt;.github.io访问你的静态站点 使用git提交更新 Tip：当对git命令不熟悉时，可以通过$git xxx --help查看帮助文档，注意xxx代表不熟悉的命令，比如clone。也可以查看廖雪峰的Git教程和Git官网学习。 克隆远程仓库 1234# 电脑中只有一个github账号时git clone https://github.com/username/reponame# 电脑中有两个个github账号时，github_second表示第二个账号的hostgit clone git@github_second:username/reponame 移除所有文件 1234# 进入仓库文件夹（工作区）$cd reponame# 强制移除所有文件$git rm -rf . 添加更新到仓库暂存区中 可以复制要添加的文件到仓库文件夹（工作区）中，然后执行命令$git add * 提交更新到本地仓库 1$git commit -a -m &quot;注释&quot; 提交更新到远程服务器 12# origin表示源仓库$git push origin master 分支管理新建分支12345678910# 切换到分支newbranch，-b表示没有就创建（branch/build）$git checkout -b newbranch# 创建文件hello$touch hello# 添加到暂存区$git add hello# 提交到本地仓库$git commit -m &quot;add a file hello&quot;# 提交到远程仓库的newbranch分支，-u表示set-upstream$git push -u origin newbranch 设置默认分支在项目的Settings–&gt;Branches下可以修改Default branch修改默认分支，其实就是把版本库的头指针HEAD指向了其他分支，通过$git branch -r（r表示remotes）可以查看所有远程分支和默认分支。 合并分支1$git merge newbranch 切换分支12# 切换到master分支工作$git checkout master 删除分支Git在删除分支时为避免数据丢失，默认禁止删除尚未合并的分支。所以，如果分支尚未合并，使用$git branch -d newbranch会报错。使用$git branch -D newbranch可以强制删除分支。 删除远程分支1$git push origin --delete testbranch 使用github协同开发开发者fork源仓库每个开发者都从源仓库中Fork代码，然后独立开发。完了，在pull request合并到源仓库中。 把开发者仓库clone到本地1234# 电脑中只有一个github账号时git clone https://github.com/username/reponame# 电脑中有两个个github账号时，github_second表示第二个账号的hostgit clone git@github_second:username/reponame 构建功能分支进行开发123456789101112131415161718192021222324&gt;&gt;&gt; git checkout develop# 切换到`develop`分支&gt;&gt;&gt; git checkout -b feature-discuss# 分出一个功能性分支&gt;&gt; touch discuss.js# 假装discuss.js就是我们要开发的功能&gt;&gt; git add .&gt;&gt; git commit -m &apos;finish discuss feature&apos;# 提交更改&gt;&gt;&gt; git checkout develop# 回到develop分支&gt;&gt;&gt; git merge --no-ff feature-discuss# 把做好的功能合并到develop中&gt;&gt;&gt; git branch -d feature-discuss# 删除功能性分支&gt;&gt;&gt; git push origin develop# 把develop提交到自己的远程仓库中 pull request点击绿色按钮pull request，将自己仓库的分支合并到源分支中 管理员测试、合并 review代码 12345678&gt;&gt; git checkout develop# 进入他本地的develop分支&gt;&gt; git checkout -b khhhshhh-develop# 从develop分支中分出一个叫khhhshhh-develop的测试分支测试我的代码&gt;&gt; git pull https://github.com/khhhshhh/practice.git develop# 把我的代码pull到测试分支中，进行测试 合并分支 123&gt;&gt; git checkout develop&gt;&gt; git merge --no-ff khhhshhh-develop&gt;&gt; git push origin develop 使用热键使用热键可以便捷地使用 Github。使用热键 ? 查看所有可用的热键，也可以访问 Github Help 获取详细的热键列表。常用的热键如下：","categories":[{"name":"it","slug":"it","permalink":"https://linlshare.github.io/categories/it/"},{"name":"tool","slug":"it/tool","permalink":"https://linlshare.github.io/categories/it/tool/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://linlshare.github.io/tags/Github/"}]},{"title":"干支纪年与六十进制","slug":"culture/中国文化/干支纪年与六十进制","date":"2016-04-06T08:56:41.000Z","updated":"2019-01-13T11:37:46.353Z","comments":true,"path":"2016/04/06/culture/中国文化/干支纪年与六十进制/","link":"","permalink":"https://linlshare.github.io/2016/04/06/culture/中国文化/干支纪年与六十进制/","excerpt":"","text":"借着对数字系统的研究兴致，我又研究了下我中华干支纪年法的奥妙。当然，这里说的只是冰山一角，并不能透彻地呈现干支纪年的奥义。 什么是干支？所谓干支，是由十天干和十二地支组合而成，共六十对，称为六十甲子。看下面的表格。 天干 甲 乙 丙 丁 戊 己 庚 辛 壬 癸 甲 乙 … 地支 子 丑 寅 卯 辰 巳 午 未 申 酉 戌 亥 … 不会读的，看下面： 十天干：甲(jiǎ)、乙(yǐ) 、丙(bǐng)、丁(dīng)、戊(wù)、己(jǐ)、庚(gēng)、辛(xīn)、壬(rén)、癸(guǐ ) 十二地支：子(zì)、丑(chǒu)、寅(yín)、卯(mǎo)、辰(chén)、巳(sì)、 午(wǔ)、未(wèi)、申(shēn)、酉(yǒu)、戌(xū)、亥(hài) 10 天干和 12 地支按顺序搭配，天干按天干的顺序循环走下去，地支按照地支的顺序循环走下去。并由此产生了 60 个干支对。 甲子 乙丑 丙寅 丁卯 戊辰 己巳 庚午 辛未 壬申 癸酉 甲戌 乙亥 丙子 丁丑 戊寅 己卯 庚辰 辛巳 壬午 癸未 甲申 乙酉 丙戌 丁亥 戊子 己丑 庚寅 辛卯 壬辰 癸巳 甲午 乙未 丙申 丁酉 戊戌 己亥 庚子 辛丑 壬寅 癸卯 甲辰 乙巳 丙午 丁未 戊申 己酉 庚戌 辛亥 壬子 癸丑 甲寅 乙卯 丙辰 丁巳 戊午 己未 庚申 辛酉 壬戌 癸亥 为什么是60呢？这其实是一个算术问题：用数字0-9代表天干，字母A-L代表地支，数字和字母各自按自己的顺序循环排列结成对，刚开始时是0A，1B，…，问经历多少对后再次回到0A？答案很简单，求10和12的最小公倍数即可，就是60。 经历 60 对后再次回到甲子，这就是六十甲子的含义。其中天干经历了6次循环（$60\\div10$），而地支经历了5次循环（$60\\div12$）。 第一个甲子年据说是始于黄帝纪年，约公元前 2697 年。近点说，上一个甲子年就是 1984 年。今年则是 丙申猴年。 补充一点：为什么丙申年是猴年呢？因为十二生肖跟十二地支是对应的，它们的关系如下： 地支 子 丑 寅 卯 辰 巳 午 未 申 酉 戌 亥 生肖 鼠 牛 虎 兔 龙 蛇 马 羊 猴 鸡 狗 猪 如果用六十进制的角度看问题？根据上一篇的博文，我们可以给出60进制的定义：底为60的60个符号表示一个数。还没看的可以点击看看：从十进制数谈到巴比伦数字系统。 在干支纪年法中，有10天干和12地支，共22个基本符号，组合成60个字符。我们现在使用的公元纪年法是10进制的，以耶稣诞生为元年。 我们现在要探讨的是这两种历法中的数学联系。但问题是这两种历法的元年不一样，干支纪年法早在黄帝那时就有了，比公元历法多了 2697 年。$2697\\div60 = 44\\cdots57$，也就是说公元1年开始再过3年（即公元4年），公元历法第一次看到了干支历法的甲子年。换句话说，公元 4 年是甲子年。又或者说，公元历法后退 3 年就可以看作跟干支历法同一元年了。（仅仅是为了计算方便） 这给我们一种计算上的技巧，把我们要计算的公元年份减去 3 ，所得的数再用这种特殊的 60 进制表示，看个位就可以看出是干支历法种对应的年了。 比如：2016 - 3 = 2013。将2013转换成60进制，为： $$(2013)_{10} = 33\\times60^{1}+33\\times60^{0} = （丙申.丙申）_{60}$$ 注：$33\\div10$ 余 3 代表天干的丙，$33\\div12$余 9 代表申。这里仿照 IP地址的点分记法。 分隔符（.）前表示 60 的倍数来着，这里表示从公元4年开始经过了丙申（33）个甲子年，分隔符后面的丙申就是该年份（2016）的干支历法表示。 那么，问题来了，2020年你可以用点分记法写出它的干支历法表示吗？ 本文标题: 干支纪年与六十进制文章作者: Lshare许可协议: ©署名-非商用-相同方式共享 4.0","categories":[{"name":"culture","slug":"culture","permalink":"https://linlshare.github.io/categories/culture/"},{"name":"中国文化","slug":"culture/中国文化","permalink":"https://linlshare.github.io/categories/culture/中国文化/"}],"tags":[{"name":"干支","slug":"干支","permalink":"https://linlshare.github.io/tags/干支/"},{"name":"历法","slug":"历法","permalink":"https://linlshare.github.io/tags/历法/"},{"name":"进制","slug":"进制","permalink":"https://linlshare.github.io/tags/进制/"}]},{"title":"从十进制数谈到巴比伦数字系统","slug":"culture/中国文化/从十进制数谈到巴比伦数字系统","date":"2016-04-04T11:12:40.000Z","updated":"2019-01-13T11:37:46.352Z","comments":true,"path":"2016/04/04/culture/中国文化/从十进制数谈到巴比伦数字系统/","link":"","permalink":"https://linlshare.github.io/2016/04/04/culture/中国文化/从十进制数谈到巴比伦数字系统/","excerpt":"","text":"我们的计数方式生活中我们普遍使用十进制进行计数。我们生下来不久就被老妈教着数手指头。没错，我们刚好十根手指头，用来计算方便极了。十进制很早就刻入了我们的脑海，以至于我们不需要知道这是十进制就可以计算早上买了一个面包，老板要找我多少钱。为什么用这个例子呢？聪明的你一定可以想到最早的计数就是用于交易的。早期的物物交换也得有个数吧，不然就乱了。 嗯，除了这种用10个符号（0到9）计数的，我们还接触过12生肖，接触过1天24小时，1分钟60秒，1 兆 1024 个。这些可不是十进制哦。那这些算是什么呢？这得从数字系统讲起。 数字系统所谓数字系统就是确定如何用有限的符号来表示一个数字。数字或者说数量是现实存在的且不会因为所用的数字系统不同而改变，你可以用十进制的 2 来表示两个苹果，也可以用二进制的 10 来表示，这丝毫不会影响苹果的数量。这里的”2”和”10”都只是符号而已，只是为了描述的方便而产生。 数字系统有两种，一种是位置化数字系统，另一种是非位置化数字系统。我们常用的是位置化数字系统，这里主要阐述的也是位置化数字系统。所谓位置化，是指符号因所处的位置不同所表示的值也不同。你想啊，把 2 放在个位它就是 2 ，但是放在十位不就是 20 吗？这里的 20 后面有个 “0” ！！！这太重要了，如果没有 “0” ，位置化数字系统会变得有点尴尬，这点后面讨论就会感受到。 先谈谈十进制十进位是古印度人的发明，他们在公元前3世纪就有了这种计数方法。但是那时候还没有用阿拉伯数字表示，也没有 “0”。直到传入阿拉伯，善于经商的阿拉伯人改造了它，从此贸易就变得简单多了。再后来传入欧洲，而欧洲人误以为这是阿拉伯人的发明，就称之为 “阿拉伯计数法” 了，我们现在通常说的阿拉伯数字，其实就是欧化了的阿拉伯数字。 “0” 的发明太重要了，要单独谈谈。零最初是印度人发明的，公元8世纪左右就有了用点表示的零，而圆形的零出现于公元13世纪。【世界古文明，张新国】其实公元6世纪，印度天文学家瓦拉哈就对零进行了加减运算。此后传入阿拉伯才有了真正的十进制数字系统。为什么等到公元6世纪才有零的发明呢？明明十进位计数法在公元前3世纪就有了！据说是因为那时候印度大乘佛法倡导”空”的思想，在这个背景下，才有了零的含义和表示。然而，印度人并不只是认为零是空无，还承认它是一个数。这很重要，承认它是一个数，它才有资格参与运算，而不是作为填补空格的记号。 说回十进制，十进制的科学定义是：10为底的用10个字符表示一个数的系统，字符集是S={0,1,2,3,4,5,6,7,8,9}。 一个数可以表示成 $\\pm(S_{k-1}\\cdots{S_{2}}{S_{1}}{S_{0}}{S_{-1}}{S_{-2}}\\cdots{S_{-l})_{10}}$ 但是为了方便我们通常省略+号、括号和底。 其值得计算方式是： $N = \\pm(S_{k-1}\\times10^{k-1}+S_{k-2}\\times10^{k-2}+\\cdots+S_{2}\\times10^{2}+S_{1}\\times10^{1}+S_{0}\\times10^{0})$ 嗯，$233 = 2\\times10_{2}+3\\times10^{1}+3\\times10^{2}$ 这就是十进制的故事。然而十进制对于计算机来说是不理想的，虽然对人类来说是友好的，因为人类有十根手指头，而计算机中只有电路的开关两种状态，让它用十进制计算似乎不科学。 二进制登场于是乎二进制登场了。据说将二进制利用于计算机的人是借鉴了中国的阴阳学说。中国人用阴阳表示了世间万物，而计算机用”0”、”1”表示了所有的数据，这其中的奥妙值得细细体味。 仿造十进制的定义，我们给出了二进制的科学定义：使用2为底的2个字符表示一个数，字符集S = {0,1}。其计算方式与上面的可类比，其实就是把10换成了2。比如 $(101)_{2} = 1\\times2^{2}+0\\times2^{1}+1\\times1^{0} = (5)_{10}$ 你看一个十进制的5，用二进制表示就用了3位。想想要是十进制的100呢？岂不是一长串的01组合。聪明的人类肯定不喜欢这样，于是发明了八进制和十六进制来简化二进制的书写。 所谓的八进制是这样的：使用8为底的8个字符来表示一个数，字符集S = {0,1,2,3,4,5,6,7}。注意：只能使用字符集里面的字符来表示数，”8”，”9”在这里是没有意义的。$(8)_{10} = (10)_{8}$ ， $(9)_{10} = (11)_{8}$。 所谓的十六进制是这样的：使用16为底的16个字符来表示一个数，字符集S = {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}。后面之所以用字母表示，是因为十进制的字符不够用了，如果你由你来定义，你也可以使用a、o、e、i、u 、v来表示，但这是国际通用的，不能随便改。嗯，$(16)_{10} = (10)_{16}$ ， $(11)_{16} = (17)_{10}$ IP地址的表示我们知道IP地址是用点分十进制表示的，在教材中我们学到的是：IP地址用4组，每组8位的二进制数点分组成，但由于二进制数对人类不友好，所以用十进制表示。但其实我们可以换一个角度思考：它是256进制数，即使用256为底的256个字符来表示一个数，字符集 S = {1,2,3,…,255}；在这个数字系统下， $(192.168.0.1)_{256}$$= (192\\times(256)^{3}+168\\times(256)^{2}+0\\times(256)^1+1\\times(256)^{0})_{10}$$= 3232235521$ 这数字是十亿级别的。 我们知道在将八进制转化为二进制时，每1位八进制数表示3位二进制数，因为 $2^{3} = 8$；将十六进制转化为二进制时，每1位十六进制表示4位二进制数，因为 $2^{4} = 16$；自然，将256进制数转化为二进制数时，每1位256进制数表示8位二进制数，因为 $2^{8}=256$。这样： $(192.168.0.1)_{256}$$= (01000000.00100000.00000000.00000001)_{2}$ 显然使用256进制数表达十亿级别的数简洁些。 还有两个有趣的数字系统玛雅数字系统玛雅文明发明了一种二十进制的数字系统。他们使用贝壳、鹅卵石和木棍这三样东西来计数。看看下面的图片，贝壳代表”0”，鹅卵石代表”1”，而木棍代表”5”，通过鹅卵石和木棍组合出了其它的17个数。符合二十进制的定义：20为底的20个符号表示一个数。 这些字符确定后，所有的数都由它们的位置组合确定。比如：$(233)_{10} = 11\\times(20)^1+13\\times(20)^0$对应于玛雅数字系统中的： 巴比伦数字系统巴比伦文明发明了一种六十进位的数字系统。他们使用两个碶形符号：和 ）。 Y表示 “1”，而 &lt; 表示 “10”。并由此组合出其它的57个符号。但是偏偏没有零。所以说他们的数字系统是不完善的，他们仅仅使用了59个符号，并通过空格和上下文来区别没有零可能造成的歧义。 在这个系统中 $(233)_{10} = 3\\times(60)^1+53\\times(60)^0$用他们的符号表示是：这真有趣(￣▽￣)~* 本文标题: 从十进制数谈到巴比伦数字系统文章作者: Lshare许可协议: ©署名-非商用-相同方式共享 4.0","categories":[{"name":"culture","slug":"culture","permalink":"https://linlshare.github.io/categories/culture/"},{"name":"中国文化","slug":"culture/中国文化","permalink":"https://linlshare.github.io/categories/culture/中国文化/"}],"tags":[{"name":"进制","slug":"进制","permalink":"https://linlshare.github.io/tags/进制/"},{"name":"基础","slug":"基础","permalink":"https://linlshare.github.io/tags/基础/"},{"name":"数字系统","slug":"数字系统","permalink":"https://linlshare.github.io/tags/数字系统/"},{"name":"IP地址","slug":"IP地址","permalink":"https://linlshare.github.io/tags/IP地址/"},{"name":"巴比伦数字系统","slug":"巴比伦数字系统","permalink":"https://linlshare.github.io/tags/巴比伦数字系统/"},{"name":"玛雅数字系统","slug":"玛雅数字系统","permalink":"https://linlshare.github.io/tags/玛雅数字系统/"}]}]}