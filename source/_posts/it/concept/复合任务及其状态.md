---
title: 复合任务及其状态
date: 2018-12-24 17:49:56
tags: [复合任务,状态]
---

在代码设计字段时我们经常会碰到需要加状态字段的场景。状态即此刻的情况、形态。从一个状态到另个状态是质变，而质变是由量变累积而成，譬如年老的状态，是时间累积、内分泌系统渐衰，而从年轻到年老的质变。代码中的状态字段亦复如是。

**原子任务**的状态转移是单一操作的，该任务只有 TODO 和 DONE 两种状态，该任务无法被部分完成，只能整体完成或没完成。

```java
public class Task{
    // 状态可取值：["TODO","DONE"]
    private String status;
}
```

然而现实世界中的任务都是复合任务，据我发现有以下几种复合方式：

1. 多个平行原子任务复合，且称之为**平行复合任务**；
2. 多个链状原子任务复合，且称之为**链状复合任务**；
3. 多个树状原子任务复合，且称之为**树状复合任务**；

上面复合方式还可以嵌套，产生更复杂的复合方式，即多重复合。

这时，我们面临一个挑战，我们该如何定义这些复合任务的状态呢？

我们说是量的积累导致了状态的质变，那么可不可以从过程量入手呢？

答案是明确的，我认为这应该是绝妙而又充满哲学意味的手段。现以最简单的平行复合任务为例，试编码如下：

（1）首先我们需要一个计数器，用来统计总数和已完成的任务数量。

```java
public class Counter{
    private int total;
    private int done;
    
    public void setTotal(int total){
        this.total = total;
    }
    
    public void increaseTotal(){
        this.total ++;
    }
    
    public void increaseDone(){
        this.done ++;
    }
    public boolean totallyDone() {
    	return total == done;
  	}
}
```
（2）再者，我们在复合任务内部刷新状态，每当一个子任务完成时检查并刷新内部状态。这样，状态的刷新就内聚了，外部量变，内部质变。

```java
public class CompoundTask{
    // 状态可取值：["TODO", "DONE", "PARTIALLY_DONE"]
    private String status = "TODO";
    private Counter counter = new Counter();
    private List<Task> tasks = new ArrayList<>();
    
    public void addTask(Task task){
        tasks.add(task);
        counter.increaseTotal();
    }
    
    public void increaseTaskDone(){
        counter.increaseDone();
        refreshStatus();
    }
    
    private void refreshStatus(){
        if(counter.totallyDone()){
            status = "DONE";
        }else{
			status = "PARTIALLY_DONE";
        }
    }
}
```

以上是基础实现，旨在探求一种通用的描述复合任务状态的解决方案。多重复合任务可以通过同类归并压平成一个计数器，不同类的任务建议使用不同的计数器。

