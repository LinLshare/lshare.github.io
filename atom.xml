<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Share 杂志</title>
  <icon>https://www.gravatar.com/avatar/67398ac80b713195e4e6faee10834ea3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linlshare.github.io/"/>
  <updated>2018-12-03T04:17:26.523Z</updated>
  <id>https://linlshare.github.io/</id>
  
  <author>
    <name>Lshare</name>
    <email>Lshare@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Groovy</title>
    <link href="https://linlshare.github.io/2018/12/03/it/tool/Groovy/"/>
    <id>https://linlshare.github.io/2018/12/03/it/tool/Groovy/</id>
    <published>2018-12-03T03:09:17.000Z</published>
    <updated>2018-12-03T04:17:26.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Gradle-中的-ext-究竟是什么？"><a href="#Gradle-中的-ext-究竟是什么？" class="headerlink" title="Gradle 中的 ext 究竟是什么？"></a>Gradle 中的 ext 究竟是什么？</h3><p>gradle 中我们使用 <code>ext</code> 定义额外的各种属性，可是 <code>ext</code> 究竟是什么呢？</p><p>参看 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html" target="_blank" rel="noopener">ExtraPropertiesExtension - Gradle DSL</a>，发现 <code>ext</code> 不是 Groovy 固有的定义，而是领域特定的语言（DSL）。使用方式是：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下的 project 常常被省略</span></span><br><span class="line">project.ext &#123; foo = <span class="string">"bar"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> project.ext.get(<span class="string">"foo"</span>) == <span class="string">"bar"</span></span><br><span class="line"><span class="keyword">assert</span> project.ext.foo == <span class="string">"bar"</span></span><br><span class="line"><span class="keyword">assert</span> project.ext[<span class="string">"foo"</span>] == <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> project.foo == <span class="string">"bar"</span></span><br><span class="line"><span class="keyword">assert</span> project[<span class="string">"foo"</span>] == <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><p><code>ext</code> 实质上是一个内置的简单对象，但可以动态添加新属性，这个对象叫 <code>ExtraPropertiesExtension</code>，它内置在所有 <code>ExtensionAware</code> 中，<code>ExtenstionAware</code> 的已知子类有 <code>Project</code>、<code>Settings</code>、<code>Task</code> 、<code>SourceSet</code>，所以在这些类中可以直接使用所谓的 <code>namespace method</code> 动态新增新属性。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extensions are just plain objects, there is no interface/type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExtension</span> &#123;</span></span><br><span class="line">  String foo</span><br><span class="line"></span><br><span class="line">  MyExtension(String foo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add new extensions via the extension container</span></span><br><span class="line">project.extensions.create(<span class="string">'custom'</span>, MyExtension, <span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">//                       («name»,   «type»,       «constructor args», …)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extensions appear as properties on the target object by the given name</span></span><br><span class="line"><span class="keyword">assert</span> project.custom <span class="keyword">instanceof</span> MyExtension</span><br><span class="line"><span class="keyword">assert</span> project.custom.foo == <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// also via a namespace method</span></span><br><span class="line">project.custom &#123;</span><br><span class="line">  <span class="keyword">assert</span> foo == <span class="string">"bar"</span></span><br><span class="line">  foo = <span class="string">"other"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> project.custom.foo == <span class="string">"other"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-amp-A&quot; class=&quot;headerlink&quot; title=&quot;Q&amp;amp;A&quot;&gt;&lt;/a&gt;Q&amp;amp;A&lt;/h2&gt;&lt;h3 id=&quot;Gradle-中的-ext-究竟是什么？&quot;&gt;&lt;a href=&quot;#Gradle-中的-ext
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="tool" scheme="https://linlshare.github.io/categories/it/tool/"/>
    
    
      <category term="Groovy" scheme="https://linlshare.github.io/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>Quartz</title>
    <link href="https://linlshare.github.io/2018/12/03/it/java/schedule/Quartz/"/>
    <id>https://linlshare.github.io/2018/12/03/it/java/schedule/Quartz/</id>
    <published>2018-12-03T02:49:29.000Z</published>
    <updated>2018-12-03T04:34:20.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quartz-是什么？"><a href="#Quartz-是什么？" class="headerlink" title="Quartz 是什么？"></a>Quartz 是什么？</h2><p><a href="https://github.com/quartz-scheduler/quartz" target="_blank" rel="noopener">Quartz</a> 是一款 Java 平台上开源的任务调度器。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">"org.quartz-scheduler:quartz:2.3.0"</span></span><br><span class="line">compile <span class="string">"org.quartz-scheduler:quartz-jobs:2.3.0"</span></span><br></pre></td></tr></table></figure><h3 id="（2）初始化"><a href="#（2）初始化" class="headerlink" title="（2）初始化"></a>（2）初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从工厂中获取 Scheduler 对象</span></span><br><span class="line">Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">scheduler.start();</span><br></pre></td></tr></table></figure><h3 id="（3）新建一个-Job"><a href="#（3）新建一个-Job" class="headerlink" title="（3）新建一个 Job"></a>（3）新建一个 Job</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJob</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">"Hello World!  TestJob is executing."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）调度一个-Job"><a href="#（4）调度一个-Job" class="headerlink" title="（4）调度一个 Job"></a>（4）调度一个 Job</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 Job 的携带数据</span></span><br><span class="line">JobDetail job = newJob(TestJob.class).withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>).build();</span><br><span class="line"><span class="comment">// 新建一个触发器</span></span><br><span class="line">Trigger trigger = newTrigger().withIdentity(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">    .startNow()</span><br><span class="line">    .withSchedule(simpleSchedule().withIntervalInSeconds(<span class="number">5</span>)</span><br><span class="line">                  .repeatForever())</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 开始调度</span></span><br><span class="line">scheduler.scheduleJob(job, trigger);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html" target="_blank" rel="noopener">quartz-2.2.x/quick-start</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Quartz-是什么？&quot;&gt;&lt;a href=&quot;#Quartz-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Quartz 是什么？&quot;&gt;&lt;/a&gt;Quartz 是什么？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/quartz
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="schedule" scheme="https://linlshare.github.io/categories/it/java/schedule/"/>
    
    
      <category term="Quartz" scheme="https://linlshare.github.io/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture</title>
    <link href="https://linlshare.github.io/2018/12/03/it/java/schedule/CompletableFuture/"/>
    <id>https://linlshare.github.io/2018/12/03/it/java/schedule/CompletableFuture/</id>
    <published>2018-12-03T02:49:29.000Z</published>
    <updated>2018-12-03T02:49:59.457Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="schedule" scheme="https://linlshare.github.io/categories/it/java/schedule/"/>
    
    
      <category term="CompletableFuture" scheme="https://linlshare.github.io/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://linlshare.github.io/2018/11/29/it/java/base/ZooKeeper/"/>
    <id>https://linlshare.github.io/2018/11/29/it/java/base/ZooKeeper/</id>
    <published>2018-11-29T04:10:22.000Z</published>
    <updated>2018-11-29T04:10:26.666Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="ZooKeeper" scheme="https://linlshare.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>服务发现</title>
    <link href="https://linlshare.github.io/2018/11/28/it/concept/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>https://linlshare.github.io/2018/11/28/it/concept/服务发现/</id>
    <published>2018-11-28T14:29:25.000Z</published>
    <updated>2018-11-28T15:12:30.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是服务发现？"><a href="#什么是服务发现？" class="headerlink" title="什么是服务发现？"></a>什么是服务发现？</h2><p>服务发现，Service Discovery，是<strong>一项提供服务发布和查找的服务</strong>，其实质就是<strong>键值存储</strong>，通过键（Key，在当前语境应是服务名）找到值（Value，在当前语境是服务）。DNS 就是一个简单的例子，人们或其他服务使用域名向 DNS 请求 IP 地址，Key 就是域名，Value 就是 IP 地址。</p><p>服务发现是支持大规模 SOA（service-oriented architecture）的核心服务，需具备以下关键特性：</p><ol><li>注册（Registration），新增服务到服务列表；</li><li>目录（Directory），即服务列表；</li><li>查找（Lookup），通过服务名找到服务。</li></ol><p>服务元数据（metadata，包括服务的 IP、端口、提供的服务等等信息）存储是服务发现的关键。</p><p>服务发现还需<strong>提供查询所有服务的部署状态和集中控制所有服务实例的方式</strong>。</p><h2 id="服务发现解决方案"><a href="#服务发现解决方案" class="headerlink" title="服务发现解决方案"></a>服务发现解决方案</h2><table><thead><tr><th>解决方案</th><th>特性</th><th>发起人</th></tr></thead><tbody><tr><td>Redis</td><td>用 Redis 作为服务中介是最简单的，但不适用于分布式系统，不具备下面的解决方案的优点</td><td>无</td></tr><tr><td>ZooKeeper</td><td>提供了包括配置管理、领导人选举和分布式锁在内的完整解决方案</td><td>Apache</td></tr><tr><td>etcd</td><td>与 ZooKeeper 具有相似的架构和功能</td><td>CoreOS</td></tr><tr><td>doozerd</td><td>与 ZooKeeper 具有相似的架构和功能</td><td>Blake Mizerany &amp; Keith Rarick</td></tr><tr><td>Consul</td><td>提供了 DNS 和 HTTP 两种 API</td><td>Hashicorp</td></tr><tr><td>Eureka</td><td>在出现网络分区时， Eureka 选择可用性，而不是一致性，适合 AP( Availability and Partition ) 系统。</td><td>Netflix</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://dockone.io/article/509" target="_blank" rel="noopener">六个问题带你了解服务发现 - dockone.io</a></li><li><a href="https://highops.com/insights/service-discovery-6-questions-to-4-experts/" target="_blank" rel="noopener">Service Discovery: 6 questions to 4 experts - highops.com</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是服务发现？&quot;&gt;&lt;a href=&quot;#什么是服务发现？&quot; class=&quot;headerlink&quot; title=&quot;什么是服务发现？&quot;&gt;&lt;/a&gt;什么是服务发现？&lt;/h2&gt;&lt;p&gt;服务发现，Service Discovery，是&lt;strong&gt;一项提供服务发布和查找的服务
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="concept" scheme="https://linlshare.github.io/categories/it/concept/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="服务发现" scheme="https://linlshare.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>分布式与集群</title>
    <link href="https://linlshare.github.io/2018/11/28/it/concept/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/"/>
    <id>https://linlshare.github.io/2018/11/28/it/concept/分布式与集群/</id>
    <published>2018-11-28T14:09:37.000Z</published>
    <updated>2018-11-28T14:28:59.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式与集群的区别（Distributed-vs-Cluster）"><a href="#分布式与集群的区别（Distributed-vs-Cluster）" class="headerlink" title="分布式与集群的区别（Distributed vs Cluster）"></a>分布式与集群的区别（Distributed vs Cluster）</h2><blockquote><p>分布式：一个业务分拆多个子业务，部署在不同的服务器上。</p><p>集群：同一个业务，部署在多个服务器上。</p><p>— <a href="https://www.zhihu.com/question/20004877/answer/26076092" target="_blank" rel="noopener">分布式与集群的区别是什么？ - 知乎用户的回答 - 知乎</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式与集群的区别（Distributed-vs-Cluster）&quot;&gt;&lt;a href=&quot;#分布式与集群的区别（Distributed-vs-Cluster）&quot; class=&quot;headerlink&quot; title=&quot;分布式与集群的区别（Distributed vs C
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="concept" scheme="https://linlshare.github.io/categories/it/concept/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="分布式" scheme="https://linlshare.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="集群" scheme="https://linlshare.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Logback</title>
    <link href="https://linlshare.github.io/2018/11/28/it/java/base/Logback/"/>
    <id>https://linlshare.github.io/2018/11/28/it/java/base/Logback/</id>
    <published>2018-11-28T06:35:54.000Z</published>
    <updated>2018-11-28T13:55:26.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Logback-是什么？"><a href="#Logback-是什么？" class="headerlink" title="Logback 是什么？"></a>Logback 是什么？</h2><p>Logback 是一个 Java 平台上的日志框架，是 log4j 的加强版本，目前分为以下模块：</p><ol><li>logback-core，放置为下面两个模块服务的基础代码；</li><li>logback-classic，log4j 的加强版本，实现了 SLF4J API，以便于切换其他日志框架；</li><li>logback-access，与 Servlet 容器集成，提供 HTTP 访问日志功能。</li></ol><blockquote><p>SLF4J：The Simple Logging Facade for Java（简单日志门面抽象框架），提供的是日志的 Facade API，需要配合 Log4j、Logback 或 java.util.logging 使用。</p></blockquote><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>（1）引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">"org.slf4j:slf4j-api:1.7.+"</span></span><br><span class="line">compile <span class="string">"ch.qos.logback:logback-core:1.2.+"</span></span><br><span class="line">compile <span class="string">"ch.qos.logback:logback-classic:1.2.+"</span></span><br></pre></td></tr></table></figure><p>（2）编写 <code>logback.xml</code> 并放置到 <code>resources</code> 文件夹中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;appender name=<span class="string">"STDOUT"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line">  &lt;root level=<span class="string">"DEBUG"</span>&gt;          </span><br><span class="line">    &lt;appender-ref ref=<span class="string">"STDOUT"</span> /&gt;</span><br><span class="line">  &lt;/root&gt;  </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>（3）在代码中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger LOGGER = LoggerFactory.getLogger(Main.class);</span><br><span class="line">LOGGER.debug(<span class="string">"Hello, Logback"</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://logback.qos.ch/" target="_blank" rel="noopener">Logback Project - logback.qos.ch</a></li><li><a href="https://segmentfault.com/a/1190000004693427" target="_blank" rel="noopener">LogBack 入门实践</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Logback-是什么？&quot;&gt;&lt;a href=&quot;#Logback-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Logback 是什么？&quot;&gt;&lt;/a&gt;Logback 是什么？&lt;/h2&gt;&lt;p&gt;Logback 是一个 Java 平台上的日志框架，是 lo
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="Java" scheme="https://linlshare.github.io/tags/Java/"/>
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="Logback" scheme="https://linlshare.github.io/tags/Logback/"/>
    
  </entry>
  
  <entry>
    <title>zsh</title>
    <link href="https://linlshare.github.io/2018/11/28/it/tool/zsh/"/>
    <id>https://linlshare.github.io/2018/11/28/it/tool/zsh/</id>
    <published>2018-11-28T03:55:54.000Z</published>
    <updated>2018-11-28T03:55:59.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="禁止粘贴命令时自动对特殊字符进行转义"><a href="#禁止粘贴命令时自动对特殊字符进行转义" class="headerlink" title="禁止粘贴命令时自动对特殊字符进行转义"></a>禁止粘贴命令时自动对特殊字符进行转义</h3><p>（1）编辑 <code>misc.zsh</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  ~/.oh-my-zsh/lib/misc.zsh</span><br></pre></td></tr></table></figure><p>（2）注释掉 <code>url-quote-magic</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#if [[ $ZSH_VERSION != 5.1.1 ]]; then</span><br><span class="line">#  for d in $fpath; do</span><br><span class="line">#       if [[ -e &quot;$d/url-quote-magic&quot; ]]; then</span><br><span class="line">#               if is-at-least 5.1; then</span><br><span class="line">#                       autoload -Uz bracketed-paste-magic</span><br><span class="line">#                       zle -N bracketed-paste bracketed-paste-magic</span><br><span class="line">#               fi</span><br><span class="line">#               autoload -Uz url-quote-magic</span><br><span class="line">#               zle -N self-insert url-quote-magic</span><br><span class="line">#      break</span><br><span class="line">#       fi</span><br><span class="line">#  done</span><br><span class="line">#fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;禁止粘贴命令时自动对特殊字符进行转义&quot;&gt;&lt;a href=&quot;#禁止粘贴命令时自动对特殊字符进行转义&quot; class=&quot;headerlink&quot; title=&quot;禁止粘贴命令时自动对特殊字符进行转义&quot;&gt;&lt;/a&gt;禁止粘贴命令时自动对特殊字符进行转义&lt;/h3&gt;&lt;p&gt;（1）编辑 
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="tool" scheme="https://linlshare.github.io/categories/it/tool/"/>
    
    
      <category term="zsh" scheme="https://linlshare.github.io/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://linlshare.github.io/2018/11/27/it/tool/Docker/"/>
    <id>https://linlshare.github.io/2018/11/27/it/tool/Docker/</id>
    <published>2018-11-27T09:47:54.000Z</published>
    <updated>2018-11-30T13:07:31.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h2><p><a href="https://github.com/moby/moby" target="_blank" rel="noopener">Docker</a> 是一种虚拟化的容器，<strong>隔离了文件系统、网络互联和进程</strong>等等，但比之传统的虚拟化技术，精简了内核和硬件的虚拟，容器内的应用进程直接运行在宿主内核。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p><strong>（1）Homebrew 安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> brew cask install docker</span><br></pre></td></tr></table></figure><p><strong>（2）下载安装</strong></p><p><a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Docker.dmg 下载</a></p><h3 id="检查安装情况"><a href="#检查安装情况" class="headerlink" title="检查安装情况"></a>检查安装情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> docker --version</span><br><span class="line"><span class="meta">&gt;</span> docker-compose --version</span><br><span class="line"><span class="meta">&gt;</span> docker-machine --version</span><br></pre></td></tr></table></figure><h3 id="使用镜像加速器"><a href="#使用镜像加速器" class="headerlink" title="使用镜像加速器"></a>使用镜像加速器</h3><p>鉴于国内的网络情况，拉取镜像会很慢，这时候需要配置镜像加速器，使用国内的镜像服务器。</p><p><strong>国内的镜像服务器地址</strong>：    <a href="https://registry.docker-cn.com。" target="_blank" rel="noopener">https://registry.docker-cn.com。</a></p><p><strong>配置方式</strong>：对于使用 Docker 客户端的用户，依次点击 <code>Docker 图标 --&gt; Settings/ Perferences --&gt; Daemon --&gt; Registry mirrors</code>，输入加速器地址，然后点击 Apply &amp; Restart 即可。</p><p><strong>检查配置是否生效</strong>：执行 <code>docker info</code> 查看 <code>Registry Mirrors</code> 字段的值。</p><h2 id="快速开始：启动一个-Nginx-服务器"><a href="#快速开始：启动一个-Nginx-服务器" class="headerlink" title="快速开始：启动一个 Nginx 服务器"></a>快速开始：启动一个 Nginx 服务器</h2><p>（1）安装并启动一个 Nginx 服务器，将本地的 8080 端口映射到 Docker 的 80 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> docker run -d -p 8080:80 --name webserver nginx</span><br></pre></td></tr></table></figure><p>（2）通过 <code>docker ps</code> 查看运行中的 docker 容器列表。</p><p>（3）通过 <code>http://localhost:8080</code> 即可正常访问。</p><p>（4）停止 Nginx 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> docker stop webserver</span><br></pre></td></tr></table></figure><p>（4）从 Docker 中删除 Nginx 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> docker rm webserver</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>虚拟概念，并非一个 ISO 的压缩文件，而是使用 Union FS 分层存储技术存储的多层文件系统联合组成，存放的是 <code>root</code> 文件系统，包括容器运行时所需的程序、库、资源、配置等文件，但不包含动态数据。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>容器是镜像运行时的实体，实质就是一个个的 Docker 进程，可以对 Docker 进程进行如下操作：</p><ul><li>创建</li><li>启动</li><li>停止</li><li>删除</li><li>暂停</li></ul><p>容器也采用分层存储，容器运行时，以镜像为基础层，在其上创建一个当前容器的存储层，称之为容器存储层。容器存储层的生命周期与容器同步，故不应向存储层写入任何数据，所有的文件写入操作，都应<strong>使用数据卷（Volume）或者绑定宿主目录</strong>。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h3><p>用来集中存储和分发 Docker 镜像的服务，一个 Registry 可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。</p><p>常用的 Public Registry 列表：</p><ol><li><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></li><li><a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a></li><li><a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a></li><li><a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a></li><li><a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a></li><li><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> </li><li><a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a></li></ol><p>国内针对 Docker Hub 的镜像服务（加速器）有：</p><ol><li><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a></li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker images</td><td>列出所有拉取的镜像</td></tr><tr><td>docker inspect [name]</td><td>检视镜像的详细信息</td></tr><tr><td>docker rmi [REPOSITORY]:[TAG]</td><td>删除镜像</td></tr><tr><td>docker pull [name]</td><td>拉取镜像</td></tr></tbody></table><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker ps -a</td><td>列出所有容器及其状态</td></tr><tr><td>docker ps</td><td>列出所有运行中的容器</td></tr><tr><td>docker  rm [容器 ID]</td><td>删除容器</td></tr><tr><td>docker crate -it [镜像标签或镜像 ID]</td><td>新建一个容器</td></tr><tr><td>docker start [容器 ID]</td><td>运行处于终止状态的容器</td></tr><tr><td>docker kill [容器 ID]</td><td>强制终止容器</td></tr><tr><td>docker kill [容器 ID]</td><td>停止容器</td></tr><tr><td>docker restart [容器 ID]</td><td>重启一个容器</td></tr><tr><td>docker logs [容器ID]</td><td>查看容器日志</td></tr></tbody></table><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>docker exec -ti [容器ID] /bin/bash</td><td>进入具体容器中运行交互命令</td></tr><tr><td>docker exec [容器 ID 或容器 name] 具体命令</td><td>直接执行具体容器的命令</td></tr></tbody></table><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 用来定制镜像，是一组指令，描述如何在基础镜像中一步步构建自定义的镜像。下面以修改 nginx 服务器首页为例：</p><p>（1）新建名为 <code>Dockerfile</code> 的文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span> echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>（2）使用 <code>docker build</code> 开始构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 确保在 Dockerfile 所在的目录下执行该命令，</span><br><span class="line"><span class="meta">#</span> 否则需要使用 `-f [file_name]` 指定 Dockerfile</span><br><span class="line"><span class="meta">#</span> 使用 `-t [name:tag]` 指定镜像的名称和标签</span><br><span class="line">docker build -t nginx:v3</span><br></pre></td></tr></table></figure><h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><h4 id="（1）FROM"><a href="#（1）FROM" class="headerlink" title="（1）FROM"></a>（1）FROM</h4><p>指定基础镜像。</p><h4 id="（2）RUN"><a href="#（2）RUN" class="headerlink" title="（2）RUN"></a>（2）RUN</h4><p>执行命令行命令，支持 shell 格式和 exec 格式。</p><blockquote><p>注意：Dockerfile 每个指令都会建立一层，Union FS 有最大层数限制。多个命令行指令可以使用 <code>&amp;&amp;</code> 串联。</p></blockquote><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><a href="https://github.com/docker/compose" target="_blank" rel="noopener">Docker Compose</a> 是 Docker 官方的开源项目之一，用来快速地部署分布式应用。官方定位是「<strong>定义和运行多个 Docker 容器的应用</strong>（Defining and running multi-container Docker applications）」。衍生概念有：</p><ol><li>服务（Service）, 一个 Docker 容器称之为一个服务；</li><li>项目（Project），一个 Compose，或者说一组相关联的服务，称之为一个项目 。</li></ol><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Docker Compose 在 Docker 客户端中已经包含，可以直接使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 检查是否可用</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>（1）使用 <code>Dockerfile</code> 定义应用的环境；</p><p>（2）使用 <code>docker-compose.yml</code> 定义组成应用的各项服务；</p><p>（2）执行 <code>docker-compose up</code> 进行部署。</p><h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><h3 id="Error-Cannot-Start-Container-stat-bin-sh-no-such-file-or-directory”"><a href="#Error-Cannot-Start-Container-stat-bin-sh-no-such-file-or-directory”" class="headerlink" title="Error: Cannot Start Container: stat /bin/sh: no such file or directory”"></a>Error: Cannot Start Container: stat /bin/sh: no such file or directory”</h3><p>（1）使用 <code>docker inspect</code>  检视镜像的 <code>Cmd</code> 选项；</p><p>（2）如果 <code>Cmd</code> 中不包含 <code>/bin/sh</code> 那意味着可能被你重写了。</p><h3 id="Run-container-but-exited-immediately"><a href="#Run-container-but-exited-immediately" class="headerlink" title="Run container but exited immediately"></a>Run container but exited immediately</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker – 从入门到实践</a>（绝佳的入门文档）</li><li><a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">docker-library/docs - Github</a> （docker 官方镜像的使用文档）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-是什么？&quot;&gt;&lt;a href=&quot;#Docker-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Docker 是什么？&quot;&gt;&lt;/a&gt;Docker 是什么？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/moby/m
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="tool" scheme="https://linlshare.github.io/categories/it/tool/"/>
    
    
      <category term="Docker" scheme="https://linlshare.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>etcd</title>
    <link href="https://linlshare.github.io/2018/11/27/it/java/base/etcd/"/>
    <id>https://linlshare.github.io/2018/11/27/it/java/base/etcd/</id>
    <published>2018-11-27T06:17:35.000Z</published>
    <updated>2018-11-30T14:54:23.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="etcd-是什么？（What-is-etcd）"><a href="#etcd-是什么？（What-is-etcd）" class="headerlink" title="etcd 是什么？（What is etcd）"></a>etcd 是什么？（What is etcd）</h2><p>etcd 是一个一致的分布式可靠的键值存储技术。可被用来做配置共享和服务发现。</p><ul><li>开发语言：Go</li><li>共识算法：<a href="https://raft.github.io/" target="_blank" rel="noopener">Raft</a></li><li>命名来源：表示分布式的 <code>etc</code> 目录，发音为<code>/ˈɛtsiːdiː/</code>。</li><li>使用的端口：2.0 后，使用 2379 作为外部客户端通信，使用 2380 作为内部服务间通信。</li><li>发起团队：CoreOS</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">brew install etcd</span><br><span class="line"><span class="meta">#</span> 验证安装</span><br><span class="line">etcd -version</span><br><span class="line">etcdctl -version</span><br></pre></td></tr></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><p>参考 <a href="https://coreos.com/etcd/docs/latest/v2/docker_guide.html" target="_blank" rel="noopener">Running etcd under Docker - CoreOS</a> 及 <a href="docker_practice/etcd/install">docker_practice/etcd/install</a> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用 host IP</span><br><span class="line">export ETCD_NODE1=127.0.0.1</span><br><span class="line"><span class="meta">#</span> 安装 etcd</span><br><span class="line">docker run --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume=etcd-data:/etcd-data \</span><br><span class="line">    quay.io/coreos/etcd:latest \</span><br><span class="line">    /usr/local/bin/etcd \</span><br><span class="line">    --data-dir=/etcd-data --name node1 \</span><br><span class="line">    --initial-advertise-peer-urls http://$&#123;ETCD_NODE1&#125;:2380 --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">    --advertise-client-urls http://$&#123;ETCD_NODE1&#125;:2379 --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">    --initial-cluster node1=http://$&#123;ETCD_NODE1&#125;:2380</span><br><span class="line"><span class="meta">#</span> 进入etcd 命令行交互</span><br><span class="line">docker exec -it etcd /bin/sh</span><br><span class="line"><span class="meta">#</span> 验证安装</span><br><span class="line">etcd -version</span><br><span class="line">etcdctl -version</span><br><span class="line"><span class="meta">#</span> 验证是否启动</span><br><span class="line">curl http://127.0.0.1:2379/version</span><br></pre></td></tr></table></figure><h3 id="Docker-Compose-快速部署"><a href="#Docker-Compose-快速部署" class="headerlink" title="Docker Compose 快速部署"></a>Docker Compose 快速部署</h3><p>参考 Docker Compose 的使用说明，编辑 <code>docker-compose.yml</code> 文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.6"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  node1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">quay.io/coreos/etcd</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - node1-data:</span><span class="string">/etcd-data</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2380</span>      </span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      cluster_net:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.100</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--data-dir=/etcd-data</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--name</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-advertise-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.100:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--advertise-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.100:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-state</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">new</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-token</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker-etcd</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  node2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">quay.io/coreos/etcd</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - node2-data:</span><span class="string">/etcd-data</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      cluster_net:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.101</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2380</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--data-dir=/etcd-data</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--name</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-advertise-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.101:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--advertise-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.101:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-state</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">new</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-token</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker-etcd</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  node3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">quay.io/coreos/etcd</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - node3-data:</span><span class="string">/etcd-data</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      cluster_net:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.102</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ETCDCTL_API=3</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">2380</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/usr/local/bin/etcd</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--data-dir=/etcd-data</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--name</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node3</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-advertise-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.102:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-peer-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--advertise-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//172.16.238.102:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--listen-client-urls</span></span><br><span class="line"><span class="attr">      - http:</span><span class="string">//0.0.0.0:2379</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node1=http://172.16.238.100:2380,node2=http://172.16.238.101:2380,node3=http://172.16.238.102:2380</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-state</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">new</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">--initial-cluster-token</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker-etcd</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  node1-data:</span></span><br><span class="line"><span class="attr">  node2-data:</span></span><br><span class="line"><span class="attr">  node3-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  cluster_net:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">    ipam:</span></span><br><span class="line"><span class="attr">      driver:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="bullet">      -</span></span><br><span class="line"><span class="attr">        subnet:</span> <span class="number">172.16</span><span class="number">.238</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure><h2 id="etcdctl-v3（主流）"><a href="#etcdctl-v3（主流）" class="headerlink" title="etcdctl v3（主流）"></a>etcdctl v3（主流）</h2><blockquote><p>Tip：可以通过 <code>ETCDCTL_API=3 etcdctl -h</code> 查看 v3 版本的命令行帮助页</p></blockquote><h4 id="（1）查看所有键值对"><a href="#（1）查看所有键值对" class="headerlink" title="（1）查看所有键值对"></a>（1）查看所有键值对</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 指定版本为 v3 且 key 前缀为空，也就是所有 key 了</span><br><span class="line">ETCDCTL_API=3 etcdctl get --prefix=true ""</span><br></pre></td></tr></table></figure><h2 id="etcdctl-v2（兼容）"><a href="#etcdctl-v2（兼容）" class="headerlink" title="etcdctl v2（兼容）"></a>etcdctl v2（兼容）</h2><blockquote><p>Tip：可以通过 <code>etcdctl -h</code> 查看 v2 版本的命令行帮助页</p></blockquote><h4 id="（1）set"><a href="#（1）set" class="headerlink" title="（1）set"></a>（1）set</h4><p>设置某个键的值，支持选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--ttl '0'                该键值的超时时间（单位为秒），不配置（默认为 0）则永不超时</span><br><span class="line">--swap-with-value value  若该键现在的值是 value，则进行设置操作</span><br><span class="line">--swap-with-index '0'    若该键现在的索引值是指定索引，则进行设置操作</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl set /testdir/testkey "Hello etcd"</span><br></pre></td></tr></table></figure><h4 id="（2）get"><a href="#（2）get" class="headerlink" title="（2）get"></a>（2）get</h4><p>获取指定键的值，支持选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--sort       对结果进行排序</span><br><span class="line">--consistent 将请求发给主节点，保证获取内容的一致性</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl get /testdir/testkey</span><br></pre></td></tr></table></figure><h4 id="（3）update"><a href="#（3）update" class="headerlink" title="（3）update"></a>（3）update</h4><p>更新某个键的值，支持选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ttl '0'    该键值的超时时间（单位为秒），不配置（默认为 0）则永不超时</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl update /testdir/testkey "你好 etcd"</span><br></pre></td></tr></table></figure><h4 id="（4）rm"><a href="#（4）rm" class="headerlink" title="（4）rm"></a>（4）rm</h4><p>删除某个键，支持选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--dir            删除空目录或键值对</span><br><span class="line">--recursive, -r  删除当前键及其子键(当为目录时)</span><br><span class="line">--with-value     当值匹配时删除</span><br><span class="line">--with-index '0' 当索引匹配时删除</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl rm /testdir/testkey --with-value "Hello etcd"</span><br></pre></td></tr></table></figure><h4 id="（5）ls"><a href="#（5）ls" class="headerlink" title="（5）ls"></a>（5）ls</h4><p>列出目录（默认为根目录 <code>/</code>）下的键和子目录，默认不显示子目录中内容。支持选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--sort         将输出结果排序</span><br><span class="line">--recursive    如果目录下有子目录，则递归输出其中的内容</span><br><span class="line">-p             对于输出为目录，在最后添加 / 进行区分</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl ls -r -p</span><br></pre></td></tr></table></figure><h2 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h2><p>使用 <code>member</code> 命令进行 etcd 实例与集群的操作：</p><ol><li><code>list</code>  列出 etcd 集群中的所有实例</li><li><code>add</code> 添加 etcd 实例到集群中</li><li><code>remove</code>  从集群中删除 etcd 实例</li><li><code>update</code> 更新集群中的 etcd 实例</li></ol><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> v2</span><br><span class="line">etcdctl member list</span><br><span class="line"><span class="meta">#</span> v3</span><br><span class="line">ETCDCTL_API=3 etcdctl member list</span><br></pre></td></tr></table></figure><h2 id="HTTP-访问"><a href="#HTTP-访问" class="headerlink" title="HTTP 访问"></a>HTTP 访问</h2><h3 id="（1）查看版本"><a href="#（1）查看版本" class="headerlink" title="（1）查看版本"></a>（1）查看版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/version</span><br></pre></td></tr></table></figure><h3 id="（2）get-1"><a href="#（2）get-1" class="headerlink" title="（2）get"></a>（2）get</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2379/v3/keys/testdir/testkey</span><br></pre></td></tr></table></figure><h2 id="参考（Reference）"><a href="#参考（Reference）" class="headerlink" title="参考（Reference）"></a>参考（Reference）</h2><ol><li><a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">etcd-io/etcd - Github</a></li><li><a href="https://github.com/etcd-io/jetcd" target="_blank" rel="noopener">etcd-io/jetcd - Github</a></li><li><a href="https://etcd.readthedocs.io/en/latest/" target="_blank" rel="noopener">etcd Documentation</a></li><li><a href="https://ralphbupt.github.io/2017/05/04/etcd-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/" target="_blank" rel="noopener">etcd 服务注册与发现</a></li><li><a href="https://tonydeng.github.io/2015/11/24/etcd-the-first-using/" target="_blank" rel="noopener">初试ETCD -  Tony Deng</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;etcd-是什么？（What-is-etcd）&quot;&gt;&lt;a href=&quot;#etcd-是什么？（What-is-etcd）&quot; class=&quot;headerlink&quot; title=&quot;etcd 是什么？（What is etcd）&quot;&gt;&lt;/a&gt;etcd 是什么？（What is
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="ETCD" scheme="https://linlshare.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://linlshare.github.io/2018/11/26/it/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://linlshare.github.io/2018/11/26/it/design/设计模式/</id>
    <published>2018-11-26T07:45:40.000Z</published>
    <updated>2018-11-27T07:05:45.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h3><h4 id="（1）适用场景"><a href="#（1）适用场景" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h4><p>当解决问题的方法有多种方式，需要可替换时。</p><h4 id="（2）核心"><a href="#（2）核心" class="headerlink" title="（2）核心"></a>（2）核心</h4><p>使用组合，封装成一个个算法，即是策略。</p><h4 id="（3）类图"><a href="#（3）类图" class="headerlink" title="（3）类图"></a>（3）类图</h4><p><img src="/2018/11/26/it/design/设计模式/design_pattern_strtegy.jpg" alt=""></p><h3 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h3><h4 id="（1）适用场景-1"><a href="#（1）适用场景-1" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h4><ol><li>产品有<strong>不同的提供商</strong>，不同的提供商提供不同品牌和风味的产品；</li><li>同一提供商有<strong>不同的流水线</strong>，不同的流水线生产不同的产品。</li></ol><h4 id="（2）核心-1"><a href="#（2）核心-1" class="headerlink" title="（2）核心"></a>（2）核心</h4><p>从创建开始就对产品进行了区分，生而不同。</p><h4 id="（3）类图-1"><a href="#（3）类图-1" class="headerlink" title="（3）类图"></a>（3）类图</h4><p><img src="/2018/11/26/it/design/设计模式/design_pattern-abstract factory.jpg" alt=""></p><h3 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h3><h4 id="（1）适用场景-2"><a href="#（1）适用场景-2" class="headerlink" title="（1）适用场景"></a>（1）适用场景</h4><p>将外部服务融合进内部而外部接口与现有服务不兼容（表现在命名、返回值、入参等不同），需要进行适配才能使用时。</p><h4 id="（2）核心-2"><a href="#（2）核心-2" class="headerlink" title="（2）核心"></a>（2）核心</h4><p>使用组合或者多继承，包装旧接口到包装类（或称为适配器）中。使用组合的称之为对象适配器，使用多继承的称之为类适配器。</p><h4 id="（3）类图-2"><a href="#（3）类图-2" class="headerlink" title="（3）类图"></a>（3）类图</h4><p><img src="/2018/11/26/it/design/设计模式/design_pattern-adapter-object.jpg" alt="对象适配器"></p><p><img src="/2018/11/26/it/design/设计模式/design_pattern-adapter-class.jpg" alt="类适配器"></p><h3 id="参考（Reference）"><a href="#参考（Reference）" class="headerlink" title="参考（Reference）"></a>参考（Reference）</h3><ol><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></li><li>Head First 设计模式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;策略模式（Strategy-Pattern）&quot;&gt;&lt;a href=&quot;#策略模式（Strategy-Pattern）&quot; class=&quot;headerlink&quot; title=&quot;策略模式（Strategy Pattern）&quot;&gt;&lt;/a&gt;策略模式（Strategy Patter
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="design" scheme="https://linlshare.github.io/categories/it/design/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="设计模式" scheme="https://linlshare.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>广州生物岛摄影 20181124</title>
    <link href="https://linlshare.github.io/2018/11/24/photography/%E5%B9%BF%E5%B7%9E%E7%94%9F%E7%89%A9%E5%B2%9B%E6%91%84%E5%BD%B1%2020181124/"/>
    <id>https://linlshare.github.io/2018/11/24/photography/广州生物岛摄影 20181124/</id>
    <published>2018-11-24T14:00:12.000Z</published>
    <updated>2018-11-24T15:13:54.930Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>地点</td><td>广州生物岛（官洲岛）</td></tr><tr><td>景点</td><td>水墨园、叠翠园、空旷的道路</td></tr><tr><td>时间</td><td>2018年 11月 24日 上午</td></tr><tr><td>气候</td><td>阳光明媚，温度 25°C</td></tr><tr><td>设备</td><td>Sony RX100 Ⅲ</td></tr><tr><td>主题</td><td>冬天在哪里？</td></tr><tr><td>照片数量</td><td>8/99</td></tr></tbody></table><h3 id="路（Road）"><a href="#路（Road）" class="headerlink" title="路（Road）"></a>路（Road）</h3><h4 id="（1）车道-人行道-水墨园"><a href="#（1）车道-人行道-水墨园" class="headerlink" title="（1）车道-人行道-水墨园"></a>（1）车道-人行道-水墨园</h4><p>生物岛的斑马线是黄白交替的，旁边有如红色地毯的自行车道，另外还有环岛的蓝色自行车道。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/1.0 车道-人行道-水墨园.png" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>增强了饱和度</td><td>拍摄时太亮，导致黄色和红色不明显</td></tr></tbody></table><h4 id="（2）竹林小道"><a href="#（2）竹林小道" class="headerlink" title="（2）竹林小道"></a>（2）竹林小道</h4><p>水墨园里有一片竹林，风吹竹曳，可以解暑气。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/1.1 竹林小道.JPG" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>无</td><td>无</td></tr></tbody></table><h4 id="（3）生锈的水栓-活动的机器人"><a href="#（3）生锈的水栓-活动的机器人" class="headerlink" title="（3）生锈的水栓 - 活动的机器人"></a>（3）生锈的水栓 - 活动的机器人</h4><p>路边看到一锈迹斑斑的水栓，看起来好似一活动的机器人正在分析路况。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/1.2 生锈的水栓-活动的机器人.png" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>增强了亮度</td><td>拍摄时逆光了</td></tr></tbody></table><h4 id="（4）清道夫的单车装备"><a href="#（4）清道夫的单车装备" class="headerlink" title="（4）清道夫的单车装备"></a>（4）清道夫的单车装备</h4><p>道路旁边放着一辆上了锁的单车，车篮放着一顶草帽，货架延伸出一个箩筐，放着扫帚之类的清道工具，装备齐全。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/1.3 清道夫的单车装备.JPG" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>无</td><td>无</td></tr></tbody></table><h3 id="水墨园（Shuimo-Park）"><a href="#水墨园（Shuimo-Park）" class="headerlink" title="水墨园（Shuimo Park）"></a>水墨园（Shuimo Park）</h3><h4 id="（1）建设-完工"><a href="#（1）建设-完工" class="headerlink" title="（1）建设-完工"></a>（1）建设-完工</h4><p>水墨园两边的建筑，一边还在雏形还没建好，一边已经完工了。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/2.0 建设-完工.png" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>一分为二，左边使用黑白+黄色色调处理，右边不做处理</td><td>增强建设中和完工的对比</td></tr></tbody></table><h4 id="（2）屏风-人家"><a href="#（2）屏风-人家" class="headerlink" title="（2）屏风 - 人家"></a>（2）屏风 - 人家</h4><p>水墨园里，接近别墅区的地方有一处做了屏风处理，感觉很是相宜。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/2.1 屏风-人家.JPG" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>无</td><td>无</td></tr></tbody></table><h4 id="（3）奇怪的建筑"><a href="#（3）奇怪的建筑" class="headerlink" title="（3）奇怪的建筑"></a>（3）奇怪的建筑</h4><p>水墨园旁边有一处奇怪的建筑，两边伸出像手臂一样的铁疙瘩，主体部分好像损毁的斗兽场，目前还在维护。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/2.3 奇怪的建筑.JPG" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>无</td><td>无</td></tr></tbody></table><h3 id="中国海警（Chinese-Maritime-Police）"><a href="#中国海警（Chinese-Maritime-Police）" class="headerlink" title="中国海警（Chinese Maritime Police）"></a>中国海警（Chinese Maritime Police）</h3><p>在水墨园偶然间听到军队嘹亮的歌声，往岛边一望，原来是中国海警舰艇的身影，穿着白色 T 恤，肩上有红蓝条纹，前额很尖。</p><p><img src="/2018/11/24/photography/广州生物岛摄影 20181124/3.0 中国海警.png" alt=""></p><table><thead><tr><th>PS</th><th>WHY</th></tr></thead><tbody><tr><td>增强了亮度</td><td>拍摄时逆光了</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;KEY&lt;/th&gt;
&lt;th&gt;VALUE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;地点&lt;/td&gt;
&lt;td&gt;广州生物岛（官洲岛）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;景点&lt;/td&gt;
&lt;td&gt;水墨园、
      
    
    </summary>
    
      <category term="photography" scheme="https://linlshare.github.io/categories/photography/"/>
    
    
      <category term="摄影" scheme="https://linlshare.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="生物岛" scheme="https://linlshare.github.io/tags/%E7%94%9F%E7%89%A9%E5%B2%9B/"/>
    
  </entry>
  
  <entry>
    <title>Guava Cache</title>
    <link href="https://linlshare.github.io/2018/11/23/it/java/guava/Guava%20Cache/"/>
    <id>https://linlshare.github.io/2018/11/23/it/java/guava/Guava Cache/</id>
    <published>2018-11-23T09:32:02.000Z</published>
    <updated>2018-11-23T12:19:39.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-Cache-是做什么的？"><a href="#Guava-Cache-是做什么的？" class="headerlink" title="Guava Cache 是做什么的？"></a>Guava Cache 是做什么的？</h2><p>内存缓存，类似于 ConcurrentMap，支持自动缓存、缓存回收和缓存移除回调。</p><h2 id="两种加载方式"><a href="#两种加载方式" class="headerlink" title="两种加载方式"></a>两种加载方式</h2><h3 id="使用CacheLoader"><a href="#使用CacheLoader" class="headerlink" title="使用CacheLoader"></a>使用CacheLoader</h3><p>当有默认的加载或计算方式使用该方式。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1000</span>)</span><br><span class="line">    .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .removalListener(MY_LISTENER)</span><br><span class="line">    .build(</span><br><span class="line">    <span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createExpensiveValue(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   cache.get(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> OtherException(e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Callable"><a href="#使用-Callable" class="headerlink" title="使用 Callable"></a>使用 Callable</h3><p>当没有默认加载运算，或者想要覆盖默认的加载运算，同时保留 “获取缓存 – 如果没有 – 则计算”（get-if-absent-compute）的原子语义时使用该方式。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;Key, Value&gt; cache =  CacheBuilder.newBuilder()</span><br><span class="line">    .expireAfterWrite(<span class="number">1</span>,TimeUnit.MINUTES)</span><br><span class="line">    .removalListener(<span class="keyword">this</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 1. get</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  cache.get(key, <span class="keyword">new</span> Callable&lt;Value&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> AnyException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> doThingsTheHardWay(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> OtherException(e.getCause());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. getIfPresent</span></span><br><span class="line">cache.getIfPresent(key);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="noopener">CachesExplained - guava</a></li><li><a href="http://ifeve.com/google-guava-cachesexplained/" target="_blank" rel="noopener">[Google Guava] 3-缓存 - 并发编程网</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Guava-Cache-是做什么的？&quot;&gt;&lt;a href=&quot;#Guava-Cache-是做什么的？&quot; class=&quot;headerlink&quot; title=&quot;Guava Cache 是做什么的？&quot;&gt;&lt;/a&gt;Guava Cache 是做什么的？&lt;/h2&gt;&lt;p&gt;内存缓存，类
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="guava" scheme="https://linlshare.github.io/categories/it/java/guava/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="Guava" scheme="https://linlshare.github.io/tags/Guava/"/>
    
      <category term="Cache" scheme="https://linlshare.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://linlshare.github.io/2018/11/22/it/java/base/Kafka/"/>
    <id>https://linlshare.github.io/2018/11/22/it/java/base/Kafka/</id>
    <published>2018-11-22T09:44:02.000Z</published>
    <updated>2018-11-28T15:14:10.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Kafka 是一个快速、可扩展和高可用的基于发布-订阅模式（pub-sub model）的消息系统，用作消息中间件，在系统之间传递消息。其核心概念有：</p><ul><li>Topic（话题）</li><li>Producer（生产者）</li><li>Consumer（消费者）</li><li>Broker（经纪人）</li></ul><p>在 Kafka 中，所有的消息都由 Topic 来组织，Producer 把消息发送到特定的 Topic，Consumer 从特定的 Topic 中读取消息。作为一个分布式系统，Kafka 运行在集群中，集群中的每个节点称之为 Broker。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.1.0/kafka_2.11-2.1.0.tgz" target="_blank" rel="noopener">下载</a>  <code>kafka_2.11-2.1.0.tgz</code>，注意 kafka 中已经包含了 zookeeper。执行以下命令解压并切换工作目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf kafka_2.11-2.1.0.tgz</span><br><span class="line">cd kafka_2.11-2.1.0</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动 zookeeper，默认监听端口 2181</span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line"><span class="meta">#</span> 启动 kafka，默认监听端口 9092</span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 停止 zookeeper</span><br><span class="line">bin/zookeeper-server-stop.sh config/zookeeper.properties</span><br><span class="line"><span class="meta">#</span> 停止 kafka</span><br><span class="line">ps aux | grep kafka | grep -v grep | awk '&#123;print $2&#125;'</span><br><span class="line">kill [pid]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;Kafka 是一个快速、可扩展和高可用的基于发布-订阅模式（pub-sub model）的消息系统，用作消息中间件，在系统之间传递消息。其核
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="Java" scheme="https://linlshare.github.io/tags/Java/"/>
    
      <category term="JavaEE" scheme="https://linlshare.github.io/tags/JavaEE/"/>
    
      <category term="Kafka" scheme="https://linlshare.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>NIO</title>
    <link href="https://linlshare.github.io/2018/11/22/it/java/base/NIO/"/>
    <id>https://linlshare.github.io/2018/11/22/it/java/base/NIO/</id>
    <published>2018-11-22T03:27:06.000Z</published>
    <updated>2018-11-22T11:12:02.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念（NIO-vs-BIO）"><a href="#概念（NIO-vs-BIO）" class="headerlink" title="概念（NIO vs BIO）"></a>概念（NIO vs BIO）</h2><p>NIO, Non-blocking I/O, 非阻塞式 I/O 模型。也可以解释为 New I/O, 区别于旧的阻塞式 I/O 模型（BIO）。</p><p>BIO 与 NIO 的区别如下：</p><table><thead><tr><th>类别</th><th>I/O 方式</th><th>最低可用的 JDK 版本</th></tr></thead><tbody><tr><td>BIO</td><td>流式</td><td>JDK 1.0</td></tr><tr><td>NIO</td><td>块式</td><td>JDK 1.4</td></tr></tbody></table><p>所谓流式处理，就是单个字节的数据移动，通过一个称为 Stream 的对象一次移动一个字节；而块式处理，就是单个字节数组的数据移动，通过一个叫 Buffer 的对象一次移动一个字节数组。JDK 中的 NIO 库已经集成了原来的标准 I/O 功能。</p><h2 id="缓冲区和通道（Buffer-amp-Channel）"><a href="#缓冲区和通道（Buffer-amp-Channel）" class="headerlink" title="缓冲区和通道（Buffer &amp; Channel）"></a>缓冲区和通道（Buffer &amp; Channel）</h2><p>NIO 中的缓冲区（Buffer）实质是一个数组，通常为字节数组（ByteBuffer），用作读写缓冲，以及对数据的结构化访问，还可以用来跟踪系统的读写进程。</p><p>Buffer 类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>NIO 中的通道（Channel）类似 BIO 中的流（Stream），但是是双向的，可以用来读、写或者同时读写。流之所以是单向的，是因为一个 Stream 要么是 InputStream，要么是 OutputStream，不能兼有。</p><h2 id="缓冲区内部细节（Buffer-Internals）"><a href="#缓冲区内部细节（Buffer-Internals）" class="headerlink" title="缓冲区内部细节（Buffer Internals）"></a>缓冲区内部细节（Buffer Internals）</h2><h3 id="状态变量（State-Variables）"><a href="#状态变量（State-Variables）" class="headerlink" title="状态变量（State Variables）"></a>状态变量（State Variables）</h3><ul><li>Position，表征读了或写了多少数据到数组中，指向下一个元素的位置；</li><li>Limit，表征剩余可读或可写的的数据量，初始情况下 Limit = Capacity。</li><li>Capacity，表征 Buffer 的最大容量。</li></ul><p>三者关系：Position &lt;= Limit &lt;= Capacity</p><p>下面从微观角度观察各状态变量在读写操作中的变化：</p><p>（1） Init</p><p>初始状态下，Position 指向第一个元素的位置，Limit 和 Capacity 指向最后一个元素的下一个虚拟元素的位置。由于 Capacity 保持不变，下面的讨论中予以略过。</p><p><img src="/2018/11/22/it/java/base/NIO/NIO-state-init.png" alt=""></p><p>（2）Channel.read</p><p>读取 5 个元素到缓冲区后，Position 指向第六个元素的位置，Limit 不变。</p><p><img src="/2018/11/22/it/java/base/NIO/NIO-state-read.png" alt=""></p><p>（3）Buffer.flip</p><p>进行 Flip 操作后，Limit 指向当前的 Position 的位置，Position 指回第一个元素的位置，</p><p><img src="/2018/11/22/it/java/base/NIO/NIO-state-flip.png" alt=""></p><p>（4）Channel.write</p><p>从缓冲区读取 5 个元素写入 Channel 后，Position 指向 Limit 所在的位置。</p><p><img src="/2018/11/22/it/java/base/NIO/NIO-state-write-2.png" alt=""></p><p>（5）Buffer.clear</p><p>clear 后缓冲区重置到初始状态。</p><p><img src="/2018/11/22/it/java/base/NIO/NIO-state-clear.png" alt=""></p><h3 id="存取方法（Accessor-）"><a href="#存取方法（Accessor-）" class="headerlink" title="存取方法（Accessor ）"></a>存取方法（Accessor ）</h3><p>存取方法分为：</p><ul><li>相对方法（Relative Method）：在当前 position 进行读写操作，随后 position 自增1。</li><li>绝对方法（Absolute Method）：在某个索引位置进行读写操作，不影响 position 和 limit。</li></ul><p>（1）get 系列方法（包括 <code>array()</code> )，用于读取缓冲区的数据，其中 <code>byte get(int index)</code>  为绝对方法。</p><p>（2）put 系列方法，用于写入数据到缓冲区，其中 <code>ByteBuffer put(int index, byte b)</code> 为绝对方法。</p><h2 id="使用（Show-U-the-Code）"><a href="#使用（Show-U-the-Code）" class="headerlink" title="使用（Show U the Code）"></a>使用（Show U the Code）</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ol><li>从 FileInputStream 中获取 Channel；</li><li>创建 Buffer；</li><li>将数据从 Channel 读到 Buffer 中。</li></ol><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 a_file 读到 StringBuilder 中</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"/path/to/a_file"</span>);</span><br><span class="line">FileChannel fc = fin.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (fc.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">    sb.append(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.position()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><ol><li>从 FileOutputStream 中获取 Channel；</li><li>创建 Buffer；</li><li>写入数据到 Buffer；</li><li>将数据从 Buffer 写入 Channel 中。</li></ol><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 "Something" 写入 a_file 中</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"/path/to/a_file"</span>);</span><br><span class="line">FileChannel fc = fos.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] content = <span class="string">"Something"</span>.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> aContent : content) &#123;</span><br><span class="line">    buffer.put(aContent);</span><br><span class="line">&#125;</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">fc.write(buffer);</span><br></pre></td></tr></table></figure><h3 id="边读边写"><a href="#边读边写" class="headerlink" title="边读边写"></a>边读边写</h3><ol><li>清除 Buffer；</li><li>从输入流的 Channel 读数据到 Buffer；</li><li>写入 Buffer 中的数据到输出流的 Channel；</li><li>循环直到输入流的 Channel 中没有数据。</li></ol><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"path/to/in_file"</span>);</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"path/to/out_file"</span>);</span><br><span class="line"></span><br><span class="line">FileChannel fcin = fin.getChannel();</span><br><span class="line">FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    buffer.clear();</span><br><span class="line">    <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line">    <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    fcout.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门 - IBM</a></li><li><a href="https://www.ibm.com/developerworks/java/tutorials/j-nio/j-nio.html" target="_blank" rel="noopener">Getting started with new I/O (NIO) - IBM</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念（NIO-vs-BIO）&quot;&gt;&lt;a href=&quot;#概念（NIO-vs-BIO）&quot; class=&quot;headerlink&quot; title=&quot;概念（NIO vs BIO）&quot;&gt;&lt;/a&gt;概念（NIO vs BIO）&lt;/h2&gt;&lt;p&gt;NIO, Non-blocking I/O,
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="Java" scheme="https://linlshare.github.io/tags/Java/"/>
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="NIO" scheme="https://linlshare.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="https://linlshare.github.io/2018/11/22/it/java/base/Netty/"/>
    <id>https://linlshare.github.io/2018/11/22/it/java/base/Netty/</id>
    <published>2018-11-22T03:23:41.000Z</published>
    <updated>2018-11-30T04:08:10.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty-是干什么的？"><a href="#Netty-是干什么的？" class="headerlink" title="Netty 是干什么的？"></a>Netty 是干什么的？</h2><p>Netty 是一个 NIO 客户端服务器框架，用于快速开发网络应用。</p><p>支持扩展协议。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>（1）引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">"io.netty:netty-all:4.1.+"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netty-是干什么的？&quot;&gt;&lt;a href=&quot;#Netty-是干什么的？&quot; class=&quot;headerlink&quot; title=&quot;Netty 是干什么的？&quot;&gt;&lt;/a&gt;Netty 是干什么的？&lt;/h2&gt;&lt;p&gt;Netty 是一个 NIO 客户端服务器框架，用于快速开发网
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="java" scheme="https://linlshare.github.io/categories/it/java/"/>
    
      <category term="base" scheme="https://linlshare.github.io/categories/it/java/base/"/>
    
    
      <category term="Java" scheme="https://linlshare.github.io/tags/Java/"/>
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="Netty" scheme="https://linlshare.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>服务鉴权机制</title>
    <link href="https://linlshare.github.io/2018/11/21/it/secure/%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
    <id>https://linlshare.github.io/2018/11/21/it/secure/服务鉴权机制/</id>
    <published>2018-11-21T09:31:26.000Z</published>
    <updated>2018-11-21T09:56:07.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Token-验证机制"><a href="#Token-验证机制" class="headerlink" title="Token 验证机制"></a>Token 验证机制</h2><p>Token 是一个字符串，由服务端生成，用于保证请求的有效性，过滤掉非法的请求。一个 Token 可以由以下三部分组成：</p><ul><li>Token 字符串（token），可以是 UUID；</li><li>生成时的时间戳（timestamp）；</li><li>校验因子（sign），由 <code>token + timestamp</code>，通过一定的规则（比如 MD5）生成。</li></ul><p>示例（<code>sg = md5(tk+&quot;*&quot;+tm+&quot;*&quot;+&quot;k2@sz8-iA&quot;</code>）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tk"</span>:<span class="string">"116b6451-6028-4490-8869-d32a84082b7c"</span>,</span><br><span class="line">    <span class="attr">"tm"</span>:<span class="string">"1536595200000"</span>,</span><br><span class="line">    <span class="attr">"sg"</span>:<span class="string">"91672a6af6d7d078676e2b26e8396ea1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当请求到达客户端时，我们先用先前的规则构造一个 md5 值，看与请求中的 sg 字段值是否相同，再判定 当前的时间戳与 tm 中的时间戳差值是否不超过预定义的过期时长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Token-验证机制&quot;&gt;&lt;a href=&quot;#Token-验证机制&quot; class=&quot;headerlink&quot; title=&quot;Token 验证机制&quot;&gt;&lt;/a&gt;Token 验证机制&lt;/h2&gt;&lt;p&gt;Token 是一个字符串，由服务端生成，用于保证请求的有效性，过滤掉非法的请
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="secure" scheme="https://linlshare.github.io/categories/it/secure/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="Secure" scheme="https://linlshare.github.io/tags/Secure/"/>
    
  </entry>
  
  <entry>
    <title>FSM</title>
    <link href="https://linlshare.github.io/2018/11/21/it/code/FSM/"/>
    <id>https://linlshare.github.io/2018/11/21/it/code/FSM/</id>
    <published>2018-11-21T07:37:25.000Z</published>
    <updated>2018-11-21T08:44:59.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>FSM, Finite State Machine 有限状态机，是一种数学计算模型，在任意给定的时刻只会存在在给定的有限状态中的一个。FSM 会在特定的外部输入条件下发生从一个状态到另一状态的改变，这个过程叫状态转移（transition）。</p><p>一个 FSM 由以下部分构成：</p><ul><li>状态表（a list of its states）</li><li>初始状态（Initial state）</li><li>每个转移的条件（the conditions for each transition）</li></ul><p>另外，在自动机理论中，FSM 也叫做 DFA（Deterministic Finite Automaton, 确定性有限自动机），与 NFA（Nondeterministic Finite Automaton, 非确定性有限自动机）相对。DFA 的特点是：</p><ul><li>每个状态转移由当前状态和输入唯一确定；</li><li>每次状态转移都要读取输入。</li></ul><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><h3 id="状态转移表（State-Transition-Table）"><a href="#状态转移表（State-Transition-Table）" class="headerlink" title="状态转移表（State Transition Table）"></a>状态转移表（State Transition Table）</h3><table><thead><tr><th>当前状态→ <br>条件↓</th><th>状态A</th><th>状态B</th><th>状态C</th></tr></thead><tbody><tr><td>条件X</td><td>…</td><td>…</td><td>…</td></tr><tr><td>条件Y</td><td>…</td><td>状态C</td><td>…</td></tr><tr><td>条件Z</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>状态转移表描述了当某个状态下触发某个条件会达到什么状态。下面以投币式旋转门为例：</p><p><img src="/2018/11/21/it/code/FSM/投币式旋转门.jpg" alt=""></p><table><thead><tr><th>当前状态→ <br>条件↓</th><th>锁定</th><th>解锁</th></tr></thead><tbody><tr><td>推动旋转杠</td><td>锁定</td><td>锁定</td></tr><tr><td>投币</td><td>解锁</td><td>解锁</td></tr></tbody></table><h3 id="UML-状态机（UML-State-Machines）"><a href="#UML-状态机（UML-State-Machines）" class="headerlink" title="UML 状态机（UML State Machines）"></a>UML 状态机（UML State Machines）</h3><p><img src="/2018/11/21/it/code/FSM/FSM_UML.png" alt=""></p><p>使用 UML 语言在 <a href="https://draw.io" target="_blank" rel="noopener">draw.io</a> 上绘制上述的投币式旋转门的状态图如下：</p><p><img src="/2018/11/21/it/code/FSM/投币式旋转门状态图.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">Finite-state mathine - wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;FSM, Finite State Machine 有限状态机，是一种数学计算模型，在任意给定的时刻只会存在在给定的有限状态中的一个。FSM
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="code" scheme="https://linlshare.github.io/categories/it/code/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="FSM" scheme="https://linlshare.github.io/tags/FSM/"/>
    
  </entry>
  
  <entry>
    <title>NAS</title>
    <link href="https://linlshare.github.io/2018/11/21/it/concept/NAS/"/>
    <id>https://linlshare.github.io/2018/11/21/it/concept/NAS/</id>
    <published>2018-11-21T06:36:20.000Z</published>
    <updated>2018-11-28T14:09:04.387Z</updated>
    
    <content type="html"><![CDATA[<p>NAS, Network Attached Storage, 网络附属存储, 简单来说就是连接在网络上, 可以存储资料的装置。可以用来做私有网盘，同步各种设备的照片、视频、音频和文件。</p><p>常见的 NAS 硬件有：</p><ul><li>群晖 / 威联通</li><li>惠普 ProLiant MicroServer</li><li>Acer Altos C100 F3</li></ul><p>常见的 NAS 软件有：</p><ul><li>Nextcloud</li><li>Owncloud</li><li>Seefile</li><li>群晖 / 威联通系列软件</li></ul><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/21359049" target="_blank" rel="noopener">搭建家庭 NAS 服务器有什么好方案？ - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NAS, Network Attached Storage, 网络附属存储, 简单来说就是连接在网络上, 可以存储资料的装置。可以用来做私有网盘，同步各种设备的照片、视频、音频和文件。&lt;/p&gt;
&lt;p&gt;常见的 NAS 硬件有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;群晖 / 威联通&lt;/l
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="concept" scheme="https://linlshare.github.io/categories/it/concept/"/>
    
    
      <category term="IT" scheme="https://linlshare.github.io/tags/IT/"/>
    
      <category term="NAS" scheme="https://linlshare.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://linlshare.github.io/2018/11/20/it/tool/Markdown/"/>
    <id>https://linlshare.github.io/2018/11/20/it/tool/Markdown/</id>
    <published>2018-11-20T12:41:20.000Z</published>
    <updated>2018-11-22T09:28:17.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在表格中输入管道符（-）"><a href="#在表格中输入管道符（-）" class="headerlink" title="在表格中输入管道符（|）"></a>在表格中输入管道符（|）</h2><p>管道符与表格分隔字段用的相冲突，会导致表格显示不正常，解决方案是：使用 <code>&amp;#124;</code>  代替 <code>|</code> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在表格中输入管道符（-）&quot;&gt;&lt;a href=&quot;#在表格中输入管道符（-）&quot; class=&quot;headerlink&quot; title=&quot;在表格中输入管道符（|）&quot;&gt;&lt;/a&gt;在表格中输入管道符（|）&lt;/h2&gt;&lt;p&gt;管道符与表格分隔字段用的相冲突，会导致表格显示不正常，解决方
      
    
    </summary>
    
      <category term="it" scheme="https://linlshare.github.io/categories/it/"/>
    
      <category term="tool" scheme="https://linlshare.github.io/categories/it/tool/"/>
    
    
      <category term="Markdown" scheme="https://linlshare.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
